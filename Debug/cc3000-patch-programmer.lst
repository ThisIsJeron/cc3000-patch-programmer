
cc3000-patch-programmer.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000010c  08000000  08000000  00008000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000523c  0800010c  0800010c  0000810c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .data         00000070  20000000  08005348  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          0000099c  20000070  080053b8  00010070  2**2
                  ALLOC
  4 ._usrstack    00000100  20000a0c  08005d54  00010070  2**0
                  ALLOC
  5 .comment      00000070  00000000  00000000  00010070  2**0
                  CONTENTS, READONLY
  6 .ARM.attributes 0000002f  00000000  00000000  000100e0  2**0
                  CONTENTS, READONLY
  7 .debug_aranges 00000b30  00000000  00000000  00010110  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   0000c873  00000000  00000000  00010c40  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 000027f5  00000000  00000000  0001d4b3  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   00007c2d  00000000  00000000  0001fca8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  00001ae0  00000000  00000000  000278d8  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    0004c26a  00000000  00000000  000293b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    00006e1d  00000000  00000000  00075622  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000b68  00000000  00000000  0007c440  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_macro  0000fa03  00000000  00000000  0007cfa8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0800010c <Reset_Handler>:
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:	

/* Copy the data segment initializers from flash to SRAM */  
  movs	r1, #0
 800010c:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 800010e:	f000 b804 	b.w	800011a <LoopCopyDataInit>

08000112 <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 8000112:	4b0c      	ldr	r3, [pc, #48]	; (8000144 <LoopFillZerobss+0x12>)
	ldr	r3, [r3, r1]
 8000114:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 8000116:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 8000118:	3104      	adds	r1, #4

0800011a <LoopCopyDataInit>:
    
LoopCopyDataInit:
	ldr	r0, =_sdata
 800011a:	480b      	ldr	r0, [pc, #44]	; (8000148 <LoopFillZerobss+0x16>)
	ldr	r3, =_edata
 800011c:	4b0b      	ldr	r3, [pc, #44]	; (800014c <LoopFillZerobss+0x1a>)
	adds	r2, r0, r1
 800011e:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 8000120:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 8000122:	f4ff aff6 	bcc.w	8000112 <CopyDataInit>
	ldr	r2, =_sbss
 8000126:	4a0a      	ldr	r2, [pc, #40]	; (8000150 <LoopFillZerobss+0x1e>)
	b	LoopFillZerobss
 8000128:	f000 b803 	b.w	8000132 <LoopFillZerobss>

0800012c <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
	movs	r3, #0
 800012c:	2300      	movs	r3, #0
	str	r3, [r2], #4
 800012e:	f842 3b04 	str.w	r3, [r2], #4

08000132 <LoopFillZerobss>:
    
LoopFillZerobss:
	ldr	r3, = _ebss
 8000132:	4b08      	ldr	r3, [pc, #32]	; (8000154 <LoopFillZerobss+0x22>)
	cmp	r2, r3
 8000134:	429a      	cmp	r2, r3
	bcc	FillZerobss
 8000136:	f4ff aff9 	bcc.w	800012c <FillZerobss>
/* Call the clock system intitialization function.*/
  bl  SystemInit 	
 800013a:	f000 fea1 	bl	8000e80 <SystemInit>
/* Call the application's entry point.*/
	bl	main
 800013e:	f000 fe23 	bl	8000d88 <main>
	bx	lr    
 8000142:	4770      	bx	lr
/* Copy the data segment initializers from flash to SRAM */  
  movs	r1, #0
  b	LoopCopyDataInit

CopyDataInit:
	ldr	r3, =_sidata
 8000144:	08005348 	.word	0x08005348
	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
	adds	r1, r1, #4
    
LoopCopyDataInit:
	ldr	r0, =_sdata
 8000148:	20000000 	.word	0x20000000
	ldr	r3, =_edata
 800014c:	20000070 	.word	0x20000070
	adds	r2, r0, r1
	cmp	r2, r3
	bcc	CopyDataInit
	ldr	r2, =_sbss
 8000150:	20000070 	.word	0x20000070
FillZerobss:
	movs	r3, #0
	str	r3, [r2], #4
    
LoopFillZerobss:
	ldr	r3, = _ebss
 8000154:	20000a0c 	.word	0x20000a0c

08000158 <ADC1_2_IRQHandler>:
 * @retval None       
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 8000158:	f7ff bffe 	b.w	8000158 <ADC1_2_IRQHandler>

0800015c <SpiOpen>:

/****************************************************************************
 CC3000 SPI Protocol API
 ****************************************************************************/
void SpiOpen(gcSpiHandleRx pfRxHandler)
{
 800015c:	b508      	push	{r3, lr}
	sSpiInformation.ulSpiState = eSPI_STATE_POWERUP;
 800015e:	4b06      	ldr	r3, [pc, #24]	; (8000178 <SpiOpen+0x1c>)
 8000160:	2200      	movs	r2, #0

	sSpiInformation.SPIRxHandler = pfRxHandler;
 8000162:	6018      	str	r0, [r3, #0]
	sSpiInformation.pRxPacket = wlan_rx_buffer;
 8000164:	4905      	ldr	r1, [pc, #20]	; (800017c <SpiOpen+0x20>)
	sSpiInformation.usRxPacketLength = 0;
	sSpiInformation.pTxPacket = NULL;
	sSpiInformation.usTxPacketLength = 0;

	/* Enable Interrupt */
	tSLInformation.WlanInterruptEnable();
 8000166:	4806      	ldr	r0, [pc, #24]	; (8000180 <SpiOpen+0x24>)
/****************************************************************************
 CC3000 SPI Protocol API
 ****************************************************************************/
void SpiOpen(gcSpiHandleRx pfRxHandler)
{
	sSpiInformation.ulSpiState = eSPI_STATE_POWERUP;
 8000168:	609a      	str	r2, [r3, #8]

	sSpiInformation.SPIRxHandler = pfRxHandler;
	sSpiInformation.pRxPacket = wlan_rx_buffer;
 800016a:	6119      	str	r1, [r3, #16]
	sSpiInformation.usRxPacketLength = 0;
 800016c:	80da      	strh	r2, [r3, #6]
	sSpiInformation.pTxPacket = NULL;
 800016e:	60da      	str	r2, [r3, #12]
	sSpiInformation.usTxPacketLength = 0;
 8000170:	809a      	strh	r2, [r3, #4]

	/* Enable Interrupt */
	tSLInformation.WlanInterruptEnable();
 8000172:	6a03      	ldr	r3, [r0, #32]
 8000174:	4798      	blx	r3
 8000176:	bd08      	pop	{r3, pc}
 8000178:	20000084 	.word	0x20000084
 800017c:	20000498 	.word	0x20000498
 8000180:	200009b8 	.word	0x200009b8

08000184 <SpiClose>:
}

void SpiClose(void)
{
 8000184:	b508      	push	{r3, lr}
	if (sSpiInformation.pRxPacket)
 8000186:	4b04      	ldr	r3, [pc, #16]	; (8000198 <SpiClose+0x14>)
 8000188:	691a      	ldr	r2, [r3, #16]
 800018a:	b10a      	cbz	r2, 8000190 <SpiClose+0xc>
	{
		sSpiInformation.pRxPacket = 0;
 800018c:	2000      	movs	r0, #0
 800018e:	6118      	str	r0, [r3, #16]
	}

	/* Disable Interrupt */
	tSLInformation.WlanInterruptDisable();
 8000190:	4902      	ldr	r1, [pc, #8]	; (800019c <SpiClose+0x18>)
 8000192:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 8000194:	4798      	blx	r3
 8000196:	bd08      	pop	{r3, pc}
 8000198:	20000084 	.word	0x20000084
 800019c:	200009b8 	.word	0x200009b8

080001a0 <SpiResumeSpi>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i");
 80001a0:	b662      	cpsie	i
 80001a2:	4770      	bx	lr

080001a4 <SpiTriggerRxProcessing>:
 to process the received data
 * @param  None
 * @retval None
 */
void SpiTriggerRxProcessing(void)
{
 80001a4:	b508      	push	{r3, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i");
 80001a6:	b672      	cpsid	i
	SpiPauseSpi();

	//
	// Trigger Rx processing
	//
	DEASSERT_CS();
 80001a8:	4806      	ldr	r0, [pc, #24]	; (80001c4 <SpiTriggerRxProcessing+0x20>)
 80001aa:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 80001ae:	f001 f891 	bl	80012d4 <GPIO_SetBits>
	sSpiInformation.ulSpiState = eSPI_STATE_IDLE;
 80001b2:	4b05      	ldr	r3, [pc, #20]	; (80001c8 <SpiTriggerRxProcessing+0x24>)
 80001b4:	2202      	movs	r2, #2
	sSpiInformation.SPIRxHandler(sSpiInformation.pRxPacket + SPI_HEADER_SIZE);
 80001b6:	6918      	ldr	r0, [r3, #16]

	//
	// Trigger Rx processing
	//
	DEASSERT_CS();
	sSpiInformation.ulSpiState = eSPI_STATE_IDLE;
 80001b8:	609a      	str	r2, [r3, #8]
	sSpiInformation.SPIRxHandler(sSpiInformation.pRxPacket + SPI_HEADER_SIZE);
 80001ba:	6819      	ldr	r1, [r3, #0]
 80001bc:	3005      	adds	r0, #5
 80001be:	4788      	blx	r1
 80001c0:	bd08      	pop	{r3, pc}
 80001c2:	bf00      	nop
 80001c4:	40010c00 	.word	0x40010c00
 80001c8:	20000084 	.word	0x20000084

080001cc <SpiReadWriteStringInt>:
 * @param  ptrData Pointer to data to be written
 * @param  ulDataSize The size of the data to be written or read
 * @retval None
 */
void SpiReadWriteStringInt(uint32_t ulTrueFalse, const uint8_t *ptrData, uint32_t ulDataSize)
{
 80001cc:	b570      	push	{r4, r5, r6, lr}
 80001ce:	4606      	mov	r6, r0
	/* Delay for at lest 50 us at the start of every transfer */
	SysCtlDelay(FIFTY_US_DELAY);

	/* Disable DMA Channels */
	CC3000_SPI_DMA_Channels(DISABLE);
 80001d0:	2000      	movs	r0, #0
 * @param  ptrData Pointer to data to be written
 * @param  ulDataSize The size of the data to be written or read
 * @retval None
 */
void SpiReadWriteStringInt(uint32_t ulTrueFalse, const uint8_t *ptrData, uint32_t ulDataSize)
{
 80001d2:	4614      	mov	r4, r2
 80001d4:	460d      	mov	r5, r1
	/* Delay for at lest 50 us at the start of every transfer */
	SysCtlDelay(FIFTY_US_DELAY);

	/* Disable DMA Channels */
	CC3000_SPI_DMA_Channels(DISABLE);
 80001d6:	f000 fbfd 	bl	80009d4 <CC3000_SPI_DMA_Channels>

	if (ulTrueFalse == TRUE)
 80001da:	2e01      	cmp	r6, #1
 80001dc:	b2a4      	uxth	r4, r4
 80001de:	d107      	bne.n	80001f0 <SpiReadWriteStringInt+0x24>
	{
		CC3000_DMA_Config(CC3000_DMA_RX, (uint8_t*) ptrData, ulDataSize);
 80001e0:	4630      	mov	r0, r6
 80001e2:	4629      	mov	r1, r5
 80001e4:	4622      	mov	r2, r4
 80001e6:	f000 fb7d 	bl	80008e4 <CC3000_DMA_Config>
		CC3000_DMA_Config(CC3000_DMA_TX, (uint8_t*) tSpiReadHeader, ulDataSize);
 80001ea:	2000      	movs	r0, #0
 80001ec:	4912      	ldr	r1, [pc, #72]	; (8000238 <SpiReadWriteStringInt+0x6c>)
 80001ee:	e007      	b.n	8000200 <SpiReadWriteStringInt+0x34>
	}
	else
	{
		CC3000_DMA_Config(CC3000_DMA_RX, (uint8_t*) sSpiInformation.pRxPacket, ulDataSize);
 80001f0:	4b12      	ldr	r3, [pc, #72]	; (800023c <SpiReadWriteStringInt+0x70>)
 80001f2:	2001      	movs	r0, #1
 80001f4:	6919      	ldr	r1, [r3, #16]
 80001f6:	4622      	mov	r2, r4
 80001f8:	f000 fb74 	bl	80008e4 <CC3000_DMA_Config>
		CC3000_DMA_Config(CC3000_DMA_TX, (uint8_t*) ptrData, ulDataSize);
 80001fc:	2000      	movs	r0, #0
 80001fe:	4629      	mov	r1, r5
 8000200:	4622      	mov	r2, r4
 8000202:	f000 fb6f 	bl	80008e4 <CC3000_DMA_Config>
	}

	/* Enable DMA SPI Interrupt */
	DMA_ITConfig(CC3000_SPI_TX_DMA_CHANNEL, DMA_IT_TC, ENABLE);
 8000206:	480e      	ldr	r0, [pc, #56]	; (8000240 <SpiReadWriteStringInt+0x74>)
 8000208:	2102      	movs	r1, #2
 800020a:	2201      	movs	r2, #1
 800020c:	f000 ff97 	bl	800113e <DMA_ITConfig>

	/* Enable DMA Channels */
	CC3000_SPI_DMA_Channels(ENABLE);
 8000210:	2001      	movs	r0, #1
 8000212:	f000 fbdf 	bl	80009d4 <CC3000_SPI_DMA_Channels>

	/* Wait until DMA Transfer Completes */
	while(DMA_GetCurrDataCounter(CC3000_SPI_TX_DMA_CHANNEL))
 8000216:	480a      	ldr	r0, [pc, #40]	; (8000240 <SpiReadWriteStringInt+0x74>)
 8000218:	f000 ff99 	bl	800114e <DMA_GetCurrDataCounter>
 800021c:	2800      	cmp	r0, #0
 800021e:	d1fa      	bne.n	8000216 <SpiReadWriteStringInt+0x4a>
	{
	}

	while(DMA_GetCurrDataCounter(CC3000_SPI_RX_DMA_CHANNEL))
 8000220:	4808      	ldr	r0, [pc, #32]	; (8000244 <SpiReadWriteStringInt+0x78>)
 8000222:	f000 ff94 	bl	800114e <DMA_GetCurrDataCounter>
 8000226:	2800      	cmp	r0, #0
 8000228:	d1fa      	bne.n	8000220 <SpiReadWriteStringInt+0x54>
	{
	}

	/* Loop until SPI busy */
	while (SPI_I2S_GetFlagStatus(CC3000_SPI, SPI_I2S_FLAG_BSY ) != RESET)
 800022a:	4807      	ldr	r0, [pc, #28]	; (8000248 <SpiReadWriteStringInt+0x7c>)
 800022c:	2180      	movs	r1, #128	; 0x80
 800022e:	f001 f8cd 	bl	80013cc <SPI_I2S_GetFlagStatus>
 8000232:	2800      	cmp	r0, #0
 8000234:	d1f9      	bne.n	800022a <SpiReadWriteStringInt+0x5e>
	{
	}
}
 8000236:	bd70      	pop	{r4, r5, r6, pc}
 8000238:	20000000 	.word	0x20000000
 800023c:	20000084 	.word	0x20000084
 8000240:	40020058 	.word	0x40020058
 8000244:	40020044 	.word	0x40020044
 8000248:	40003800 	.word	0x40003800

0800024c <SpiReadData>:
 * @param  The pointer to data buffer
 * @param  This size of data
 * @retval None
 */
void SpiReadData(unsigned char *data, unsigned short size)
{
 800024c:	4603      	mov	r3, r0
 800024e:	460a      	mov	r2, r1
	SpiReadWriteStringInt(TRUE, data, size);
 8000250:	2001      	movs	r0, #1
 8000252:	4619      	mov	r1, r3
 8000254:	f7ff bfba 	b.w	80001cc <SpiReadWriteStringInt>

08000258 <SpiReadWriteString>:
 * @param  ptrData Pointer to data to be written
 * @param  ulDataSize The size of the data to be written or read
 * @retval None
 */
void SpiReadWriteString(uint32_t ulTrueFalse, const uint8_t *ptrData, uint32_t ulDataSize)
{
 8000258:	b570      	push	{r4, r5, r6, lr}
 800025a:	4606      	mov	r6, r0
	SysCtlDelay(FIFTY_US_DELAY);

	/* Disable DMA RX Channels */
	CC3000_SPI_DMA_Channels(DISABLE);
 800025c:	2000      	movs	r0, #0
 * @param  ptrData Pointer to data to be written
 * @param  ulDataSize The size of the data to be written or read
 * @retval None
 */
void SpiReadWriteString(uint32_t ulTrueFalse, const uint8_t *ptrData, uint32_t ulDataSize)
{
 800025e:	4614      	mov	r4, r2
 8000260:	460d      	mov	r5, r1
	SysCtlDelay(FIFTY_US_DELAY);

	/* Disable DMA RX Channels */
	CC3000_SPI_DMA_Channels(DISABLE);
 8000262:	f000 fbb7 	bl	80009d4 <CC3000_SPI_DMA_Channels>

	/* Specify the DMA Read/Write buffer and size */
	if (ulTrueFalse == TRUE)
 8000266:	2e01      	cmp	r6, #1
 8000268:	b2a4      	uxth	r4, r4
 800026a:	d107      	bne.n	800027c <SpiReadWriteString+0x24>
	{
		CC3000_DMA_Config(CC3000_DMA_RX, (uint8_t*) ptrData, ulDataSize);
 800026c:	4630      	mov	r0, r6
 800026e:	4629      	mov	r1, r5
 8000270:	4622      	mov	r2, r4
 8000272:	f000 fb37 	bl	80008e4 <CC3000_DMA_Config>
		CC3000_DMA_Config(CC3000_DMA_TX, (uint8_t*) tSpiReadHeader, ulDataSize);
 8000276:	2000      	movs	r0, #0
 8000278:	4910      	ldr	r1, [pc, #64]	; (80002bc <SpiReadWriteString+0x64>)
 800027a:	e007      	b.n	800028c <SpiReadWriteString+0x34>
	}
	else
	{
		CC3000_DMA_Config(CC3000_DMA_RX, (uint8_t*) sSpiInformation.pRxPacket, ulDataSize);
 800027c:	4b10      	ldr	r3, [pc, #64]	; (80002c0 <SpiReadWriteString+0x68>)
 800027e:	2001      	movs	r0, #1
 8000280:	6919      	ldr	r1, [r3, #16]
 8000282:	4622      	mov	r2, r4
 8000284:	f000 fb2e 	bl	80008e4 <CC3000_DMA_Config>
		CC3000_DMA_Config(CC3000_DMA_TX, (uint8_t*) ptrData, ulDataSize);
 8000288:	2000      	movs	r0, #0
 800028a:	4629      	mov	r1, r5
 800028c:	4622      	mov	r2, r4
 800028e:	f000 fb29 	bl	80008e4 <CC3000_DMA_Config>
	}

	/* Enable DMA Channels */
	CC3000_SPI_DMA_Channels(ENABLE);
 8000292:	2001      	movs	r0, #1
 8000294:	f000 fb9e 	bl	80009d4 <CC3000_SPI_DMA_Channels>

	/* Wait until DMA Transfer Completes */
	while(DMA_GetCurrDataCounter(CC3000_SPI_TX_DMA_CHANNEL))
 8000298:	480a      	ldr	r0, [pc, #40]	; (80002c4 <SpiReadWriteString+0x6c>)
 800029a:	f000 ff58 	bl	800114e <DMA_GetCurrDataCounter>
 800029e:	2800      	cmp	r0, #0
 80002a0:	d1fa      	bne.n	8000298 <SpiReadWriteString+0x40>
	{
	}

	while(DMA_GetCurrDataCounter(CC3000_SPI_RX_DMA_CHANNEL))
 80002a2:	4809      	ldr	r0, [pc, #36]	; (80002c8 <SpiReadWriteString+0x70>)
 80002a4:	f000 ff53 	bl	800114e <DMA_GetCurrDataCounter>
 80002a8:	2800      	cmp	r0, #0
 80002aa:	d1fa      	bne.n	80002a2 <SpiReadWriteString+0x4a>
	{
	}

	/* Loop until SPI busy */
	while (SPI_I2S_GetFlagStatus(CC3000_SPI, SPI_I2S_FLAG_BSY ) != RESET)
 80002ac:	4807      	ldr	r0, [pc, #28]	; (80002cc <SpiReadWriteString+0x74>)
 80002ae:	2180      	movs	r1, #128	; 0x80
 80002b0:	f001 f88c 	bl	80013cc <SPI_I2S_GetFlagStatus>
 80002b4:	2800      	cmp	r0, #0
 80002b6:	d1f9      	bne.n	80002ac <SpiReadWriteString+0x54>
	{
	}
}
 80002b8:	bd70      	pop	{r4, r5, r6, pc}
 80002ba:	bf00      	nop
 80002bc:	20000000 	.word	0x20000000
 80002c0:	20000084 	.word	0x20000084
 80002c4:	40020058 	.word	0x40020058
 80002c8:	40020044 	.word	0x40020044
 80002cc:	40003800 	.word	0x40003800

080002d0 <SpiWriteAsync>:
 * @brief  This sends data over the SPI transport layer with
 * @param  None
 * @retval None
 */
void SpiWriteAsync(const unsigned char *data, unsigned short size)
{
 80002d0:	4603      	mov	r3, r0
 80002d2:	460a      	mov	r2, r1
	//
	// The DMA TX/RX channel must be disabled.
	//
	SpiReadWriteString(FALSE, data, size);
 80002d4:	2000      	movs	r0, #0
 80002d6:	4619      	mov	r1, r3
 80002d8:	f7ff bfbe 	b.w	8000258 <SpiReadWriteString>

080002dc <SpiFirstWrite>:
 * @brief  Sends header information to CC3000
 * @param  None
 * @retval None
 */
long SpiFirstWrite(unsigned char *ucBuf, unsigned short usLength)
{
 80002dc:	b570      	push	{r4, r5, r6, lr}
	//
	// workaround for first transaction
	//
	ASSERT_CS();
 80002de:	4d0e      	ldr	r5, [pc, #56]	; (8000318 <SpiFirstWrite+0x3c>)
 * @brief  Sends header information to CC3000
 * @param  None
 * @retval None
 */
long SpiFirstWrite(unsigned char *ucBuf, unsigned short usLength)
{
 80002e0:	4604      	mov	r4, r0
 80002e2:	460e      	mov	r6, r1
	//
	// workaround for first transaction
	//
	ASSERT_CS();
 80002e4:	4628      	mov	r0, r5
 80002e6:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 80002ea:	f000 fff5 	bl	80012d8 <GPIO_ResetBits>

	//SPI writes first 4 bytes of data
	SpiReadWriteString(FALSE, ucBuf, 4);
 80002ee:	2000      	movs	r0, #0
 80002f0:	4621      	mov	r1, r4
 80002f2:	2204      	movs	r2, #4
 80002f4:	f7ff ffb0 	bl	8000258 <SpiReadWriteString>
	//SPI writes next 4 bytes of data
	SpiReadWriteString(FALSE, ucBuf + 4, usLength - 4);
 80002f8:	2000      	movs	r0, #0
 80002fa:	1d21      	adds	r1, r4, #4
 80002fc:	1f32      	subs	r2, r6, #4
 80002fe:	f7ff ffab 	bl	8000258 <SpiReadWriteString>

	// From this point on - operate in a regular way
	sSpiInformation.ulSpiState = eSPI_STATE_IDLE;
 8000302:	4b06      	ldr	r3, [pc, #24]	; (800031c <SpiFirstWrite+0x40>)
 8000304:	2202      	movs	r2, #2

	DEASSERT_CS();
 8000306:	4628      	mov	r0, r5
 8000308:	f44f 5180 	mov.w	r1, #4096	; 0x1000
	SpiReadWriteString(FALSE, ucBuf, 4);
	//SPI writes next 4 bytes of data
	SpiReadWriteString(FALSE, ucBuf + 4, usLength - 4);

	// From this point on - operate in a regular way
	sSpiInformation.ulSpiState = eSPI_STATE_IDLE;
 800030c:	609a      	str	r2, [r3, #8]

	DEASSERT_CS();
 800030e:	f000 ffe1 	bl	80012d4 <GPIO_SetBits>
	return (0);
}
 8000312:	2000      	movs	r0, #0
 8000314:	bd70      	pop	{r4, r5, r6, pc}
 8000316:	bf00      	nop
 8000318:	40010c00 	.word	0x40010c00
 800031c:	20000084 	.word	0x20000084

08000320 <SpiWrite>:
 * @param  pUserBuffer: pointer to data
 * @param usLength: length of data that will be sent to CC3000
 * @retval None
 */
long SpiWrite(unsigned char *pUserBuffer, unsigned short usLength)
{
 8000320:	b570      	push	{r4, r5, r6, lr}
	unsigned char ucPad = 0;
	//
	// Figure out the total length of the packet in order to figure out if there is padding or not
	//
	if (!(usLength & 0x0001))
 8000322:	f001 0601 	and.w	r6, r1, #1
 * @param  pUserBuffer: pointer to data
 * @param usLength: length of data that will be sent to CC3000
 * @retval None
 */
long SpiWrite(unsigned char *pUserBuffer, unsigned short usLength)
{
 8000326:	4604      	mov	r4, r0
	unsigned char ucPad = 0;
	//
	// Figure out the total length of the packet in order to figure out if there is padding or not
	//
	if (!(usLength & 0x0001))
 8000328:	f086 0001 	eor.w	r0, r6, #1
	{
		ucPad++;
	}

	pUserBuffer[0] = WRITE;
	pUserBuffer[1] = HI(usLength + ucPad);
 800032c:	180d      	adds	r5, r1, r0
	if (!(usLength & 0x0001))
	{
		ucPad++;
	}

	pUserBuffer[0] = WRITE;
 800032e:	2301      	movs	r3, #1
	pUserBuffer[1] = HI(usLength + ucPad);
	pUserBuffer[2] = LO(usLength + ucPad);
	pUserBuffer[3] = 0;
 8000330:	2600      	movs	r6, #0
	if (!(usLength & 0x0001))
	{
		ucPad++;
	}

	pUserBuffer[0] = WRITE;
 8000332:	7023      	strb	r3, [r4, #0]
	pUserBuffer[1] = HI(usLength + ucPad);
 8000334:	f3c5 2207 	ubfx	r2, r5, #8, #8
	pUserBuffer[3] = 0;
	pUserBuffer[4] = 0;

	usLength += (SPI_HEADER_SIZE + ucPad);

	if (sSpiInformation.ulSpiState == eSPI_STATE_POWERUP)
 8000338:	4b1d      	ldr	r3, [pc, #116]	; (80003b0 <SpiWrite+0x90>)
	}

	pUserBuffer[0] = WRITE;
	pUserBuffer[1] = HI(usLength + ucPad);
	pUserBuffer[2] = LO(usLength + ucPad);
	pUserBuffer[3] = 0;
 800033a:	70e6      	strb	r6, [r4, #3]
	pUserBuffer[4] = 0;
 800033c:	7126      	strb	r6, [r4, #4]
	{
		ucPad++;
	}

	pUserBuffer[0] = WRITE;
	pUserBuffer[1] = HI(usLength + ucPad);
 800033e:	7062      	strb	r2, [r4, #1]
	pUserBuffer[2] = LO(usLength + ucPad);
 8000340:	70a5      	strb	r5, [r4, #2]
	pUserBuffer[3] = 0;
	pUserBuffer[4] = 0;

	usLength += (SPI_HEADER_SIZE + ucPad);
 8000342:	3105      	adds	r1, #5

	if (sSpiInformation.ulSpiState == eSPI_STATE_POWERUP)
 8000344:	689d      	ldr	r5, [r3, #8]
	pUserBuffer[1] = HI(usLength + ucPad);
	pUserBuffer[2] = LO(usLength + ucPad);
	pUserBuffer[3] = 0;
	pUserBuffer[4] = 0;

	usLength += (SPI_HEADER_SIZE + ucPad);
 8000346:	1808      	adds	r0, r1, r0
 8000348:	b286      	uxth	r6, r0

	if (sSpiInformation.ulSpiState == eSPI_STATE_POWERUP)
 800034a:	b915      	cbnz	r5, 8000352 <SpiWrite+0x32>
	{
		while (sSpiInformation.ulSpiState != eSPI_STATE_INITIALIZED)
 800034c:	689a      	ldr	r2, [r3, #8]
 800034e:	2a01      	cmp	r2, #1
 8000350:	d1fc      	bne.n	800034c <SpiWrite+0x2c>
		{
		}
	}
	if (sSpiInformation.ulSpiState == eSPI_STATE_INITIALIZED)
 8000352:	6899      	ldr	r1, [r3, #8]
 8000354:	4d16      	ldr	r5, [pc, #88]	; (80003b0 <SpiWrite+0x90>)
 8000356:	2901      	cmp	r1, #1
 8000358:	d107      	bne.n	800036a <SpiWrite+0x4a>
	{

		//
		// This is time for first TX/RX transactions over SPI: the IRQ is down - so need to send read buffer size command
		//
		SpiFirstWrite(pUserBuffer, usLength);
 800035a:	4620      	mov	r0, r4
 800035c:	4631      	mov	r1, r6
 800035e:	f7ff ffbd 	bl	80002dc <SpiFirstWrite>

		//
		// Due to the fact that we are currently implementing a blocking situation
		// here we will wait till end of transaction
		//
		while (eSPI_STATE_IDLE != sSpiInformation.ulSpiState)
 8000362:	68aa      	ldr	r2, [r5, #8]
 8000364:	2a02      	cmp	r2, #2
 8000366:	d1fc      	bne.n	8000362 <SpiWrite+0x42>
 8000368:	e01f      	b.n	80003aa <SpiWrite+0x8a>

		//
		// We need to prevent here race that can occur in case 2 back to back packets are sent to the
		// device, so the state will move to IDLE and once again to not IDLE due to IRQ
		//
		while (sSpiInformation.ulSpiState != eSPI_STATE_IDLE)
 800036a:	68a8      	ldr	r0, [r5, #8]
 800036c:	2802      	cmp	r0, #2
 800036e:	d1fc      	bne.n	800036a <SpiWrite+0x4a>
		{
		}

		/* Loop until SPI busy */
		while (SPI_I2S_GetFlagStatus(CC3000_SPI, SPI_I2S_FLAG_BSY ) != RESET)
 8000370:	4810      	ldr	r0, [pc, #64]	; (80003b4 <SpiWrite+0x94>)
 8000372:	2180      	movs	r1, #128	; 0x80
 8000374:	f001 f82a 	bl	80013cc <SPI_I2S_GetFlagStatus>
 8000378:	2800      	cmp	r0, #0
 800037a:	d1f9      	bne.n	8000370 <SpiWrite+0x50>
		{
		}

		//SysCtlDelay(9000000);

		while (!tSLInformation.ReadWlanInterruptPin())
 800037c:	4b0e      	ldr	r3, [pc, #56]	; (80003b8 <SpiWrite+0x98>)
 800037e:	69dd      	ldr	r5, [r3, #28]
 8000380:	47a8      	blx	r5
 8000382:	2800      	cmp	r0, #0
 8000384:	d0fa      	beq.n	800037c <SpiWrite+0x5c>
		{
		}

		sSpiInformation.ulSpiState = eSPI_STATE_WRITE_IRQ;
 8000386:	4d0a      	ldr	r5, [pc, #40]	; (80003b0 <SpiWrite+0x90>)
 8000388:	2203      	movs	r2, #3
		sSpiInformation.usTxPacketLength = usLength;

		//
		// Assert the CS line and wait till IRQ line is active and then initialize write operation
		//
		ASSERT_CS();
 800038a:	480c      	ldr	r0, [pc, #48]	; (80003bc <SpiWrite+0x9c>)
 800038c:	f44f 5180 	mov.w	r1, #4096	; 0x1000

		while (!tSLInformation.ReadWlanInterruptPin())
		{
		}

		sSpiInformation.ulSpiState = eSPI_STATE_WRITE_IRQ;
 8000390:	60aa      	str	r2, [r5, #8]
		sSpiInformation.pTxPacket = pUserBuffer;
 8000392:	60ec      	str	r4, [r5, #12]
		sSpiInformation.usTxPacketLength = usLength;
 8000394:	80ae      	strh	r6, [r5, #4]

		//
		// Assert the CS line and wait till IRQ line is active and then initialize write operation
		//
		ASSERT_CS();
 8000396:	f000 ff9f 	bl	80012d8 <GPIO_ResetBits>

		//SysCtlDelay(90000);

		while (!tSLInformation.ReadWlanInterruptPin())
 800039a:	4907      	ldr	r1, [pc, #28]	; (80003b8 <SpiWrite+0x98>)
 800039c:	69c8      	ldr	r0, [r1, #28]
 800039e:	4780      	blx	r0
 80003a0:	2800      	cmp	r0, #0
 80003a2:	d0fa      	beq.n	800039a <SpiWrite+0x7a>

		//
		// Due to the fact that we are currently implementing a blocking situation
		// here we will wait till end of transaction
		//
		while (eSPI_STATE_IDLE != sSpiInformation.ulSpiState)
 80003a4:	68ab      	ldr	r3, [r5, #8]
 80003a6:	2b02      	cmp	r3, #2
 80003a8:	d1fc      	bne.n	80003a4 <SpiWrite+0x84>
		{
		}
	}
	return (0);
}
 80003aa:	2000      	movs	r0, #0
 80003ac:	bd70      	pop	{r4, r5, r6, pc}
 80003ae:	bf00      	nop
 80003b0:	20000084 	.word	0x20000084
 80003b4:	40003800 	.word	0x40003800
 80003b8:	200009b8 	.word	0x200009b8
 80003bc:	40010c00 	.word	0x40010c00

080003c0 <SpiReadDataCont>:

 * @param  None
 * @retval None
 */
long SpiReadDataCont(void)
{
 80003c0:	b570      	push	{r4, r5, r6, lr}
	unsigned char *evnt_buff, type;

	//
	//determine what type of packet we have
	//
	evnt_buff = sSpiInformation.pRxPacket;
 80003c2:	4e18      	ldr	r6, [pc, #96]	; (8000424 <SpiReadDataCont+0x64>)
 80003c4:	6935      	ldr	r5, [r6, #16]
	data_to_recv = 0;
	STREAM_TO_UINT8((char *)(evnt_buff + SPI_HEADER_SIZE), HCI_PACKET_TYPE_OFFSET, type);

	switch (type)
 80003c6:	796b      	ldrb	r3, [r5, #5]
 80003c8:	2b02      	cmp	r3, #2
 80003ca:	d008      	beq.n	80003de <SpiReadDataCont+0x1e>
 80003cc:	2b04      	cmp	r3, #4
 80003ce:	d125      	bne.n	800041c <SpiReadDataCont+0x5c>
		case HCI_TYPE_EVNT:
		{
			//
			// Calculate the rest length of the data
			//
			STREAM_TO_UINT8((char *)(evnt_buff + SPI_HEADER_SIZE), HCI_EVENT_LENGTH_OFFSET, data_to_recv);
 80003d0:	7a28      	ldrb	r0, [r5, #8]
			data_to_recv -= 1;
 80003d2:	1e44      	subs	r4, r0, #1
			// Add padding byte if needed
			//
			if ((HEADERS_SIZE_EVNT + data_to_recv) & 1)
			{

				data_to_recv++;
 80003d4:	f014 0f01 	tst.w	r4, #1
 80003d8:	bf18      	it	ne
 80003da:	4604      	movne	r4, r0
 80003dc:	e014      	b.n	8000408 <SpiReadDataCont+0x48>

	switch (type)
	{
		case HCI_TYPE_DATA:
		{
			STREAM_TO_UINT16((char *)(evnt_buff + SPI_HEADER_SIZE), HCI_DATA_LENGTH_OFFSET, data_to_recv);
 80003de:	1d68      	adds	r0, r5, #5
 80003e0:	2103      	movs	r1, #3
 80003e2:	f001 f889 	bl	80014f8 <STREAM_TO_UINT16_f>

			if (data_to_recv >= SPI_WINDOW_SIZE)
 80003e6:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400

	switch (type)
	{
		case HCI_TYPE_DATA:
		{
			STREAM_TO_UINT16((char *)(evnt_buff + SPI_HEADER_SIZE), HCI_DATA_LENGTH_OFFSET, data_to_recv);
 80003ea:	4604      	mov	r4, r0

			if (data_to_recv >= SPI_WINDOW_SIZE)
 80003ec:	db08      	blt.n	8000400 <SpiReadDataCont+0x40>
			{
				data_to_recv = eSPI_STATE_READ_FIRST_PORTION;
				SpiReadData(evnt_buff + 10, SPI_WINDOW_SIZE);
 80003ee:	f105 000a 	add.w	r0, r5, #10
 80003f2:	f44f 6180 	mov.w	r1, #1024	; 0x400
				sSpiInformation.ulSpiState = eSPI_STATE_READ_FIRST_PORTION;
 80003f6:	2407      	movs	r4, #7
			STREAM_TO_UINT16((char *)(evnt_buff + SPI_HEADER_SIZE), HCI_DATA_LENGTH_OFFSET, data_to_recv);

			if (data_to_recv >= SPI_WINDOW_SIZE)
			{
				data_to_recv = eSPI_STATE_READ_FIRST_PORTION;
				SpiReadData(evnt_buff + 10, SPI_WINDOW_SIZE);
 80003f8:	f7ff ff28 	bl	800024c <SpiReadData>
				sSpiInformation.ulSpiState = eSPI_STATE_READ_FIRST_PORTION;
 80003fc:	60b4      	str	r4, [r6, #8]
 80003fe:	e00e      	b.n	800041e <SpiReadDataCont+0x5e>
			else
			{
				//
				// We need to read the rest of data..
				//
				if (!((HEADERS_SIZE_EVNT + data_to_recv) & 1))
 8000400:	07c3      	lsls	r3, r0, #31
 8000402:	d401      	bmi.n	8000408 <SpiReadDataCont+0x48>
				{
					data_to_recv++;
 8000404:	1c44      	adds	r4, r0, #1
 8000406:	e000      	b.n	800040a <SpiReadDataCont+0x4a>
			{

				data_to_recv++;
			}

			if (data_to_recv)
 8000408:	b124      	cbz	r4, 8000414 <SpiReadDataCont+0x54>
			{
				SpiReadData(evnt_buff + 10, data_to_recv);
 800040a:	f105 000a 	add.w	r0, r5, #10
 800040e:	b2a1      	uxth	r1, r4
 8000410:	f7ff ff1c 	bl	800024c <SpiReadData>
			}

			sSpiInformation.ulSpiState = eSPI_STATE_READ_EOT;
 8000414:	4903      	ldr	r1, [pc, #12]	; (8000424 <SpiReadDataCont+0x64>)
 8000416:	2208      	movs	r2, #8
 8000418:	608a      	str	r2, [r1, #8]
			break;
 800041a:	e000      	b.n	800041e <SpiReadDataCont+0x5e>

	//
	//determine what type of packet we have
	//
	evnt_buff = sSpiInformation.pRxPacket;
	data_to_recv = 0;
 800041c:	2400      	movs	r4, #0
			break;
		}
	}

	return (data_to_recv);
}
 800041e:	4620      	mov	r0, r4
 8000420:	bd70      	pop	{r4, r5, r6, pc}
 8000422:	bf00      	nop
 8000424:	20000084 	.word	0x20000084

08000428 <SpiReadHeader>:
 * @param  None
 * @retval None
 */
void SpiReadHeader(void)
{
	SpiReadWriteStringInt(TRUE, sSpiInformation.pRxPacket, 10);
 8000428:	4b02      	ldr	r3, [pc, #8]	; (8000434 <SpiReadHeader+0xc>)
 800042a:	2001      	movs	r0, #1
 800042c:	6919      	ldr	r1, [r3, #16]
 800042e:	220a      	movs	r2, #10
 8000430:	f7ff becc 	b.w	80001cc <SpiReadWriteStringInt>
 8000434:	20000084 	.word	0x20000084

08000438 <SpiContReadOperation>:
 * @brief  Determine if all data was read if so end the data exchange
 * @param  None
 * @retval None
 */
void SpiContReadOperation(void)
{
 8000438:	b508      	push	{r3, lr}
	//
	// The header was read - continue with  the payload read
	//
	if (!SpiReadDataCont())
 800043a:	f7ff ffc1 	bl	80003c0 <SpiReadDataCont>
 800043e:	b918      	cbnz	r0, 8000448 <SpiContReadOperation+0x10>
		// All the data was read - finalize handling by switching to teh task
		//	and calling from task Event Handler
		//
		SpiTriggerRxProcessing();
	}
}
 8000440:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	{
		//
		// All the data was read - finalize handling by switching to teh task
		//	and calling from task Event Handler
		//
		SpiTriggerRxProcessing();
 8000444:	f7ff beae 	b.w	80001a4 <SpiTriggerRxProcessing>
 8000448:	bd08      	pop	{r3, pc}
	...

0800044c <SPI_DMA_IntHandler>:
 transfer.
 * @param  None
 * @retval None
 */
void SPI_DMA_IntHandler(void)
{
 800044c:	b570      	push	{r4, r5, r6, lr}
	unsigned long ucTxFinished, ucRxFinished;
	unsigned short data_to_recv;
	unsigned char *evnt_buff;

	evnt_buff = sSpiInformation.pRxPacket;
 800044e:	4c38      	ldr	r4, [pc, #224]	; (8000530 <SPI_DMA_IntHandler+0xe4>)
	data_to_recv = 0;

	ucTxFinished = DMA_GetFlagStatus(CC3000_SPI_TX_DMA_TCFLAG );
 8000450:	f44f 3000 	mov.w	r0, #131072	; 0x20000
{
	unsigned long ucTxFinished, ucRxFinished;
	unsigned short data_to_recv;
	unsigned char *evnt_buff;

	evnt_buff = sSpiInformation.pRxPacket;
 8000454:	6926      	ldr	r6, [r4, #16]
	data_to_recv = 0;

	ucTxFinished = DMA_GetFlagStatus(CC3000_SPI_TX_DMA_TCFLAG );
 8000456:	f000 fe7d 	bl	8001154 <DMA_GetFlagStatus>
 800045a:	4605      	mov	r5, r0
	ucRxFinished = DMA_GetFlagStatus(CC3000_SPI_RX_DMA_TCFLAG );
 800045c:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8000460:	f000 fe78 	bl	8001154 <DMA_GetFlagStatus>

	if (sSpiInformation.ulSpiState == eSPI_STATE_READ_IRQ)
 8000464:	68a3      	ldr	r3, [r4, #8]
 8000466:	2b06      	cmp	r3, #6
 8000468:	d10b      	bne.n	8000482 <SPI_DMA_IntHandler+0x36>
	{
		//
		// If one of DMA's still did not finished its operation - we need to stay
		// and wait till it will finish
		//
		if (ucTxFinished && ucRxFinished)
 800046a:	2d00      	cmp	r5, #0
 800046c:	d05e      	beq.n	800052c <SPI_DMA_IntHandler+0xe0>
 800046e:	2800      	cmp	r0, #0
 8000470:	d05c      	beq.n	800052c <SPI_DMA_IntHandler+0xe0>
		{
			/* Clear SPI_DMA Interrupt Pending Flags */
			DMA_ClearFlag(CC3000_SPI_TX_DMA_TCFLAG | CC3000_SPI_RX_DMA_TCFLAG);
 8000472:	f44f 3008 	mov.w	r0, #139264	; 0x22000
 8000476:	f000 fe7b 	bl	8001170 <DMA_ClearFlag>
		{
			sSpiInformation.ulSpiState = eSPI_STATE_WRITE_EOT;
			SpiWriteAsync(sSpiInformation.pTxPacket + SPI_WINDOW_SIZE, sSpiInformation.usTxPacketLength - SPI_WINDOW_SIZE);
		}
	}
}
 800047a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		if (ucTxFinished && ucRxFinished)
		{
			/* Clear SPI_DMA Interrupt Pending Flags */
			DMA_ClearFlag(CC3000_SPI_TX_DMA_TCFLAG | CC3000_SPI_RX_DMA_TCFLAG);

			SpiContReadOperation();
 800047e:	f7ff bfdb 	b.w	8000438 <SpiContReadOperation>
		}
	}
	else if (sSpiInformation.ulSpiState == eSPI_STATE_READ_FIRST_PORTION)
 8000482:	68a1      	ldr	r1, [r4, #8]
 8000484:	2907      	cmp	r1, #7
 8000486:	d11b      	bne.n	80004c0 <SPI_DMA_IntHandler+0x74>
	{
		if (ucRxFinished)
 8000488:	2800      	cmp	r0, #0
 800048a:	d04f      	beq.n	800052c <SPI_DMA_IntHandler+0xe0>
		{
			/* Clear SPI_DMA Interrupt Pending Flags */
			DMA_ClearFlag(CC3000_SPI_TX_DMA_TCFLAG | CC3000_SPI_RX_DMA_TCFLAG);
 800048c:	f44f 3008 	mov.w	r0, #139264	; 0x22000
 8000490:	f000 fe6e 	bl	8001170 <DMA_ClearFlag>

			STREAM_TO_UINT16((char *)(evnt_buff + SPI_HEADER_SIZE), HCI_DATA_LENGTH_OFFSET, data_to_recv);
 8000494:	2103      	movs	r1, #3
 8000496:	1d70      	adds	r0, r6, #5
 8000498:	f001 f82e 	bl	80014f8 <STREAM_TO_UINT16_f>
			// Read the last portion of data
			//
			//
			// We need to read the rest of data..
			//
			data_to_recv -= SPI_WINDOW_SIZE;
 800049c:	f5a0 6480 	sub.w	r4, r0, #1024	; 0x400
 80004a0:	b2a1      	uxth	r1, r4
			if (!((HEADERS_SIZE_EVNT + data_to_recv) & 1))
			{
				data_to_recv++;
			}

			SpiReadData(sSpiInformation.pRxPacket + 10 + SPI_WINDOW_SIZE, data_to_recv);
 80004a2:	4c23      	ldr	r4, [pc, #140]	; (8000530 <SPI_DMA_IntHandler+0xe4>)
			//
			// We need to read the rest of data..
			//
			data_to_recv -= SPI_WINDOW_SIZE;

			if (!((HEADERS_SIZE_EVNT + data_to_recv) & 1))
 80004a4:	07ca      	lsls	r2, r1, #31
			{
				data_to_recv++;
 80004a6:	bf58      	it	pl
 80004a8:	f2a0 31ff 	subwpl	r1, r0, #1023	; 0x3ff
			}

			SpiReadData(sSpiInformation.pRxPacket + 10 + SPI_WINDOW_SIZE, data_to_recv);
 80004ac:	6920      	ldr	r0, [r4, #16]
			//
			data_to_recv -= SPI_WINDOW_SIZE;

			if (!((HEADERS_SIZE_EVNT + data_to_recv) & 1))
			{
				data_to_recv++;
 80004ae:	bf58      	it	pl
 80004b0:	b289      	uxthpl	r1, r1
			}

			SpiReadData(sSpiInformation.pRxPacket + 10 + SPI_WINDOW_SIZE, data_to_recv);
 80004b2:	f200 400a 	addw	r0, r0, #1034	; 0x40a
 80004b6:	f7ff fec9 	bl	800024c <SpiReadData>

			sSpiInformation.ulSpiState = eSPI_STATE_READ_EOT;
 80004ba:	2308      	movs	r3, #8
 80004bc:	60a3      	str	r3, [r4, #8]
 80004be:	bd70      	pop	{r4, r5, r6, pc}
		}
	}
	else if (sSpiInformation.ulSpiState == eSPI_STATE_READ_EOT)
 80004c0:	68a2      	ldr	r2, [r4, #8]
 80004c2:	2a08      	cmp	r2, #8
 80004c4:	d109      	bne.n	80004da <SPI_DMA_IntHandler+0x8e>
	{
		//
		// All the data was read - finalize handling by switching to the task
		// and calling from task Event Handler
		//
		if (ucRxFinished)
 80004c6:	2800      	cmp	r0, #0
 80004c8:	d030      	beq.n	800052c <SPI_DMA_IntHandler+0xe0>
		{
			/* Clear SPI_DMA Interrupt Pending Flags */
			DMA_ClearFlag(CC3000_SPI_TX_DMA_TCFLAG | CC3000_SPI_RX_DMA_TCFLAG);
 80004ca:	f44f 3008 	mov.w	r0, #139264	; 0x22000
 80004ce:	f000 fe4f 	bl	8001170 <DMA_ClearFlag>
		{
			sSpiInformation.ulSpiState = eSPI_STATE_WRITE_EOT;
			SpiWriteAsync(sSpiInformation.pTxPacket + SPI_WINDOW_SIZE, sSpiInformation.usTxPacketLength - SPI_WINDOW_SIZE);
		}
	}
}
 80004d2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		if (ucRxFinished)
		{
			/* Clear SPI_DMA Interrupt Pending Flags */
			DMA_ClearFlag(CC3000_SPI_TX_DMA_TCFLAG | CC3000_SPI_RX_DMA_TCFLAG);

			SpiTriggerRxProcessing();
 80004d6:	f7ff be65 	b.w	80001a4 <SpiTriggerRxProcessing>
		}
	}
	else if (sSpiInformation.ulSpiState == eSPI_STATE_WRITE_EOT)
 80004da:	68a0      	ldr	r0, [r4, #8]
 80004dc:	2805      	cmp	r0, #5
 80004de:	d114      	bne.n	800050a <SPI_DMA_IntHandler+0xbe>
	{
		if (ucTxFinished)
 80004e0:	2d00      	cmp	r5, #0
 80004e2:	d023      	beq.n	800052c <SPI_DMA_IntHandler+0xe0>
		{
			/* Loop until SPI busy */
			while (SPI_I2S_GetFlagStatus(CC3000_SPI, SPI_I2S_FLAG_BSY ) != RESET)
 80004e4:	4813      	ldr	r0, [pc, #76]	; (8000534 <SPI_DMA_IntHandler+0xe8>)
 80004e6:	2180      	movs	r1, #128	; 0x80
 80004e8:	f000 ff70 	bl	80013cc <SPI_I2S_GetFlagStatus>
 80004ec:	2800      	cmp	r0, #0
 80004ee:	d1f9      	bne.n	80004e4 <SPI_DMA_IntHandler+0x98>
			{
			}

			/* Clear SPI_DMA Interrupt Pending Flags */
			DMA_ClearFlag(CC3000_SPI_TX_DMA_TCFLAG | CC3000_SPI_RX_DMA_TCFLAG);
 80004f0:	f44f 3008 	mov.w	r0, #139264	; 0x22000
 80004f4:	f000 fe3c 	bl	8001170 <DMA_ClearFlag>

			DEASSERT_CS();
 80004f8:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 80004fc:	480e      	ldr	r0, [pc, #56]	; (8000538 <SPI_DMA_IntHandler+0xec>)
 80004fe:	f000 fee9 	bl	80012d4 <GPIO_SetBits>

			sSpiInformation.ulSpiState = eSPI_STATE_IDLE;
 8000502:	4a0b      	ldr	r2, [pc, #44]	; (8000530 <SPI_DMA_IntHandler+0xe4>)
 8000504:	2102      	movs	r1, #2
 8000506:	6091      	str	r1, [r2, #8]
 8000508:	bd70      	pop	{r4, r5, r6, pc}
		}
	}
	else if (sSpiInformation.ulSpiState == eSPI_STATE_WRITE_FIRST_PORTION)
 800050a:	68a3      	ldr	r3, [r4, #8]
 800050c:	2b04      	cmp	r3, #4
 800050e:	d10d      	bne.n	800052c <SPI_DMA_IntHandler+0xe0>
	{
		if (ucTxFinished)
 8000510:	b165      	cbz	r5, 800052c <SPI_DMA_IntHandler+0xe0>
		{
			sSpiInformation.ulSpiState = eSPI_STATE_WRITE_EOT;
			SpiWriteAsync(sSpiInformation.pTxPacket + SPI_WINDOW_SIZE, sSpiInformation.usTxPacketLength - SPI_WINDOW_SIZE);
 8000512:	88a0      	ldrh	r0, [r4, #4]
 8000514:	68e2      	ldr	r2, [r4, #12]
	}
	else if (sSpiInformation.ulSpiState == eSPI_STATE_WRITE_FIRST_PORTION)
	{
		if (ucTxFinished)
		{
			sSpiInformation.ulSpiState = eSPI_STATE_WRITE_EOT;
 8000516:	2105      	movs	r1, #5
			SpiWriteAsync(sSpiInformation.pTxPacket + SPI_WINDOW_SIZE, sSpiInformation.usTxPacketLength - SPI_WINDOW_SIZE);
 8000518:	f5a0 6380 	sub.w	r3, r0, #1024	; 0x400
	}
	else if (sSpiInformation.ulSpiState == eSPI_STATE_WRITE_FIRST_PORTION)
	{
		if (ucTxFinished)
		{
			sSpiInformation.ulSpiState = eSPI_STATE_WRITE_EOT;
 800051c:	60a1      	str	r1, [r4, #8]
			SpiWriteAsync(sSpiInformation.pTxPacket + SPI_WINDOW_SIZE, sSpiInformation.usTxPacketLength - SPI_WINDOW_SIZE);
 800051e:	f502 6080 	add.w	r0, r2, #1024	; 0x400
 8000522:	b299      	uxth	r1, r3
		}
	}
}
 8000524:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	else if (sSpiInformation.ulSpiState == eSPI_STATE_WRITE_FIRST_PORTION)
	{
		if (ucTxFinished)
		{
			sSpiInformation.ulSpiState = eSPI_STATE_WRITE_EOT;
			SpiWriteAsync(sSpiInformation.pTxPacket + SPI_WINDOW_SIZE, sSpiInformation.usTxPacketLength - SPI_WINDOW_SIZE);
 8000528:	f7ff bed2 	b.w	80002d0 <SpiWriteAsync>
 800052c:	bd70      	pop	{r4, r5, r6, pc}
 800052e:	bf00      	nop
 8000530:	20000084 	.word	0x20000084
 8000534:	40003800 	.word	0x40003800
 8000538:	40010c00 	.word	0x40010c00

0800053c <SPI_EXTI_IntHandler>:
 IRQ line low.
 * @param  None
 * @retval None
 */
void SPI_EXTI_IntHandler(void)
{
 800053c:	b508      	push	{r3, lr}
	//Flag is cleared in first ISR handler
	if (!tSLInformation.ReadWlanInterruptPin())
 800053e:	4b18      	ldr	r3, [pc, #96]	; (80005a0 <SPI_EXTI_IntHandler+0x64>)
 8000540:	69d8      	ldr	r0, [r3, #28]
 8000542:	4780      	blx	r0
 8000544:	2800      	cmp	r0, #0
 8000546:	d12a      	bne.n	800059e <SPI_EXTI_IntHandler+0x62>
	{
		if (sSpiInformation.ulSpiState == eSPI_STATE_POWERUP)
 8000548:	4b16      	ldr	r3, [pc, #88]	; (80005a4 <SPI_EXTI_IntHandler+0x68>)
 800054a:	689a      	ldr	r2, [r3, #8]
 800054c:	b912      	cbnz	r2, 8000554 <SPI_EXTI_IntHandler+0x18>
		{
			/* This means IRQ line was low call a callback of HCI Layer to inform on event */
			sSpiInformation.ulSpiState = eSPI_STATE_INITIALIZED;
 800054e:	2001      	movs	r0, #1
 8000550:	6098      	str	r0, [r3, #8]
 8000552:	bd08      	pop	{r3, pc}
		}
		else if (sSpiInformation.ulSpiState == eSPI_STATE_IDLE)
 8000554:	6899      	ldr	r1, [r3, #8]
 8000556:	2902      	cmp	r1, #2
 8000558:	d10a      	bne.n	8000570 <SPI_EXTI_IntHandler+0x34>
		{
			sSpiInformation.ulSpiState = eSPI_STATE_READ_IRQ;
 800055a:	2206      	movs	r2, #6

			/* IRQ line goes down - we are starting reception */

			ASSERT_CS();
 800055c:	4812      	ldr	r0, [pc, #72]	; (80005a8 <SPI_EXTI_IntHandler+0x6c>)
 800055e:	f44f 5180 	mov.w	r1, #4096	; 0x1000
			/* This means IRQ line was low call a callback of HCI Layer to inform on event */
			sSpiInformation.ulSpiState = eSPI_STATE_INITIALIZED;
		}
		else if (sSpiInformation.ulSpiState == eSPI_STATE_IDLE)
		{
			sSpiInformation.ulSpiState = eSPI_STATE_READ_IRQ;
 8000562:	609a      	str	r2, [r3, #8]

			/* IRQ line goes down - we are starting reception */

			ASSERT_CS();
 8000564:	f000 feb8 	bl	80012d8 <GPIO_ResetBits>
				//
				SpiWriteAsync(sSpiInformation.pTxPacket, SPI_WINDOW_SIZE);
			}
		}
	}
}
 8000568:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
			ASSERT_CS();

			//
			// Wait for TX/RX Complete which will come as DMA interrupt
			//
			SpiReadHeader();
 800056c:	f7ff bf5c 	b.w	8000428 <SpiReadHeader>
		}
		else if (sSpiInformation.ulSpiState == eSPI_STATE_WRITE_IRQ)
 8000570:	689a      	ldr	r2, [r3, #8]
 8000572:	2a03      	cmp	r2, #3
 8000574:	d113      	bne.n	800059e <SPI_EXTI_IntHandler+0x62>
		{
			if (sSpiInformation.usTxPacketLength <= SPI_WINDOW_SIZE)
 8000576:	889a      	ldrh	r2, [r3, #4]
 8000578:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 800057c:	d806      	bhi.n	800058c <SPI_EXTI_IntHandler+0x50>
			{
				//
				// Send the data over SPI and wait for complete interrupt
				//
				sSpiInformation.ulSpiState = eSPI_STATE_WRITE_EOT;
 800057e:	2105      	movs	r1, #5
 8000580:	6099      	str	r1, [r3, #8]

				SpiReadWriteStringInt(FALSE, sSpiInformation.pTxPacket, sSpiInformation.usTxPacketLength);
 8000582:	68d9      	ldr	r1, [r3, #12]
				//
				SpiWriteAsync(sSpiInformation.pTxPacket, SPI_WINDOW_SIZE);
			}
		}
	}
}
 8000584:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
				//
				// Send the data over SPI and wait for complete interrupt
				//
				sSpiInformation.ulSpiState = eSPI_STATE_WRITE_EOT;

				SpiReadWriteStringInt(FALSE, sSpiInformation.pTxPacket, sSpiInformation.usTxPacketLength);
 8000588:	f7ff be20 	b.w	80001cc <SpiReadWriteStringInt>
			else
			{
				//
				// Send the data over SPI and wait for complete interrupt to transfer the rest
				//
				sSpiInformation.ulSpiState = eSPI_STATE_WRITE_FIRST_PORTION;
 800058c:	2004      	movs	r0, #4
 800058e:	6098      	str	r0, [r3, #8]

				//
				// Start the DMA and change state
				//
				SpiWriteAsync(sSpiInformation.pTxPacket, SPI_WINDOW_SIZE);
 8000590:	68d8      	ldr	r0, [r3, #12]
 8000592:	f44f 6180 	mov.w	r1, #1024	; 0x400
			}
		}
	}
}
 8000596:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
				sSpiInformation.ulSpiState = eSPI_STATE_WRITE_FIRST_PORTION;

				//
				// Start the DMA and change state
				//
				SpiWriteAsync(sSpiInformation.pTxPacket, SPI_WINDOW_SIZE);
 800059a:	f7ff be99 	b.w	80002d0 <SpiWriteAsync>
 800059e:	bd08      	pop	{r3, pc}
 80005a0:	200009b8 	.word	0x200009b8
 80005a4:	20000084 	.word	0x20000084
 80005a8:	40010c00 	.word	0x40010c00

080005ac <NVIC_Configuration>:
	/* 4 bits for pre-emption priority(0-15 PreemptionPriority) and 0 bits for subpriority(0 SubPriority) */
	//NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);

	/* Configure the Priority Group to 2 bits */
	/* 2 bits for pre-emption priority(0-3 PreemptionPriority) and 2 bits for subpriority(0-3 SubPriority) */
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
 80005ac:	f44f 60a0 	mov.w	r0, #1280	; 0x500
 80005b0:	f000 bce4 	b.w	8000f7c <NVIC_PriorityGroupConfig>

080005b4 <LED_Init>:
  *     @arg LED1
  *     @arg LED2
  * @retval None
  */
void LED_Init(Led_TypeDef Led)
{
 80005b4:	b537      	push	{r0, r1, r2, r4, r5, lr}
    GPIO_InitTypeDef  GPIO_InitStructure;

    /* Enable the GPIO_LED Clock */
    RCC_APB2PeriphClockCmd(LED_CLK[Led], ENABLE);
 80005b6:	4d0c      	ldr	r5, [pc, #48]	; (80005e8 <LED_Init+0x34>)
  *     @arg LED1
  *     @arg LED2
  * @retval None
  */
void LED_Init(Led_TypeDef Led)
{
 80005b8:	4604      	mov	r4, r0
    GPIO_InitTypeDef  GPIO_InitStructure;

    /* Enable the GPIO_LED Clock */
    RCC_APB2PeriphClockCmd(LED_CLK[Led], ENABLE);
 80005ba:	2101      	movs	r1, #1
 80005bc:	f855 0020 	ldr.w	r0, [r5, r0, lsl #2]
 80005c0:	f000 feb8 	bl	8001334 <RCC_APB2PeriphClockCmd>

    /* Configure the GPIO_LED pin */
    GPIO_InitStructure.GPIO_Pin = LED_PIN[Led];
 80005c4:	eb05 0544 	add.w	r5, r5, r4, lsl #1
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

    GPIO_Init(LED_PORT[Led], &GPIO_InitStructure);
 80005c8:	4a08      	ldr	r2, [pc, #32]	; (80005ec <LED_Init+0x38>)
    /* Enable the GPIO_LED Clock */
    RCC_APB2PeriphClockCmd(LED_CLK[Led], ENABLE);

    /* Configure the GPIO_LED pin */
    GPIO_InitStructure.GPIO_Pin = LED_PIN[Led];
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 80005ca:	2010      	movs	r0, #16
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80005cc:	2103      	movs	r1, #3

    /* Enable the GPIO_LED Clock */
    RCC_APB2PeriphClockCmd(LED_CLK[Led], ENABLE);

    /* Configure the GPIO_LED pin */
    GPIO_InitStructure.GPIO_Pin = LED_PIN[Led];
 80005ce:	892b      	ldrh	r3, [r5, #8]
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 80005d0:	f88d 0007 	strb.w	r0, [sp, #7]
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80005d4:	f88d 1006 	strb.w	r1, [sp, #6]

    GPIO_Init(LED_PORT[Led], &GPIO_InitStructure);
 80005d8:	f852 0024 	ldr.w	r0, [r2, r4, lsl #2]
 80005dc:	a901      	add	r1, sp, #4

    /* Enable the GPIO_LED Clock */
    RCC_APB2PeriphClockCmd(LED_CLK[Led], ENABLE);

    /* Configure the GPIO_LED pin */
    GPIO_InitStructure.GPIO_Pin = LED_PIN[Led];
 80005de:	f8ad 3004 	strh.w	r3, [sp, #4]
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

    GPIO_Init(LED_PORT[Led], &GPIO_InitStructure);
 80005e2:	f000 fe21 	bl	8001228 <GPIO_Init>
}
 80005e6:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 80005e8:	080021dc 	.word	0x080021dc
 80005ec:	20000008 	.word	0x20000008

080005f0 <LED_On>:
  *     @arg LED2
  * @retval None
  */
void LED_On(Led_TypeDef Led)
{
    LED_PORT[Led]->BSRR = LED_PIN[Led];
 80005f0:	4b04      	ldr	r3, [pc, #16]	; (8000604 <LED_On+0x14>)
 80005f2:	4a05      	ldr	r2, [pc, #20]	; (8000608 <LED_On+0x18>)
 80005f4:	f853 1020 	ldr.w	r1, [r3, r0, lsl #2]
 80005f8:	eb02 0040 	add.w	r0, r2, r0, lsl #1
 80005fc:	8903      	ldrh	r3, [r0, #8]
 80005fe:	610b      	str	r3, [r1, #16]
 8000600:	4770      	bx	lr
 8000602:	bf00      	nop
 8000604:	20000008 	.word	0x20000008
 8000608:	080021dc 	.word	0x080021dc

0800060c <LED_Off>:
  *     @arg LED2
  * @retval None
  */
void LED_Off(Led_TypeDef Led)
{
    LED_PORT[Led]->BRR = LED_PIN[Led];
 800060c:	4b04      	ldr	r3, [pc, #16]	; (8000620 <LED_Off+0x14>)
 800060e:	4a05      	ldr	r2, [pc, #20]	; (8000624 <LED_Off+0x18>)
 8000610:	f853 1020 	ldr.w	r1, [r3, r0, lsl #2]
 8000614:	eb02 0040 	add.w	r0, r2, r0, lsl #1
 8000618:	8903      	ldrh	r3, [r0, #8]
 800061a:	614b      	str	r3, [r1, #20]
 800061c:	4770      	bx	lr
 800061e:	bf00      	nop
 8000620:	20000008 	.word	0x20000008
 8000624:	080021dc 	.word	0x080021dc

08000628 <LED_Toggle>:
  *     @arg LED2
  * @retval None
  */
void LED_Toggle(Led_TypeDef Led)
{
    LED_PORT[Led]->ODR ^= LED_PIN[Led];
 8000628:	4b05      	ldr	r3, [pc, #20]	; (8000640 <LED_Toggle+0x18>)
 800062a:	4906      	ldr	r1, [pc, #24]	; (8000644 <LED_Toggle+0x1c>)
 800062c:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8000630:	eb01 0040 	add.w	r0, r1, r0, lsl #1
 8000634:	68da      	ldr	r2, [r3, #12]
 8000636:	8901      	ldrh	r1, [r0, #8]
 8000638:	404a      	eors	r2, r1
 800063a:	60da      	str	r2, [r3, #12]
 800063c:	4770      	bx	lr
 800063e:	bf00      	nop
 8000640:	20000008 	.word	0x20000008
 8000644:	080021dc 	.word	0x080021dc

08000648 <BUTTON_EXTI_Config>:
        BUTTON_EXTI_Config(Button, ENABLE);
    }
}

void BUTTON_EXTI_Config(Button_TypeDef Button, FunctionalState NewState)
{
 8000648:	b573      	push	{r0, r1, r4, r5, r6, lr}
    EXTI_InitTypeDef EXTI_InitStructure;

	/* Connect Button EXTI Line to Button GPIO Pin */
    GPIO_EXTILineConfig(BUTTON_PORT_SOURCE[Button], BUTTON_PIN_SOURCE[Button]);
 800064a:	4c0e      	ldr	r4, [pc, #56]	; (8000684 <BUTTON_EXTI_Config+0x3c>)
        BUTTON_EXTI_Config(Button, ENABLE);
    }
}

void BUTTON_EXTI_Config(Button_TypeDef Button, FunctionalState NewState)
{
 800064c:	460e      	mov	r6, r1
    EXTI_InitTypeDef EXTI_InitStructure;

	/* Connect Button EXTI Line to Button GPIO Pin */
    GPIO_EXTILineConfig(BUTTON_PORT_SOURCE[Button], BUTTON_PIN_SOURCE[Button]);
 800064e:	eb04 0440 	add.w	r4, r4, r0, lsl #1
 8000652:	7c21      	ldrb	r1, [r4, #16]
        BUTTON_EXTI_Config(Button, ENABLE);
    }
}

void BUTTON_EXTI_Config(Button_TypeDef Button, FunctionalState NewState)
{
 8000654:	4605      	mov	r5, r0
    EXTI_InitTypeDef EXTI_InitStructure;

	/* Connect Button EXTI Line to Button GPIO Pin */
    GPIO_EXTILineConfig(BUTTON_PORT_SOURCE[Button], BUTTON_PIN_SOURCE[Button]);
 8000656:	7b20      	ldrb	r0, [r4, #12]
 8000658:	f000 fe40 	bl	80012dc <GPIO_EXTILineConfig>

	/* Clear the EXTI line pending flag */
	EXTI_ClearFlag(BUTTON_EXTI_LINE[Button]);
 800065c:	8aa4      	ldrh	r4, [r4, #20]
 800065e:	4620      	mov	r0, r4
 8000660:	f000 fdcc 	bl	80011fc <EXTI_ClearFlag>

    /* Configure Button EXTI line */
    EXTI_InitStructure.EXTI_Line = BUTTON_EXTI_LINE[Button];
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
	EXTI_InitStructure.EXTI_Trigger = BUTTON_EXTI_TRIGGER[Button];
 8000664:	4808      	ldr	r0, [pc, #32]	; (8000688 <BUTTON_EXTI_Config+0x40>)
	/* Clear the EXTI line pending flag */
	EXTI_ClearFlag(BUTTON_EXTI_LINE[Button]);

    /* Configure Button EXTI line */
    EXTI_InitStructure.EXTI_Line = BUTTON_EXTI_LINE[Button];
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
 8000666:	2300      	movs	r3, #0
	EXTI_InitStructure.EXTI_Trigger = BUTTON_EXTI_TRIGGER[Button];
 8000668:	1945      	adds	r5, r0, r5
 800066a:	7a29      	ldrb	r1, [r5, #8]
    EXTI_InitStructure.EXTI_LineCmd = NewState;
    EXTI_Init(&EXTI_InitStructure);
 800066c:	4668      	mov	r0, sp

	/* Clear the EXTI line pending flag */
	EXTI_ClearFlag(BUTTON_EXTI_LINE[Button]);

    /* Configure Button EXTI line */
    EXTI_InitStructure.EXTI_Line = BUTTON_EXTI_LINE[Button];
 800066e:	9400      	str	r4, [sp, #0]
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
 8000670:	f88d 3004 	strb.w	r3, [sp, #4]
	EXTI_InitStructure.EXTI_Trigger = BUTTON_EXTI_TRIGGER[Button];
 8000674:	f88d 1005 	strb.w	r1, [sp, #5]
    EXTI_InitStructure.EXTI_LineCmd = NewState;
 8000678:	f88d 6006 	strb.w	r6, [sp, #6]
    EXTI_Init(&EXTI_InitStructure);
 800067c:	f000 fd82 	bl	8001184 <EXTI_Init>
}
 8000680:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}
 8000682:	bf00      	nop
 8000684:	080021dc 	.word	0x080021dc
 8000688:	20000008 	.word	0x20000008

0800068c <BUTTON_Init>:
  *     @arg BUTTON_MODE_EXTI: Button will be connected to EXTI line with interrupt
  *                     generation capability
  * @retval None
  */
void BUTTON_Init(Button_TypeDef Button, ButtonMode_TypeDef Button_Mode)
{
 800068c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    GPIO_InitTypeDef GPIO_InitStructure;
    NVIC_InitTypeDef NVIC_InitStructure;
    TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;

    /* Enable the BUTTON Clock */
    RCC_APB2PeriphClockCmd(BUTTON_CLK[Button] | RCC_APB2Periph_AFIO, ENABLE);
 8000690:	4f35      	ldr	r7, [pc, #212]	; (8000768 <BUTTON_Init+0xdc>)
 8000692:	0086      	lsls	r6, r0, #2
 8000694:	19bb      	adds	r3, r7, r6
  *     @arg BUTTON_MODE_EXTI: Button will be connected to EXTI line with interrupt
  *                     generation capability
  * @retval None
  */
void BUTTON_Init(Button_TypeDef Button, ButtonMode_TypeDef Button_Mode)
{
 8000696:	4605      	mov	r5, r0
    GPIO_InitTypeDef GPIO_InitStructure;
    NVIC_InitTypeDef NVIC_InitStructure;
    TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;

    /* Enable the BUTTON Clock */
    RCC_APB2PeriphClockCmd(BUTTON_CLK[Button] | RCC_APB2Periph_AFIO, ENABLE);
 8000698:	6998      	ldr	r0, [r3, #24]
  *     @arg BUTTON_MODE_EXTI: Button will be connected to EXTI line with interrupt
  *                     generation capability
  * @retval None
  */
void BUTTON_Init(Button_TypeDef Button, ButtonMode_TypeDef Button_Mode)
{
 800069a:	b086      	sub	sp, #24
 800069c:	460c      	mov	r4, r1
    GPIO_InitTypeDef GPIO_InitStructure;
    NVIC_InitTypeDef NVIC_InitStructure;
    TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;

    /* Enable the BUTTON Clock */
    RCC_APB2PeriphClockCmd(BUTTON_CLK[Button] | RCC_APB2Periph_AFIO, ENABLE);
 800069e:	f040 0001 	orr.w	r0, r0, #1
 80006a2:	2101      	movs	r1, #1
 80006a4:	f000 fe46 	bl	8001334 <RCC_APB2PeriphClockCmd>

    /* Configure Button pin as input floating */
    GPIO_InitStructure.GPIO_Mode = BUTTON_GPIO_MODE[Button];
 80006a8:	4b30      	ldr	r3, [pc, #192]	; (800076c <BUTTON_Init+0xe0>)
    GPIO_InitStructure.GPIO_Pin = BUTTON_PIN[Button];
 80006aa:	eb07 0745 	add.w	r7, r7, r5, lsl #1

    /* Enable the BUTTON Clock */
    RCC_APB2PeriphClockCmd(BUTTON_CLK[Button] | RCC_APB2Periph_AFIO, ENABLE);

    /* Configure Button pin as input floating */
    GPIO_InitStructure.GPIO_Mode = BUTTON_GPIO_MODE[Button];
 80006ae:	195a      	adds	r2, r3, r5
 80006b0:	7a91      	ldrb	r1, [r2, #10]
    GPIO_InitStructure.GPIO_Pin = BUTTON_PIN[Button];
 80006b2:	8c38      	ldrh	r0, [r7, #32]

    /* Enable the BUTTON Clock */
    RCC_APB2PeriphClockCmd(BUTTON_CLK[Button] | RCC_APB2Periph_AFIO, ENABLE);

    /* Configure Button pin as input floating */
    GPIO_InitStructure.GPIO_Mode = BUTTON_GPIO_MODE[Button];
 80006b4:	f88d 1007 	strb.w	r1, [sp, #7]
    GPIO_InitStructure.GPIO_Pin = BUTTON_PIN[Button];
    GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStructure);
 80006b8:	199e      	adds	r6, r3, r6
    /* Enable the BUTTON Clock */
    RCC_APB2PeriphClockCmd(BUTTON_CLK[Button] | RCC_APB2Periph_AFIO, ENABLE);

    /* Configure Button pin as input floating */
    GPIO_InitStructure.GPIO_Mode = BUTTON_GPIO_MODE[Button];
    GPIO_InitStructure.GPIO_Pin = BUTTON_PIN[Button];
 80006ba:	a906      	add	r1, sp, #24
 80006bc:	f821 0d14 	strh.w	r0, [r1, #-20]!
    GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStructure);
 80006c0:	68f0      	ldr	r0, [r6, #12]
 80006c2:	f000 fdb1 	bl	8001228 <GPIO_Init>

    if (Button_Mode == BUTTON_MODE_EXTI)
 80006c6:	2c01      	cmp	r4, #1
 80006c8:	d14b      	bne.n	8000762 <BUTTON_Init+0xd6>
    	DEBOUNCE_TIMER_CLK_CMD(DEBOUNCE_TIMER_CLK, ENABLE);

        /* TIM Update Frequency = 72000000/7200/100 = 100Hz = 10ms */
        /* TIM_Prescaler: 7199 */
        /* TIM_Autoreload: 99 -> 100Hz = 10ms */
        uint16_t TIM_Prescaler = (SystemCoreClock / 10000) - 1;
 80006ca:	4e29      	ldr	r6, [pc, #164]	; (8000770 <BUTTON_Init+0xe4>)
    GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStructure);

    if (Button_Mode == BUTTON_MODE_EXTI)
    {
        /* Enable TIM clock */
    	DEBOUNCE_TIMER_CLK_CMD(DEBOUNCE_TIMER_CLK, ENABLE);
 80006cc:	f44f 6000 	mov.w	r0, #2048	; 0x800
 80006d0:	4621      	mov	r1, r4
 80006d2:	f000 fe2f 	bl	8001334 <RCC_APB2PeriphClockCmd>

        /* TIM Update Frequency = 72000000/7200/100 = 100Hz = 10ms */
        /* TIM_Prescaler: 7199 */
        /* TIM_Autoreload: 99 -> 100Hz = 10ms */
        uint16_t TIM_Prescaler = (SystemCoreClock / 10000) - 1;
 80006d6:	6832      	ldr	r2, [r6, #0]
 80006d8:	f242 7310 	movw	r3, #10000	; 0x2710
 80006dc:	fbb2 f1f3 	udiv	r1, r2, r3
 80006e0:	1e48      	subs	r0, r1, #1
 80006e2:	b286      	uxth	r6, r0
        uint16_t TIM_Autoreload = (10000 / DEBOUNCE_FREQ) - 1;

        /* Time Base Configuration */
    	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
 80006e4:	a803      	add	r0, sp, #12
 80006e6:	f000 fec1 	bl	800146c <TIM_TimeBaseStructInit>
    	TIM_TimeBaseStructure.TIM_Prescaler = TIM_Prescaler;
    	TIM_TimeBaseStructure.TIM_Period = TIM_Autoreload;
    	TIM_TimeBaseStructure.TIM_ClockDivision = 0x0;
 80006ea:	2300      	movs	r3, #0
        uint16_t TIM_Autoreload = (10000 / DEBOUNCE_FREQ) - 1;

        /* Time Base Configuration */
    	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
    	TIM_TimeBaseStructure.TIM_Prescaler = TIM_Prescaler;
    	TIM_TimeBaseStructure.TIM_Period = TIM_Autoreload;
 80006ec:	2263      	movs	r2, #99	; 0x63
    	TIM_TimeBaseStructure.TIM_ClockDivision = 0x0;
    	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
    	TIM_TimeBaseInit(DEBOUNCE_TIMER, &TIM_TimeBaseStructure);
 80006ee:	4821      	ldr	r0, [pc, #132]	; (8000774 <BUTTON_Init+0xe8>)
 80006f0:	a903      	add	r1, sp, #12

        /* Time Base Configuration */
    	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
    	TIM_TimeBaseStructure.TIM_Prescaler = TIM_Prescaler;
    	TIM_TimeBaseStructure.TIM_Period = TIM_Autoreload;
    	TIM_TimeBaseStructure.TIM_ClockDivision = 0x0;
 80006f2:	f8ad 3012 	strh.w	r3, [sp, #18]
    	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 80006f6:	f8ad 300e 	strh.w	r3, [sp, #14]
        uint16_t TIM_Autoreload = (10000 / DEBOUNCE_FREQ) - 1;

        /* Time Base Configuration */
    	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
    	TIM_TimeBaseStructure.TIM_Prescaler = TIM_Prescaler;
    	TIM_TimeBaseStructure.TIM_Period = TIM_Autoreload;
 80006fa:	f8ad 2010 	strh.w	r2, [sp, #16]
        uint16_t TIM_Prescaler = (SystemCoreClock / 10000) - 1;
        uint16_t TIM_Autoreload = (10000 / DEBOUNCE_FREQ) - 1;

        /* Time Base Configuration */
    	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
    	TIM_TimeBaseStructure.TIM_Prescaler = TIM_Prescaler;
 80006fe:	f8ad 600c 	strh.w	r6, [sp, #12]
    	TIM_TimeBaseStructure.TIM_Period = TIM_Autoreload;
    	TIM_TimeBaseStructure.TIM_ClockDivision = 0x0;
 8000702:	461e      	mov	r6, r3
    	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
    	TIM_TimeBaseInit(DEBOUNCE_TIMER, &TIM_TimeBaseStructure);
 8000704:	f000 fe68 	bl	80013d8 <TIM_TimeBaseInit>
        /* TIM Configuration */
        //TIM_PrescalerConfig(DEBOUNCE_TIMER, TIM_Prescaler, TIM_PSCReloadMode_Update);
        //TIM_SetAutoreload(DEBOUNCE_TIMER, TIM_Autoreload);

        /* One Pulse Mode selection */
        TIM_SelectOnePulseMode(DEBOUNCE_TIMER, TIM_OPMode_Single);
 8000708:	481a      	ldr	r0, [pc, #104]	; (8000774 <BUTTON_Init+0xe8>)
 800070a:	2108      	movs	r1, #8
 800070c:	f000 fecc 	bl	80014a8 <TIM_SelectOnePulseMode>

        TIM_ClearITPendingBit(DEBOUNCE_TIMER, DEBOUNCE_TIMER_FLAG);
 8000710:	4818      	ldr	r0, [pc, #96]	; (8000774 <BUTTON_Init+0xe8>)
 8000712:	4621      	mov	r1, r4
 8000714:	f000 fede 	bl	80014d4 <TIM_ClearITPendingBit>

        /* TIM IT Enable */
        TIM_ITConfig(DEBOUNCE_TIMER, DEBOUNCE_TIMER_FLAG, ENABLE);
 8000718:	4622      	mov	r2, r4
 800071a:	4816      	ldr	r0, [pc, #88]	; (8000774 <BUTTON_Init+0xe8>)
 800071c:	4621      	mov	r1, r4
 800071e:	f000 feba 	bl	8001496 <TIM_ITConfig>

        /* Enable the TIM Interrupt */
        NVIC_InitStructure.NVIC_IRQChannel = DEBOUNCE_TIMER_IRQn;
        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02;
 8000722:	f04f 0802 	mov.w	r8, #2

        /* TIM IT Enable */
        TIM_ITConfig(DEBOUNCE_TIMER, DEBOUNCE_TIMER_FLAG, ENABLE);

        /* Enable the TIM Interrupt */
        NVIC_InitStructure.NVIC_IRQChannel = DEBOUNCE_TIMER_IRQn;
 8000726:	2119      	movs	r1, #25
        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02;
        NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x00;
        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;

        NVIC_Init(&NVIC_InitStructure);
 8000728:	a802      	add	r0, sp, #8

        /* TIM IT Enable */
        TIM_ITConfig(DEBOUNCE_TIMER, DEBOUNCE_TIMER_FLAG, ENABLE);

        /* Enable the TIM Interrupt */
        NVIC_InitStructure.NVIC_IRQChannel = DEBOUNCE_TIMER_IRQn;
 800072a:	f88d 1008 	strb.w	r1, [sp, #8]
        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02;
 800072e:	f88d 8009 	strb.w	r8, [sp, #9]
        NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x00;
 8000732:	f88d 600a 	strb.w	r6, [sp, #10]
        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8000736:	f88d 400b 	strb.w	r4, [sp, #11]

        NVIC_Init(&NVIC_InitStructure);
 800073a:	f000 fc29 	bl	8000f90 <NVIC_Init>

        /* Enable the Button EXTI Interrupt */
        NVIC_InitStructure.NVIC_IRQChannel = BUTTON_IRQn[Button];
 800073e:	8cb8      	ldrh	r0, [r7, #36]	; 0x24
        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02;
 8000740:	f88d 8009 	strb.w	r8, [sp, #9]
        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;

        NVIC_Init(&NVIC_InitStructure);

        /* Enable the Button EXTI Interrupt */
        NVIC_InitStructure.NVIC_IRQChannel = BUTTON_IRQn[Button];
 8000744:	f88d 0008 	strb.w	r0, [sp, #8]
        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02;
        NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x01;
        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;

        NVIC_Init(&NVIC_InitStructure);
 8000748:	a802      	add	r0, sp, #8
        NVIC_Init(&NVIC_InitStructure);

        /* Enable the Button EXTI Interrupt */
        NVIC_InitStructure.NVIC_IRQChannel = BUTTON_IRQn[Button];
        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02;
        NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x01;
 800074a:	f88d 400a 	strb.w	r4, [sp, #10]
        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 800074e:	f88d 400b 	strb.w	r4, [sp, #11]

        NVIC_Init(&NVIC_InitStructure);
 8000752:	f000 fc1d 	bl	8000f90 <NVIC_Init>

        BUTTON_DEBOUNCED[Button] = 0x00;
 8000756:	4a08      	ldr	r2, [pc, #32]	; (8000778 <BUTTON_Init+0xec>)

        BUTTON_EXTI_Config(Button, ENABLE);
 8000758:	4628      	mov	r0, r5
 800075a:	4621      	mov	r1, r4
        NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x01;
        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;

        NVIC_Init(&NVIC_InitStructure);

        BUTTON_DEBOUNCED[Button] = 0x00;
 800075c:	5556      	strb	r6, [r2, r5]

        BUTTON_EXTI_Config(Button, ENABLE);
 800075e:	f7ff ff73 	bl	8000648 <BUTTON_EXTI_Config>
    }
}
 8000762:	b006      	add	sp, #24
 8000764:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000768:	080021dc 	.word	0x080021dc
 800076c:	20000008 	.word	0x20000008
 8000770:	20000058 	.word	0x20000058
 8000774:	40012c00 	.word	0x40012c00
 8000778:	20000070 	.word	0x20000070

0800077c <Set_System>:
 * @brief  Configures Main system clocks & power.
 * @param  None
 * @retval None
 */
void Set_System(void)
{
 800077c:	b508      	push	{r3, lr}
	 To reconfigure the default setting of SystemInit() function, refer to
	 system_stm32f10x.c file
	 */

	/* Enable PWR and BKP clock */
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);
 800077e:	2101      	movs	r1, #1
 8000780:	f04f 50c0 	mov.w	r0, #402653184	; 0x18000000
 8000784:	f000 fde2 	bl	800134c <RCC_APB1PeriphClockCmd>

	/* Enable write access to Backup domain */
	PWR_BackupAccessCmd(ENABLE);
 8000788:	2001      	movs	r0, #1
 800078a:	f000 fdc1 	bl	8001310 <PWR_BackupAccessCmd>

	/* NVIC configuration */
	NVIC_Configuration();
 800078e:	f7ff ff0d 	bl	80005ac <NVIC_Configuration>

	/* Configure the LEDs and set the default states */
	int LEDx;
	for(LEDx = 0; LEDx < LEDn; ++LEDx)
	{
	    LED_Init(LEDx);
 8000792:	2000      	movs	r0, #0
 8000794:	f7ff ff0e 	bl	80005b4 <LED_Init>
	    LED_Off(LEDx);
 8000798:	2000      	movs	r0, #0
 800079a:	f7ff ff37 	bl	800060c <LED_Off>

	/* Configure the LEDs and set the default states */
	int LEDx;
	for(LEDx = 0; LEDx < LEDn; ++LEDx)
	{
	    LED_Init(LEDx);
 800079e:	2001      	movs	r0, #1
 80007a0:	f7ff ff08 	bl	80005b4 <LED_Init>
	    LED_Off(LEDx);
 80007a4:	2001      	movs	r0, #1
 80007a6:	f7ff ff31 	bl	800060c <LED_Off>
	}

    /* Configure the Button */
    BUTTON_Init(BUTTON1, BUTTON_MODE_EXTI);
 80007aa:	2000      	movs	r0, #0
 80007ac:	2101      	movs	r1, #1
 80007ae:	f7ff ff6d 	bl	800068c <BUTTON_Init>

	/* Setup SysTick Timer for 1 msec interrupts */
	if (SysTick_Config(SystemCoreClock / 1000))
 80007b2:	4b15      	ldr	r3, [pc, #84]	; (8000808 <Set_System+0x8c>)
 80007b4:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80007b8:	681a      	ldr	r2, [r3, #0]
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
 80007ba:	4b14      	ldr	r3, [pc, #80]	; (800080c <Set_System+0x90>)
 80007bc:	fbb2 f1f0 	udiv	r1, r2, r0
 80007c0:	1e4a      	subs	r2, r1, #1
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 80007c2:	4913      	ldr	r1, [pc, #76]	; (8000810 <Set_System+0x94>)
 80007c4:	20f0      	movs	r0, #240	; 0xf0
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
 80007c6:	605a      	str	r2, [r3, #4]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 80007c8:	f881 0023 	strb.w	r0, [r1, #35]	; 0x23
{
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
 80007cc:	2200      	movs	r2, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80007ce:	2007      	movs	r0, #7
{
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
 80007d0:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80007d2:	6018      	str	r0, [r3, #0]

    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grouping field */
 80007d4:	68cb      	ldr	r3, [r1, #12]
 80007d6:	f3c3 2002 	ubfx	r0, r3, #8, #3
  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
 80007da:	1d01      	adds	r1, r0, #4
 80007dc:	2906      	cmp	r1, #6
{
  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
 80007de:	f1c0 0307 	rsb	r3, r0, #7
  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
 80007e2:	bf88      	it	hi
 80007e4:	1ec2      	subhi	r2, r0, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
 80007e6:	2b04      	cmp	r3, #4
 80007e8:	bf28      	it	cs
 80007ea:	2304      	movcs	r3, #4
  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;

  return (
           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
 80007ec:	2001      	movs	r0, #1
 80007ee:	fa00 f103 	lsl.w	r1, r0, r3
 80007f2:	1e4b      	subs	r3, r1, #1
 80007f4:	f003 0003 	and.w	r0, r3, #3
 80007f8:	fa00 f202 	lsl.w	r2, r0, r2
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 80007fc:	4b04      	ldr	r3, [pc, #16]	; (8000810 <Set_System+0x94>)
 80007fe:	0111      	lsls	r1, r2, #4
 8000800:	b2c8      	uxtb	r0, r1
 8000802:	f883 0023 	strb.w	r0, [r3, #35]	; 0x23
 8000806:	bd08      	pop	{r3, pc}
 8000808:	20000058 	.word	0x20000058
 800080c:	e000e010 	.word	0xe000e010
 8000810:	e000ed00 	.word	0xe000ed00

08000814 <BUTTON_GetState>:
  *     @arg BUTTON2: Button2
  * @retval Actual Button Pressed state.
  */
uint8_t BUTTON_GetState(Button_TypeDef Button)
{
    return GPIO_ReadInputDataBit(BUTTON_PORT[Button], BUTTON_PIN[Button]);
 8000814:	4a04      	ldr	r2, [pc, #16]	; (8000828 <BUTTON_GetState+0x14>)
 8000816:	4b05      	ldr	r3, [pc, #20]	; (800082c <BUTTON_GetState+0x18>)
 8000818:	eb02 0180 	add.w	r1, r2, r0, lsl #2
 800081c:	eb03 0240 	add.w	r2, r3, r0, lsl #1
 8000820:	68c8      	ldr	r0, [r1, #12]
 8000822:	8c11      	ldrh	r1, [r2, #32]
 8000824:	f000 bd50 	b.w	80012c8 <GPIO_ReadInputDataBit>
 8000828:	20000008 	.word	0x20000008
 800082c:	080021dc 	.word	0x080021dc

08000830 <BUTTON_GetDebouncedState>:
  *     @arg BUTTON2: Button2
  * @retval Button Debounced state.
  */
uint8_t BUTTON_GetDebouncedState(Button_TypeDef Button)
{
	if(BUTTON_DEBOUNCED[BUTTON1] != 0x00)
 8000830:	4b03      	ldr	r3, [pc, #12]	; (8000840 <BUTTON_GetDebouncedState+0x10>)
 8000832:	7818      	ldrb	r0, [r3, #0]
 8000834:	b110      	cbz	r0, 800083c <BUTTON_GetDebouncedState+0xc>
	{
		BUTTON_DEBOUNCED[BUTTON1] = 0x00;
 8000836:	2200      	movs	r2, #0
 8000838:	701a      	strb	r2, [r3, #0]
		return 0x01;
 800083a:	2001      	movs	r0, #1
	}
	return 0x00;
}
 800083c:	4770      	bx	lr
 800083e:	bf00      	nop
 8000840:	20000070 	.word	0x20000070

08000844 <CC3000_SPI_Init>:
 * @brief  Initialize and configure the SPI peripheral used by CC3000.
 * @param  None
 * @retval None
 */
void CC3000_SPI_Init(void)
{
 8000844:	b530      	push	{r4, r5, lr}
	GPIO_InitTypeDef GPIO_InitStructure;
	SPI_InitTypeDef SPI_InitStructure;

	/* CC3000_SPI_SCK_GPIO, CC3000_SPI_MOSI_GPIO and CC3000_SPI_MISO_GPIO Peripheral clock enable */
	RCC_APB2PeriphClockCmd(CC3000_SPI_SCK_GPIO_CLK | CC3000_SPI_MOSI_GPIO_CLK | CC3000_SPI_MISO_GPIO_CLK, ENABLE);
 8000846:	2008      	movs	r0, #8
 * @brief  Initialize and configure the SPI peripheral used by CC3000.
 * @param  None
 * @retval None
 */
void CC3000_SPI_Init(void)
{
 8000848:	b087      	sub	sp, #28
	GPIO_InitTypeDef GPIO_InitStructure;
	SPI_InitTypeDef SPI_InitStructure;

	/* CC3000_SPI_SCK_GPIO, CC3000_SPI_MOSI_GPIO and CC3000_SPI_MISO_GPIO Peripheral clock enable */
	RCC_APB2PeriphClockCmd(CC3000_SPI_SCK_GPIO_CLK | CC3000_SPI_MOSI_GPIO_CLK | CC3000_SPI_MISO_GPIO_CLK, ENABLE);
 800084a:	2101      	movs	r1, #1
 800084c:	f000 fd72 	bl	8001334 <RCC_APB2PeriphClockCmd>

	/* Configure CC3000_SPI pins: SCK */
	GPIO_InitStructure.GPIO_Pin = CC3000_SPI_SCK_PIN;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_Init(CC3000_SPI_SCK_GPIO_PORT, &GPIO_InitStructure);
 8000850:	4c22      	ldr	r4, [pc, #136]	; (80008dc <CC3000_SPI_Init+0x98>)

	/* CC3000_SPI_SCK_GPIO, CC3000_SPI_MOSI_GPIO and CC3000_SPI_MISO_GPIO Peripheral clock enable */
	RCC_APB2PeriphClockCmd(CC3000_SPI_SCK_GPIO_CLK | CC3000_SPI_MOSI_GPIO_CLK | CC3000_SPI_MISO_GPIO_CLK, ENABLE);

	/* CC3000_SPI Peripheral clock enable */
	CC3000_SPI_CLK_CMD(CC3000_SPI_CLK, ENABLE);
 8000852:	2101      	movs	r1, #1
 8000854:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8000858:	f000 fd78 	bl	800134c <RCC_APB1PeriphClockCmd>

	/* Configure CC3000_SPI pins: SCK */
	GPIO_InitStructure.GPIO_Pin = CC3000_SPI_SCK_PIN;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
 800085c:	2018      	movs	r0, #24

	/* CC3000_SPI Peripheral clock enable */
	CC3000_SPI_CLK_CMD(CC3000_SPI_CLK, ENABLE);

	/* Configure CC3000_SPI pins: SCK */
	GPIO_InitStructure.GPIO_Pin = CC3000_SPI_SCK_PIN;
 800085e:	f44f 5300 	mov.w	r3, #8192	; 0x2000
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
 8000862:	2501      	movs	r5, #1
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
 8000864:	f88d 0003 	strb.w	r0, [sp, #3]
	GPIO_Init(CC3000_SPI_SCK_GPIO_PORT, &GPIO_InitStructure);
 8000868:	4669      	mov	r1, sp
 800086a:	4620      	mov	r0, r4

	/* CC3000_SPI Peripheral clock enable */
	CC3000_SPI_CLK_CMD(CC3000_SPI_CLK, ENABLE);

	/* Configure CC3000_SPI pins: SCK */
	GPIO_InitStructure.GPIO_Pin = CC3000_SPI_SCK_PIN;
 800086c:	f8ad 3000 	strh.w	r3, [sp]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
 8000870:	f88d 5002 	strb.w	r5, [sp, #2]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_Init(CC3000_SPI_SCK_GPIO_PORT, &GPIO_InitStructure);
 8000874:	f000 fcd8 	bl	8001228 <GPIO_Init>

	/* Configure CC3000_SPI pins: MOSI */
	GPIO_InitStructure.GPIO_Pin = CC3000_SPI_MOSI_PIN;
 8000878:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800087c:	f8ad 1000 	strh.w	r1, [sp]
	GPIO_Init(CC3000_SPI_MOSI_GPIO_PORT, &GPIO_InitStructure);
 8000880:	4620      	mov	r0, r4
 8000882:	4669      	mov	r1, sp
 8000884:	f000 fcd0 	bl	8001228 <GPIO_Init>

	/* Configure CC3000_SPI pins: MISO */
	GPIO_InitStructure.GPIO_Pin = CC3000_SPI_MISO_PIN;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
 8000888:	2304      	movs	r3, #4
	/* Configure CC3000_SPI pins: MOSI */
	GPIO_InitStructure.GPIO_Pin = CC3000_SPI_MOSI_PIN;
	GPIO_Init(CC3000_SPI_MOSI_GPIO_PORT, &GPIO_InitStructure);

	/* Configure CC3000_SPI pins: MISO */
	GPIO_InitStructure.GPIO_Pin = CC3000_SPI_MISO_PIN;
 800088a:	f44f 4280 	mov.w	r2, #16384	; 0x4000
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
	GPIO_Init(CC3000_SPI_MISO_GPIO_PORT, &GPIO_InitStructure);
 800088e:	4620      	mov	r0, r4
 8000890:	4669      	mov	r1, sp
	/* Configure CC3000_SPI pins: MOSI */
	GPIO_InitStructure.GPIO_Pin = CC3000_SPI_MOSI_PIN;
	GPIO_Init(CC3000_SPI_MOSI_GPIO_PORT, &GPIO_InitStructure);

	/* Configure CC3000_SPI pins: MISO */
	GPIO_InitStructure.GPIO_Pin = CC3000_SPI_MISO_PIN;
 8000892:	f8ad 2000 	strh.w	r2, [sp]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
 8000896:	f88d 3003 	strb.w	r3, [sp, #3]
	GPIO_Init(CC3000_SPI_MISO_GPIO_PORT, &GPIO_InitStructure);
 800089a:	f000 fcc5 	bl	8001228 <GPIO_Init>

	/* CC3000_SPI Config */
	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
 800089e:	2000      	movs	r0, #0
 80008a0:	f8ad 0004 	strh.w	r0, [sp, #4]
	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
 80008a4:	f44f 7182 	mov.w	r1, #260	; 0x104
	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
 80008a8:	f8ad 0008 	strh.w	r0, [sp, #8]
	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
 80008ac:	f8ad 000a 	strh.w	r0, [sp, #10]
	SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;
	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
	SPI_InitStructure.SPI_BaudRatePrescaler = CC3000_SPI_BAUDRATE_PRESCALER;
	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
 80008b0:	f8ad 0012 	strh.w	r0, [sp, #18]
	SPI_InitStructure.SPI_CRCPolynomial = 7;
 80008b4:	2007      	movs	r0, #7
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
	GPIO_Init(CC3000_SPI_MISO_GPIO_PORT, &GPIO_InitStructure);

	/* CC3000_SPI Config */
	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
 80008b6:	f8ad 1006 	strh.w	r1, [sp, #6]
	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
	SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;
	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
 80008ba:	f44f 7200 	mov.w	r2, #512	; 0x200
	SPI_InitStructure.SPI_BaudRatePrescaler = CC3000_SPI_BAUDRATE_PRESCALER;
 80008be:	2320      	movs	r3, #32
	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
	SPI_InitStructure.SPI_CRCPolynomial = 7;
 80008c0:	f8ad 0014 	strh.w	r0, [sp, #20]
	SPI_Init(CC3000_SPI, &SPI_InitStructure);
 80008c4:	a901      	add	r1, sp, #4
 80008c6:	4806      	ldr	r0, [pc, #24]	; (80008e0 <CC3000_SPI_Init+0x9c>)
	/* CC3000_SPI Config */
	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
	SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;
 80008c8:	f8ad 500c 	strh.w	r5, [sp, #12]
	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
 80008cc:	f8ad 200e 	strh.w	r2, [sp, #14]
	SPI_InitStructure.SPI_BaudRatePrescaler = CC3000_SPI_BAUDRATE_PRESCALER;
 80008d0:	f8ad 3010 	strh.w	r3, [sp, #16]
	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
	SPI_InitStructure.SPI_CRCPolynomial = 7;
	SPI_Init(CC3000_SPI, &SPI_InitStructure);
 80008d4:	f000 fd46 	bl	8001364 <SPI_Init>
}
 80008d8:	b007      	add	sp, #28
 80008da:	bd30      	pop	{r4, r5, pc}
 80008dc:	40010c00 	.word	0x40010c00
 80008e0:	40003800 	.word	0x40003800

080008e4 <CC3000_DMA_Config>:
 * @brief  Configure the DMA Peripheral used to handle CC3000 communication via SPI.
 * @param  None
 * @retval None
 */
void CC3000_DMA_Config(CC3000_DMADirection_TypeDef Direction, uint8_t* buffer, uint16_t NumData)
{
 80008e4:	b570      	push	{r4, r5, r6, lr}
 80008e6:	4604      	mov	r4, r0
	DMA_InitTypeDef DMA_InitStructure;

	RCC_AHBPeriphClockCmd(CC3000_SPI_DMA_CLK, ENABLE);
 80008e8:	2001      	movs	r0, #1
 * @brief  Configure the DMA Peripheral used to handle CC3000 communication via SPI.
 * @param  None
 * @retval None
 */
void CC3000_DMA_Config(CC3000_DMADirection_TypeDef Direction, uint8_t* buffer, uint16_t NumData)
{
 80008ea:	b08c      	sub	sp, #48	; 0x30
 80008ec:	460e      	mov	r6, r1
	DMA_InitTypeDef DMA_InitStructure;

	RCC_AHBPeriphClockCmd(CC3000_SPI_DMA_CLK, ENABLE);
 80008ee:	4601      	mov	r1, r0
 * @brief  Configure the DMA Peripheral used to handle CC3000 communication via SPI.
 * @param  None
 * @retval None
 */
void CC3000_DMA_Config(CC3000_DMADirection_TypeDef Direction, uint8_t* buffer, uint16_t NumData)
{
 80008f0:	4615      	mov	r5, r2
	DMA_InitTypeDef DMA_InitStructure;

	RCC_AHBPeriphClockCmd(CC3000_SPI_DMA_CLK, ENABLE);
 80008f2:	f000 fd13 	bl	800131c <RCC_AHBPeriphClockCmd>

	DMA_InitStructure.DMA_PeripheralBaseAddr = CC3000_SPI_DR_BASE;
 80008f6:	4b12      	ldr	r3, [pc, #72]	; (8000940 <CC3000_DMA_Config+0x5c>)
	DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t) buffer;
	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 80008f8:	2000      	movs	r0, #0
	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 80008fa:	2280      	movs	r2, #128	; 0x80
	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
	DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;
 80008fc:	f44f 5140 	mov.w	r1, #12288	; 0x3000
	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;

	/* DMA used for Reception */
	if (Direction == CC3000_DMA_RX)
 8000900:	2c01      	cmp	r4, #1
{
	DMA_InitTypeDef DMA_InitStructure;

	RCC_AHBPeriphClockCmd(CC3000_SPI_DMA_CLK, ENABLE);

	DMA_InitStructure.DMA_PeripheralBaseAddr = CC3000_SPI_DR_BASE;
 8000902:	9301      	str	r3, [sp, #4]
	DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t) buffer;
 8000904:	9602      	str	r6, [sp, #8]
	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 8000906:	9005      	str	r0, [sp, #20]
	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 8000908:	9206      	str	r2, [sp, #24]
	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 800090a:	9007      	str	r0, [sp, #28]
	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 800090c:	9008      	str	r0, [sp, #32]
	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
 800090e:	9009      	str	r0, [sp, #36]	; 0x24
	DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;
 8000910:	910a      	str	r1, [sp, #40]	; 0x28
	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
 8000912:	900b      	str	r0, [sp, #44]	; 0x2c

	/* DMA used for Reception */
	if (Direction == CC3000_DMA_RX)
 8000914:	d106      	bne.n	8000924 <CC3000_DMA_Config+0x40>
	{
		DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
 8000916:	9003      	str	r0, [sp, #12]
		DMA_InitStructure.DMA_BufferSize = NumData;
		DMA_DeInit(CC3000_SPI_RX_DMA_CHANNEL );
 8000918:	480a      	ldr	r0, [pc, #40]	; (8000944 <CC3000_DMA_Config+0x60>)

	/* DMA used for Reception */
	if (Direction == CC3000_DMA_RX)
	{
		DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
		DMA_InitStructure.DMA_BufferSize = NumData;
 800091a:	9504      	str	r5, [sp, #16]
		DMA_DeInit(CC3000_SPI_RX_DMA_CHANNEL );
 800091c:	f000 fb6c 	bl	8000ff8 <DMA_DeInit>
		DMA_Init(CC3000_SPI_RX_DMA_CHANNEL, &DMA_InitStructure);
 8000920:	4808      	ldr	r0, [pc, #32]	; (8000944 <CC3000_DMA_Config+0x60>)
 8000922:	e007      	b.n	8000934 <CC3000_DMA_Config+0x50>
	}
	/* DMA used for Transmission */
	else if (Direction == CC3000_DMA_TX)
 8000924:	b94c      	cbnz	r4, 800093a <CC3000_DMA_Config+0x56>
	{
		DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
 8000926:	2310      	movs	r3, #16
		DMA_InitStructure.DMA_BufferSize = NumData;
		DMA_DeInit(CC3000_SPI_TX_DMA_CHANNEL );
 8000928:	4807      	ldr	r0, [pc, #28]	; (8000948 <CC3000_DMA_Config+0x64>)
		DMA_Init(CC3000_SPI_RX_DMA_CHANNEL, &DMA_InitStructure);
	}
	/* DMA used for Transmission */
	else if (Direction == CC3000_DMA_TX)
	{
		DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
 800092a:	9303      	str	r3, [sp, #12]
		DMA_InitStructure.DMA_BufferSize = NumData;
 800092c:	9504      	str	r5, [sp, #16]
		DMA_DeInit(CC3000_SPI_TX_DMA_CHANNEL );
 800092e:	f000 fb63 	bl	8000ff8 <DMA_DeInit>
		DMA_Init(CC3000_SPI_TX_DMA_CHANNEL, &DMA_InitStructure);
 8000932:	4805      	ldr	r0, [pc, #20]	; (8000948 <CC3000_DMA_Config+0x64>)
 8000934:	a901      	add	r1, sp, #4
 8000936:	f000 fbd7 	bl	80010e8 <DMA_Init>
	}
}
 800093a:	b00c      	add	sp, #48	; 0x30
 800093c:	bd70      	pop	{r4, r5, r6, pc}
 800093e:	bf00      	nop
 8000940:	4000380c 	.word	0x4000380c
 8000944:	40020044 	.word	0x40020044
 8000948:	40020058 	.word	0x40020058

0800094c <CC3000_SPI_DMA_Init>:

void CC3000_SPI_DMA_Init(void)
{
 800094c:	b573      	push	{r0, r1, r4, r5, r6, lr}
	NVIC_InitTypeDef NVIC_InitStructure;

	/* Configure and enable SPI DMA TX Channel interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = CC3000_SPI_TX_DMA_IRQn;
 800094e:	230f      	movs	r3, #15
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x00;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8000950:	2401      	movs	r4, #1
{
	NVIC_InitTypeDef NVIC_InitStructure;

	/* Configure and enable SPI DMA TX Channel interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = CC3000_SPI_TX_DMA_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00;
 8000952:	2500      	movs	r5, #0
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x00;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);
 8000954:	a801      	add	r0, sp, #4
void CC3000_SPI_DMA_Init(void)
{
	NVIC_InitTypeDef NVIC_InitStructure;

	/* Configure and enable SPI DMA TX Channel interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = CC3000_SPI_TX_DMA_IRQn;
 8000956:	f88d 3004 	strb.w	r3, [sp, #4]
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00;
 800095a:	f88d 5005 	strb.w	r5, [sp, #5]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x00;
 800095e:	f88d 5006 	strb.w	r5, [sp, #6]
	/* Configure DMA Peripheral but don't send data*/
	CC3000_DMA_Config(CC3000_DMA_RX, (uint8_t*) wlan_rx_buffer, 0);
	CC3000_DMA_Config(CC3000_DMA_TX, (uint8_t*) wlan_tx_buffer, 0);

	/* Enable SPI DMA TX Channel Transfer Complete Interrupt */
	DMA_ITConfig(CC3000_SPI_TX_DMA_CHANNEL, DMA_IT_TC, ENABLE);
 8000962:	4e17      	ldr	r6, [pc, #92]	; (80009c0 <CC3000_SPI_DMA_Init+0x74>)

	/* Configure and enable SPI DMA TX Channel interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = CC3000_SPI_TX_DMA_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x00;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8000964:	f88d 4007 	strb.w	r4, [sp, #7]
	NVIC_Init(&NVIC_InitStructure);
 8000968:	f000 fb12 	bl	8000f90 <NVIC_Init>

	CC3000_SPI_Init();
 800096c:	f7ff ff6a 	bl	8000844 <CC3000_SPI_Init>

	/* Configure DMA Peripheral but don't send data*/
	CC3000_DMA_Config(CC3000_DMA_RX, (uint8_t*) wlan_rx_buffer, 0);
 8000970:	4620      	mov	r0, r4
 8000972:	462a      	mov	r2, r5
 8000974:	4913      	ldr	r1, [pc, #76]	; (80009c4 <CC3000_SPI_DMA_Init+0x78>)
 8000976:	f7ff ffb5 	bl	80008e4 <CC3000_DMA_Config>
	CC3000_DMA_Config(CC3000_DMA_TX, (uint8_t*) wlan_tx_buffer, 0);
 800097a:	4628      	mov	r0, r5
 800097c:	462a      	mov	r2, r5
 800097e:	4912      	ldr	r1, [pc, #72]	; (80009c8 <CC3000_SPI_DMA_Init+0x7c>)

	/* Enable SPI DMA TX Channel Transfer Complete Interrupt */
	DMA_ITConfig(CC3000_SPI_TX_DMA_CHANNEL, DMA_IT_TC, ENABLE);

	/* Enable SPI DMA request */
	SPI_I2S_DMACmd(CC3000_SPI, SPI_I2S_DMAReq_Rx, ENABLE);
 8000980:	4d12      	ldr	r5, [pc, #72]	; (80009cc <CC3000_SPI_DMA_Init+0x80>)

	CC3000_SPI_Init();

	/* Configure DMA Peripheral but don't send data*/
	CC3000_DMA_Config(CC3000_DMA_RX, (uint8_t*) wlan_rx_buffer, 0);
	CC3000_DMA_Config(CC3000_DMA_TX, (uint8_t*) wlan_tx_buffer, 0);
 8000982:	f7ff ffaf 	bl	80008e4 <CC3000_DMA_Config>

	/* Enable SPI DMA TX Channel Transfer Complete Interrupt */
	DMA_ITConfig(CC3000_SPI_TX_DMA_CHANNEL, DMA_IT_TC, ENABLE);
 8000986:	4630      	mov	r0, r6
 8000988:	2102      	movs	r1, #2
 800098a:	4622      	mov	r2, r4
 800098c:	f000 fbd7 	bl	800113e <DMA_ITConfig>

	/* Enable SPI DMA request */
	SPI_I2S_DMACmd(CC3000_SPI, SPI_I2S_DMAReq_Rx, ENABLE);
 8000990:	4628      	mov	r0, r5
 8000992:	4621      	mov	r1, r4
 8000994:	4622      	mov	r2, r4
 8000996:	f000 fd10 	bl	80013ba <SPI_I2S_DMACmd>
	SPI_I2S_DMACmd(CC3000_SPI, SPI_I2S_DMAReq_Tx, ENABLE);
 800099a:	4622      	mov	r2, r4
 800099c:	4628      	mov	r0, r5
 800099e:	2102      	movs	r1, #2
 80009a0:	f000 fd0b 	bl	80013ba <SPI_I2S_DMACmd>

	/* Enable CC3000_SPI */
	SPI_Cmd(CC3000_SPI, ENABLE);
 80009a4:	4628      	mov	r0, r5
 80009a6:	4621      	mov	r1, r4
 80009a8:	f000 fcfb 	bl	80013a2 <SPI_Cmd>

	/* Enable DMA RX Channel */
	DMA_Cmd(CC3000_SPI_RX_DMA_CHANNEL, ENABLE);
 80009ac:	4621      	mov	r1, r4
 80009ae:	4808      	ldr	r0, [pc, #32]	; (80009d0 <CC3000_SPI_DMA_Init+0x84>)
 80009b0:	f000 fbba 	bl	8001128 <DMA_Cmd>
	/* Enable DMA TX Channel */
	DMA_Cmd(CC3000_SPI_TX_DMA_CHANNEL, ENABLE);
 80009b4:	4630      	mov	r0, r6
 80009b6:	4621      	mov	r1, r4
 80009b8:	f000 fbb6 	bl	8001128 <DMA_Cmd>
}
 80009bc:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}
 80009be:	bf00      	nop
 80009c0:	40020058 	.word	0x40020058
 80009c4:	20000498 	.word	0x20000498
 80009c8:	20000098 	.word	0x20000098
 80009cc:	40003800 	.word	0x40003800
 80009d0:	40020044 	.word	0x40020044

080009d4 <CC3000_SPI_DMA_Channels>:

void CC3000_SPI_DMA_Channels(FunctionalState NewState)
{
 80009d4:	b510      	push	{r4, lr}
 80009d6:	4604      	mov	r4, r0
	/* Enable/Disable DMA RX Channel */
	DMA_Cmd(CC3000_SPI_RX_DMA_CHANNEL, NewState);
 80009d8:	4621      	mov	r1, r4
 80009da:	4804      	ldr	r0, [pc, #16]	; (80009ec <CC3000_SPI_DMA_Channels+0x18>)
 80009dc:	f000 fba4 	bl	8001128 <DMA_Cmd>
	/* Enable/Disable DMA TX Channel */
	DMA_Cmd(CC3000_SPI_TX_DMA_CHANNEL, NewState);
 80009e0:	4803      	ldr	r0, [pc, #12]	; (80009f0 <CC3000_SPI_DMA_Channels+0x1c>)
 80009e2:	4621      	mov	r1, r4
}
 80009e4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void CC3000_SPI_DMA_Channels(FunctionalState NewState)
{
	/* Enable/Disable DMA RX Channel */
	DMA_Cmd(CC3000_SPI_RX_DMA_CHANNEL, NewState);
	/* Enable/Disable DMA TX Channel */
	DMA_Cmd(CC3000_SPI_TX_DMA_CHANNEL, NewState);
 80009e8:	f000 bb9e 	b.w	8001128 <DMA_Cmd>
 80009ec:	40020044 	.word	0x40020044
 80009f0:	40020058 	.word	0x40020058

080009f4 <CC3000_Read_Interrupt_Pin>:
}

/* CC3000 Hardware related callbacks passed to wlan_init */
long CC3000_Read_Interrupt_Pin(void)
{
 80009f4:	b508      	push	{r3, lr}
	return GPIO_ReadInputDataBit(CC3000_WIFI_INT_GPIO_PORT, CC3000_WIFI_INT_PIN );
 80009f6:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80009fa:	4802      	ldr	r0, [pc, #8]	; (8000a04 <CC3000_Read_Interrupt_Pin+0x10>)
 80009fc:	f000 fc64 	bl	80012c8 <GPIO_ReadInputDataBit>
}
 8000a00:	bd08      	pop	{r3, pc}
 8000a02:	bf00      	nop
 8000a04:	40010c00 	.word	0x40010c00

08000a08 <CC3000_Interrupt_Enable>:

void CC3000_Interrupt_Enable(void)
{
 8000a08:	b530      	push	{r4, r5, lr}
	GPIO_InitTypeDef GPIO_InitStructure;
	EXTI_InitTypeDef EXTI_InitStructure;
	NVIC_InitTypeDef NVIC_InitStructure;

	/* CC3000_WIFI_INT_GPIO and AFIO Peripheral clock enable */
	RCC_APB2PeriphClockCmd(CC3000_WIFI_INT_GPIO_CLK | RCC_APB2Periph_AFIO, ENABLE);
 8000a0a:	2009      	movs	r0, #9
{
	return GPIO_ReadInputDataBit(CC3000_WIFI_INT_GPIO_PORT, CC3000_WIFI_INT_PIN );
}

void CC3000_Interrupt_Enable(void)
{
 8000a0c:	b085      	sub	sp, #20
	GPIO_InitTypeDef GPIO_InitStructure;
	EXTI_InitTypeDef EXTI_InitStructure;
	NVIC_InitTypeDef NVIC_InitStructure;

	/* CC3000_WIFI_INT_GPIO and AFIO Peripheral clock enable */
	RCC_APB2PeriphClockCmd(CC3000_WIFI_INT_GPIO_CLK | RCC_APB2Periph_AFIO, ENABLE);
 8000a0e:	2101      	movs	r1, #1
 8000a10:	f000 fc90 	bl	8001334 <RCC_APB2PeriphClockCmd>

	/* Configure CC3000_WIFI pins: Interrupt */
	GPIO_InitStructure.GPIO_Pin = CC3000_WIFI_INT_PIN;
 8000a14:	f44f 6400 	mov.w	r4, #2048	; 0x800
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 8000a18:	2348      	movs	r3, #72	; 0x48
	GPIO_Init(CC3000_WIFI_INT_GPIO_PORT, &GPIO_InitStructure);
 8000a1a:	4669      	mov	r1, sp
 8000a1c:	4814      	ldr	r0, [pc, #80]	; (8000a70 <CC3000_Interrupt_Enable+0x68>)
	/* CC3000_WIFI_INT_GPIO and AFIO Peripheral clock enable */
	RCC_APB2PeriphClockCmd(CC3000_WIFI_INT_GPIO_CLK | RCC_APB2Periph_AFIO, ENABLE);

	/* Configure CC3000_WIFI pins: Interrupt */
	GPIO_InitStructure.GPIO_Pin = CC3000_WIFI_INT_PIN;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 8000a1e:	f88d 3003 	strb.w	r3, [sp, #3]

	/* CC3000_WIFI_INT_GPIO and AFIO Peripheral clock enable */
	RCC_APB2PeriphClockCmd(CC3000_WIFI_INT_GPIO_CLK | RCC_APB2Periph_AFIO, ENABLE);

	/* Configure CC3000_WIFI pins: Interrupt */
	GPIO_InitStructure.GPIO_Pin = CC3000_WIFI_INT_PIN;
 8000a22:	f8ad 4000 	strh.w	r4, [sp]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_Init(CC3000_WIFI_INT_GPIO_PORT, &GPIO_InitStructure);
 8000a26:	f000 fbff 	bl	8001228 <GPIO_Init>

	/* Select the CC3000_WIFI_INT GPIO pin used as EXTI Line */
	GPIO_EXTILineConfig(CC3000_WIFI_INT_EXTI_PORT_SOURCE, CC3000_WIFI_INT_EXTI_PIN_SOURCE );
 8000a2a:	210b      	movs	r1, #11
 8000a2c:	2001      	movs	r0, #1
 8000a2e:	f000 fc55 	bl	80012dc <GPIO_EXTILineConfig>

	/* Clear the EXTI line pending flag */
	EXTI_ClearFlag(CC3000_WIFI_INT_EXTI_LINE );
 8000a32:	4620      	mov	r0, r4
 8000a34:	f000 fbe2 	bl	80011fc <EXTI_ClearFlag>

	/* Configure and Enable CC3000_WIFI_INT EXTI line */
	EXTI_InitStructure.EXTI_Line = CC3000_WIFI_INT_EXTI_LINE;
	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
 8000a38:	200c      	movs	r0, #12

	/* Clear the EXTI line pending flag */
	EXTI_ClearFlag(CC3000_WIFI_INT_EXTI_LINE );

	/* Configure and Enable CC3000_WIFI_INT EXTI line */
	EXTI_InitStructure.EXTI_Line = CC3000_WIFI_INT_EXTI_LINE;
 8000a3a:	9402      	str	r4, [sp, #8]
	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
 8000a3c:	2500      	movs	r5, #0
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 8000a3e:	2401      	movs	r4, #1
	EXTI_ClearFlag(CC3000_WIFI_INT_EXTI_LINE );

	/* Configure and Enable CC3000_WIFI_INT EXTI line */
	EXTI_InitStructure.EXTI_Line = CC3000_WIFI_INT_EXTI_LINE;
	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
 8000a40:	f88d 000d 	strb.w	r0, [sp, #13]
	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
	EXTI_Init(&EXTI_InitStructure);
 8000a44:	a802      	add	r0, sp, #8
	/* Clear the EXTI line pending flag */
	EXTI_ClearFlag(CC3000_WIFI_INT_EXTI_LINE );

	/* Configure and Enable CC3000_WIFI_INT EXTI line */
	EXTI_InitStructure.EXTI_Line = CC3000_WIFI_INT_EXTI_LINE;
	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
 8000a46:	f88d 500c 	strb.w	r5, [sp, #12]
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 8000a4a:	f88d 400e 	strb.w	r4, [sp, #14]
	EXTI_Init(&EXTI_InitStructure);
 8000a4e:	f000 fb99 	bl	8001184 <EXTI_Init>

	/* Enable and set CC3000_WIFI_INT EXTI Interrupt to the lowest priority */
	NVIC_InitStructure.NVIC_IRQChannel = CC3000_WIFI_INT_EXTI_IRQn;
 8000a52:	2128      	movs	r1, #40	; 0x28
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x01;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);
 8000a54:	a801      	add	r0, sp, #4
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
	EXTI_Init(&EXTI_InitStructure);

	/* Enable and set CC3000_WIFI_INT EXTI Interrupt to the lowest priority */
	NVIC_InitStructure.NVIC_IRQChannel = CC3000_WIFI_INT_EXTI_IRQn;
 8000a56:	f88d 1004 	strb.w	r1, [sp, #4]
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00;
 8000a5a:	f88d 5005 	strb.w	r5, [sp, #5]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x01;
 8000a5e:	f88d 4006 	strb.w	r4, [sp, #6]
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8000a62:	f88d 4007 	strb.w	r4, [sp, #7]
	NVIC_Init(&NVIC_InitStructure);
 8000a66:	f000 fa93 	bl	8000f90 <NVIC_Init>
}
 8000a6a:	b005      	add	sp, #20
 8000a6c:	bd30      	pop	{r4, r5, pc}
 8000a6e:	bf00      	nop
 8000a70:	40010c00 	.word	0x40010c00

08000a74 <CC3000_Interrupt_Disable>:

void CC3000_Interrupt_Disable(void)
{
 8000a74:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	EXTI_InitTypeDef EXTI_InitStructure;
	NVIC_InitTypeDef NVIC_InitStructure;

	/* Disable CC3000_WIFI_INT EXTI Interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = CC3000_WIFI_INT_EXTI_IRQn;
 8000a76:	2328      	movs	r3, #40	; 0x28
	NVIC_InitStructure.NVIC_IRQChannelCmd = DISABLE;
 8000a78:	2400      	movs	r4, #0
	NVIC_Init(&NVIC_InitStructure);
 8000a7a:	a801      	add	r0, sp, #4
{
	EXTI_InitTypeDef EXTI_InitStructure;
	NVIC_InitTypeDef NVIC_InitStructure;

	/* Disable CC3000_WIFI_INT EXTI Interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = CC3000_WIFI_INT_EXTI_IRQn;
 8000a7c:	f88d 3004 	strb.w	r3, [sp, #4]
	NVIC_InitStructure.NVIC_IRQChannelCmd = DISABLE;
 8000a80:	f88d 4007 	strb.w	r4, [sp, #7]
	NVIC_Init(&NVIC_InitStructure);
 8000a84:	f000 fa84 	bl	8000f90 <NVIC_Init>

	/* Disable CC3000_WIFI_INT EXTI line */
	EXTI_InitStructure.EXTI_Line = CC3000_WIFI_INT_EXTI_LINE;
 8000a88:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8000a8c:	9002      	str	r0, [sp, #8]
	EXTI_InitStructure.EXTI_LineCmd = DISABLE;
	EXTI_Init(&EXTI_InitStructure);
 8000a8e:	a802      	add	r0, sp, #8
	NVIC_InitStructure.NVIC_IRQChannelCmd = DISABLE;
	NVIC_Init(&NVIC_InitStructure);

	/* Disable CC3000_WIFI_INT EXTI line */
	EXTI_InitStructure.EXTI_Line = CC3000_WIFI_INT_EXTI_LINE;
	EXTI_InitStructure.EXTI_LineCmd = DISABLE;
 8000a90:	f88d 400e 	strb.w	r4, [sp, #14]
	EXTI_Init(&EXTI_InitStructure);
 8000a94:	f000 fb76 	bl	8001184 <EXTI_Init>
}
 8000a98:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}
	...

08000a9c <CC3000_Write_Enable_Pin>:

void CC3000_Write_Enable_Pin(unsigned char val)
{
	/* Set WLAN Enable/Disable */
	if (val != WLAN_DISABLE)
 8000a9c:	b120      	cbz	r0, 8000aa8 <CC3000_Write_Enable_Pin+0xc>
	{
		GPIO_SetBits(CC3000_WIFI_EN_GPIO_PORT, CC3000_WIFI_EN_PIN );
 8000a9e:	4805      	ldr	r0, [pc, #20]	; (8000ab4 <CC3000_Write_Enable_Pin+0x18>)
 8000aa0:	f44f 7180 	mov.w	r1, #256	; 0x100
 8000aa4:	f000 bc16 	b.w	80012d4 <GPIO_SetBits>
	}
	else
	{
		GPIO_ResetBits(CC3000_WIFI_EN_GPIO_PORT, CC3000_WIFI_EN_PIN );
 8000aa8:	4802      	ldr	r0, [pc, #8]	; (8000ab4 <CC3000_Write_Enable_Pin+0x18>)
 8000aaa:	f44f 7180 	mov.w	r1, #256	; 0x100
 8000aae:	f000 bc13 	b.w	80012d8 <GPIO_ResetBits>
 8000ab2:	bf00      	nop
 8000ab4:	40010c00 	.word	0x40010c00

08000ab8 <CC3000_WIFI_Init>:
 * @brief  Initialize the CC3000 - CS and ENABLE lines.
 * @param  None
 * @retval None
 */
void CC3000_WIFI_Init(void)
{
 8000ab8:	b537      	push	{r0, r1, r2, r4, r5, lr}

	/* Configure CC3000_WIFI pins: CS */
	GPIO_InitStructure.GPIO_Pin = CC3000_WIFI_CS_PIN;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_Init(CC3000_WIFI_CS_GPIO_PORT, &GPIO_InitStructure);
 8000aba:	4c11      	ldr	r4, [pc, #68]	; (8000b00 <CC3000_WIFI_Init+0x48>)
void CC3000_WIFI_Init(void)
{
	GPIO_InitTypeDef GPIO_InitStructure;

	/* CC3000_WIFI_CS_GPIO and CC3000_WIFI_EN_GPIO Peripheral clock enable */
	RCC_APB2PeriphClockCmd(CC3000_WIFI_CS_GPIO_CLK | CC3000_WIFI_EN_GPIO_CLK, ENABLE);
 8000abc:	2008      	movs	r0, #8
 8000abe:	2101      	movs	r1, #1
 8000ac0:	f000 fc38 	bl	8001334 <RCC_APB2PeriphClockCmd>

	/* Configure CC3000_WIFI pins: CS */
	GPIO_InitStructure.GPIO_Pin = CC3000_WIFI_CS_PIN;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8000ac4:	2010      	movs	r0, #16
	/* CC3000_WIFI_CS_GPIO and CC3000_WIFI_EN_GPIO Peripheral clock enable */
	RCC_APB2PeriphClockCmd(CC3000_WIFI_CS_GPIO_CLK | CC3000_WIFI_EN_GPIO_CLK, ENABLE);

	/* Configure CC3000_WIFI pins: CS */
	GPIO_InitStructure.GPIO_Pin = CC3000_WIFI_CS_PIN;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8000ac6:	2303      	movs	r3, #3

	/* CC3000_WIFI_CS_GPIO and CC3000_WIFI_EN_GPIO Peripheral clock enable */
	RCC_APB2PeriphClockCmd(CC3000_WIFI_CS_GPIO_CLK | CC3000_WIFI_EN_GPIO_CLK, ENABLE);

	/* Configure CC3000_WIFI pins: CS */
	GPIO_InitStructure.GPIO_Pin = CC3000_WIFI_CS_PIN;
 8000ac8:	f44f 5580 	mov.w	r5, #4096	; 0x1000
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8000acc:	f88d 0007 	strb.w	r0, [sp, #7]
	GPIO_Init(CC3000_WIFI_CS_GPIO_PORT, &GPIO_InitStructure);
 8000ad0:	a901      	add	r1, sp, #4
 8000ad2:	4620      	mov	r0, r4
	/* CC3000_WIFI_CS_GPIO and CC3000_WIFI_EN_GPIO Peripheral clock enable */
	RCC_APB2PeriphClockCmd(CC3000_WIFI_CS_GPIO_CLK | CC3000_WIFI_EN_GPIO_CLK, ENABLE);

	/* Configure CC3000_WIFI pins: CS */
	GPIO_InitStructure.GPIO_Pin = CC3000_WIFI_CS_PIN;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8000ad4:	f88d 3006 	strb.w	r3, [sp, #6]

	/* CC3000_WIFI_CS_GPIO and CC3000_WIFI_EN_GPIO Peripheral clock enable */
	RCC_APB2PeriphClockCmd(CC3000_WIFI_CS_GPIO_CLK | CC3000_WIFI_EN_GPIO_CLK, ENABLE);

	/* Configure CC3000_WIFI pins: CS */
	GPIO_InitStructure.GPIO_Pin = CC3000_WIFI_CS_PIN;
 8000ad8:	f8ad 5004 	strh.w	r5, [sp, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_Init(CC3000_WIFI_CS_GPIO_PORT, &GPIO_InitStructure);
 8000adc:	f000 fba4 	bl	8001228 <GPIO_Init>

	/* Deselect CC3000 */
	CC3000_CS_HIGH();
 8000ae0:	4620      	mov	r0, r4
 8000ae2:	4629      	mov	r1, r5
 8000ae4:	f000 fbf6 	bl	80012d4 <GPIO_SetBits>

	/* Configure CC3000_WIFI pins: Enable */
	GPIO_InitStructure.GPIO_Pin = CC3000_WIFI_EN_PIN;
 8000ae8:	f44f 7180 	mov.w	r1, #256	; 0x100
 8000aec:	f8ad 1004 	strh.w	r1, [sp, #4]
	GPIO_Init(CC3000_WIFI_EN_GPIO_PORT, &GPIO_InitStructure);
 8000af0:	4620      	mov	r0, r4
 8000af2:	a901      	add	r1, sp, #4
 8000af4:	f000 fb98 	bl	8001228 <GPIO_Init>

	/* Disable CC3000 */
	CC3000_Write_Enable_Pin(WLAN_DISABLE);
 8000af8:	2000      	movs	r0, #0
 8000afa:	f7ff ffcf 	bl	8000a9c <CC3000_Write_Enable_Pin>
}
 8000afe:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 8000b00:	40010c00 	.word	0x40010c00

08000b04 <WLAN_Async_Callback>:
	return (0);
}

/* WLAN Application related callbacks passed to wlan_init */
void WLAN_Async_Callback(long lEventType, char *data, unsigned char length)
{
 8000b04:	4770      	bx	lr

08000b06 <WLAN_Firmware_Patch>:
	//Do Nothing
}

char *WLAN_Firmware_Patch(unsigned long *length)
{
	*length = 0;
 8000b06:	2300      	movs	r3, #0
 8000b08:	6003      	str	r3, [r0, #0]
	return NULL;
}
 8000b0a:	4618      	mov	r0, r3
 8000b0c:	4770      	bx	lr

08000b0e <WLAN_Driver_Patch>:

char *WLAN_Driver_Patch(unsigned long *length)
{
	*length = 0;
 8000b0e:	2300      	movs	r3, #0
 8000b10:	6003      	str	r3, [r0, #0]
	return NULL;
}
 8000b12:	4618      	mov	r0, r3
 8000b14:	4770      	bx	lr

08000b16 <WLAN_BootLoader_Patch>:

char *WLAN_BootLoader_Patch(unsigned long *length)
{
	*length = 0;
 8000b16:	2300      	movs	r3, #0
 8000b18:	6003      	str	r3, [r0, #0]
	return NULL;
}
 8000b1a:	4618      	mov	r0, r3
 8000b1c:	4770      	bx	lr
	...

08000b20 <Delay>:
* Output         : None
* Return         : None
*******************************************************************************/
void Delay(uint32_t nTime)
{
    TimingDelay = nTime;
 8000b20:	4b02      	ldr	r3, [pc, #8]	; (8000b2c <Delay+0xc>)
 8000b22:	6018      	str	r0, [r3, #0]

    // /* Enable the SysTick Counter */
    // SysTick->CTRL |= SysTick_CTRL_ENABLE;

    while(TimingDelay != 0);
 8000b24:	681a      	ldr	r2, [r3, #0]
 8000b26:	2a00      	cmp	r2, #0
 8000b28:	d1fc      	bne.n	8000b24 <Delay+0x4>
    // /* Disable the SysTick Counter */
    // SysTick->CTRL &= ~SysTick_CTRL_ENABLE;

    // /* Clear the SysTick Counter */
    // SysTick->VAL = (uint32_t)0x00;
}
 8000b2a:	4770      	bx	lr
 8000b2c:	20000074 	.word	0x20000074

08000b30 <Timing_Decrement>:
* Output         : Timing
* Return         : None
*******************************************************************************/
void Timing_Decrement(void)
{
    if (TimingDelay != 0x00)
 8000b30:	4b0e      	ldr	r3, [pc, #56]	; (8000b6c <Timing_Decrement+0x3c>)
* Input          : None
* Output         : Timing
* Return         : None
*******************************************************************************/
void Timing_Decrement(void)
{
 8000b32:	b510      	push	{r4, lr}
    if (TimingDelay != 0x00)
 8000b34:	681a      	ldr	r2, [r3, #0]
 8000b36:	b112      	cbz	r2, 8000b3e <Timing_Decrement+0xe>
    {
        TimingDelay--;
 8000b38:	6818      	ldr	r0, [r3, #0]
 8000b3a:	1e41      	subs	r1, r0, #1
 8000b3c:	6019      	str	r1, [r3, #0]
    }

    if (TimingBUTTON != 0x00)
 8000b3e:	685a      	ldr	r2, [r3, #4]
 8000b40:	4c0a      	ldr	r4, [pc, #40]	; (8000b6c <Timing_Decrement+0x3c>)
 8000b42:	b112      	cbz	r2, 8000b4a <Timing_Decrement+0x1a>
    {
    	TimingBUTTON--;
 8000b44:	6860      	ldr	r0, [r4, #4]
 8000b46:	1e41      	subs	r1, r0, #1
 8000b48:	6061      	str	r1, [r4, #4]
    }

    if (TimingLED != 0x00)
 8000b4a:	689b      	ldr	r3, [r3, #8]
 8000b4c:	4c07      	ldr	r4, [pc, #28]	; (8000b6c <Timing_Decrement+0x3c>)
 8000b4e:	b113      	cbz	r3, 8000b56 <Timing_Decrement+0x26>
    {
        TimingLED--;
 8000b50:	68a1      	ldr	r1, [r4, #8]
 8000b52:	1e48      	subs	r0, r1, #1
 8000b54:	e008      	b.n	8000b68 <Timing_Decrement+0x38>
    }
    else if(!CC3000_PATCH_APPLIED)
 8000b56:	4a06      	ldr	r2, [pc, #24]	; (8000b70 <Timing_Decrement+0x40>)
 8000b58:	7810      	ldrb	r0, [r2, #0]
 8000b5a:	b930      	cbnz	r0, 8000b6a <Timing_Decrement+0x3a>
    {
    	LED_Toggle(LED1);
 8000b5c:	f7ff fd64 	bl	8000628 <LED_Toggle>
    	LED_Toggle(LED2);
 8000b60:	2001      	movs	r0, #1
 8000b62:	f7ff fd61 	bl	8000628 <LED_Toggle>
    	TimingLED = 200;	//200ms
 8000b66:	20c8      	movs	r0, #200	; 0xc8
 8000b68:	60a0      	str	r0, [r4, #8]
 8000b6a:	bd10      	pop	{r4, pc}
 8000b6c:	20000074 	.word	0x20000074
 8000b70:	2000001c 	.word	0x2000001c

08000b74 <WLAN_Init_Driver>:
//!  @brief  The function initializes a CC3000 device and triggers it to start
//           operation
//
//*****************************************************************************
int WLAN_Init_Driver(unsigned short cRequestPatch)
{
 8000b74:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8000b76:	4604      	mov	r4, r0
	LED_Off(LED1);
 8000b78:	2000      	movs	r0, #0
 8000b7a:	f7ff fd47 	bl	800060c <LED_Off>
	LED_Off(LED2);
 8000b7e:	2001      	movs	r0, #1
 8000b80:	f7ff fd44 	bl	800060c <LED_Off>

	/* Initialize CC3000's CS, EN and INT pins to their default states */
	CC3000_WIFI_Init();
 8000b84:	f7ff ff98 	bl	8000ab8 <CC3000_WIFI_Init>

	/* Configure & initialize CC3000 SPI_DMA Interface */
	CC3000_SPI_DMA_Init();
 8000b88:	f7ff fee0 	bl	800094c <CC3000_SPI_DMA_Init>

	/* WLAN On API Implementation */
	wlan_init(WLAN_Async_Callback, WLAN_Firmware_Patch, WLAN_Driver_Patch, WLAN_BootLoader_Patch,
 8000b8c:	4b0f      	ldr	r3, [pc, #60]	; (8000bcc <WLAN_Init_Driver+0x58>)
 8000b8e:	4810      	ldr	r0, [pc, #64]	; (8000bd0 <WLAN_Init_Driver+0x5c>)
 8000b90:	4910      	ldr	r1, [pc, #64]	; (8000bd4 <WLAN_Init_Driver+0x60>)
 8000b92:	4a11      	ldr	r2, [pc, #68]	; (8000bd8 <WLAN_Init_Driver+0x64>)
 8000b94:	9300      	str	r3, [sp, #0]
 8000b96:	9001      	str	r0, [sp, #4]
 8000b98:	4b10      	ldr	r3, [pc, #64]	; (8000bdc <WLAN_Init_Driver+0x68>)
 8000b9a:	9102      	str	r1, [sp, #8]
 8000b9c:	9203      	str	r2, [sp, #12]
 8000b9e:	4910      	ldr	r1, [pc, #64]	; (8000be0 <WLAN_Init_Driver+0x6c>)
 8000ba0:	4a10      	ldr	r2, [pc, #64]	; (8000be4 <WLAN_Init_Driver+0x70>)
 8000ba2:	4811      	ldr	r0, [pc, #68]	; (8000be8 <WLAN_Init_Driver+0x74>)
 8000ba4:	f001 f912 	bl	8001dcc <wlan_init>
				CC3000_Read_Interrupt_Pin, CC3000_Interrupt_Enable, CC3000_Interrupt_Disable, CC3000_Write_Enable_Pin);

	Delay(1000);
 8000ba8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8000bac:	f7ff ffb8 	bl	8000b20 <Delay>

	/* Trigger a WLAN device */
	wlan_start(cRequestPatch);
 8000bb0:	4620      	mov	r0, r4
 8000bb2:	f001 f91f 	bl	8001df4 <wlan_start>
	wlan_smart_config_set_prefix(aucCC3000_prefix);
 8000bb6:	480d      	ldr	r0, [pc, #52]	; (8000bec <WLAN_Init_Driver+0x78>)
 8000bb8:	f001 f9ae 	bl	8001f18 <wlan_smart_config_set_prefix>

	/* Mask out all non-required events from CC3000 */
	wlan_set_event_mask(HCI_EVNT_WLAN_KEEPALIVE | HCI_EVNT_WLAN_UNSOL_INIT | HCI_EVNT_WLAN_ASYNC_PING_REPORT);
 8000bbc:	f248 2044 	movw	r0, #33348	; 0x8244
 8000bc0:	f001 f978 	bl	8001eb4 <wlan_set_event_mask>

	return (0);
}
 8000bc4:	2000      	movs	r0, #0
 8000bc6:	b004      	add	sp, #16
 8000bc8:	bd10      	pop	{r4, pc}
 8000bca:	bf00      	nop
 8000bcc:	080009f5 	.word	0x080009f5
 8000bd0:	08000a09 	.word	0x08000a09
 8000bd4:	08000a75 	.word	0x08000a75
 8000bd8:	08000a9d 	.word	0x08000a9d
 8000bdc:	08000b17 	.word	0x08000b17
 8000be0:	08000b07 	.word	0x08000b07
 8000be4:	08000b0f 	.word	0x08000b0f
 8000be8:	08000b05 	.word	0x08000b05
 8000bec:	2000001d 	.word	0x2000001d

08000bf0 <fat_write_content>:
//! @brief  parse the FAT table from eeprom
//
//*****************************************************************************
unsigned char fat_write_content(unsigned short const *file_address,
								unsigned short const *file_length)
{
 8000bf0:	b570      	push	{r4, r5, r6, lr}
	unsigned char   ucStatus;
	unsigned char   fatTable[48];
	unsigned char*  fatTablePtr = fatTable;

	// first, write the magic number
	ucStatus = nvmem_write(16, 2, 0, "LS");
 8000bf2:	2200      	movs	r2, #0
//! @brief  parse the FAT table from eeprom
//
//*****************************************************************************
unsigned char fat_write_content(unsigned short const *file_address,
								unsigned short const *file_length)
{
 8000bf4:	b08c      	sub	sp, #48	; 0x30
	unsigned char   ucStatus;
	unsigned char   fatTable[48];
	unsigned char*  fatTablePtr = fatTable;

	// first, write the magic number
	ucStatus = nvmem_write(16, 2, 0, "LS");
 8000bf6:	4b17      	ldr	r3, [pc, #92]	; (8000c54 <fat_write_content+0x64>)
//! @brief  parse the FAT table from eeprom
//
//*****************************************************************************
unsigned char fat_write_content(unsigned short const *file_address,
								unsigned short const *file_length)
{
 8000bf8:	4606      	mov	r6, r0
 8000bfa:	460d      	mov	r5, r1
	unsigned char   ucStatus;
	unsigned char   fatTable[48];
	unsigned char*  fatTablePtr = fatTable;

	// first, write the magic number
	ucStatus = nvmem_write(16, 2, 0, "LS");
 8000bfc:	2010      	movs	r0, #16
 8000bfe:	2102      	movs	r1, #2
 8000c00:	f001 f876 	bl	8001cf0 <nvmem_write>
//! @return on succes 0, error otherwise
//!
//! @brief  parse the FAT table from eeprom
//
//*****************************************************************************
unsigned char fat_write_content(unsigned short const *file_address,
 8000c04:	ab01      	add	r3, sp, #4
	unsigned char   ucStatus;
	unsigned char   fatTable[48];
	unsigned char*  fatTablePtr = fatTable;

	// first, write the magic number
	ucStatus = nvmem_write(16, 2, 0, "LS");
 8000c06:	2200      	movs	r2, #0

	for (; index <= NVMEM_RM_FILEID; index++)
	{
		// write address low char and mark as allocated
		*fatTablePtr++ = (unsigned char)(file_address[index] & 0xff) | BIT0;
 8000c08:	5ab4      	ldrh	r4, [r6, r2]

		// write address high char
		*fatTablePtr++ = (unsigned char)((file_address[index]>>8) & 0xff);
 8000c0a:	0a20      	lsrs	r0, r4, #8
	ucStatus = nvmem_write(16, 2, 0, "LS");

	for (; index <= NVMEM_RM_FILEID; index++)
	{
		// write address low char and mark as allocated
		*fatTablePtr++ = (unsigned char)(file_address[index] & 0xff) | BIT0;
 8000c0c:	f044 0101 	orr.w	r1, r4, #1

		// write address high char
		*fatTablePtr++ = (unsigned char)((file_address[index]>>8) & 0xff);

		// write length low char
		*fatTablePtr++ = (unsigned char)(file_length[index] & 0xff);
 8000c10:	5aac      	ldrh	r4, [r5, r2]
 8000c12:	3202      	adds	r2, #2
 8000c14:	f803 4c02 	strb.w	r4, [r3, #-2]

		// write length high char
		*fatTablePtr++ = (unsigned char)((file_length[index]>>8) & 0xff);
 8000c18:	0a24      	lsrs	r4, r4, #8
	ucStatus = nvmem_write(16, 2, 0, "LS");

	for (; index <= NVMEM_RM_FILEID; index++)
	{
		// write address low char and mark as allocated
		*fatTablePtr++ = (unsigned char)(file_address[index] & 0xff) | BIT0;
 8000c1a:	f803 1c04 	strb.w	r1, [r3, #-4]

		// write address high char
		*fatTablePtr++ = (unsigned char)((file_address[index]>>8) & 0xff);
 8000c1e:	f803 0c03 	strb.w	r0, [r3, #-3]

		// write length low char
		*fatTablePtr++ = (unsigned char)(file_length[index] & 0xff);

		// write length high char
		*fatTablePtr++ = (unsigned char)((file_length[index]>>8) & 0xff);
 8000c22:	f803 4c01 	strb.w	r4, [r3, #-1]
 8000c26:	3304      	adds	r3, #4
	unsigned char*  fatTablePtr = fatTable;

	// first, write the magic number
	ucStatus = nvmem_write(16, 2, 0, "LS");

	for (; index <= NVMEM_RM_FILEID; index++)
 8000c28:	2a18      	cmp	r2, #24
 8000c2a:	d1ed      	bne.n	8000c08 <fat_write_content+0x18>
		// write length high char
		*fatTablePtr++ = (unsigned char)((file_length[index]>>8) & 0xff);
	}

	// second, write the FAT
	ucStatus = nvmem_write(16, 48, 4, fatTable);
 8000c2c:	466b      	mov	r3, sp
 8000c2e:	2130      	movs	r1, #48	; 0x30
 8000c30:	2204      	movs	r2, #4
 8000c32:	2010      	movs	r0, #16
 8000c34:	f001 f85c 	bl	8001cf0 <nvmem_write>

	// third, we want to erase any user files
	memset(fatTable, 0, sizeof(fatTable));
 8000c38:	2100      	movs	r1, #0
 8000c3a:	2230      	movs	r2, #48	; 0x30
 8000c3c:	4668      	mov	r0, sp
 8000c3e:	f001 fa37 	bl	80020b0 <memset>
	ucStatus = nvmem_write(16, 16, 52, fatTable);
 8000c42:	2010      	movs	r0, #16
 8000c44:	4601      	mov	r1, r0
 8000c46:	2234      	movs	r2, #52	; 0x34
 8000c48:	466b      	mov	r3, sp
 8000c4a:	f001 f851 	bl	8001cf0 <nvmem_write>

	return ucStatus;
}
 8000c4e:	b2c0      	uxtb	r0, r0
 8000c50:	b00c      	add	sp, #48	; 0x30
 8000c52:	bd70      	pop	{r4, r5, r6, pc}
 8000c54:	08005344 	.word	0x08005344

08000c58 <WLAN_Apply_Patch>:

void WLAN_Apply_Patch(void)
{
 8000c58:	b570      	push	{r4, r5, r6, lr}
	unsigned char *pRMParams;

	CC3000_PATCH_APPLIED = 0;
 8000c5a:	4c42      	ldr	r4, [pc, #264]	; (8000d64 <WLAN_Apply_Patch+0x10c>)
 8000c5c:	2300      	movs	r3, #0

	// Init WLAN and request to load with no patches.
	// this is in order to overwrite restrictions to write to specific places in EEPROM
	WLAN_Init_Driver(1);
 8000c5e:	2001      	movs	r0, #1

void WLAN_Apply_Patch(void)
{
	unsigned char *pRMParams;

	CC3000_PATCH_APPLIED = 0;
 8000c60:	7023      	strb	r3, [r4, #0]

	// Init WLAN and request to load with no patches.
	// this is in order to overwrite restrictions to write to specific places in EEPROM
	WLAN_Init_Driver(1);
 8000c62:	f7ff ff87 	bl	8000b74 <WLAN_Init_Driver>

	// read MAC address
	mac_status = nvmem_get_mac_address(cMacFromEeprom);
 8000c66:	4840      	ldr	r0, [pc, #256]	; (8000d68 <WLAN_Apply_Patch+0x110>)
 8000c68:	f001 f87d 	bl	8001d66 <nvmem_get_mac_address>
 8000c6c:	7120      	strb	r0, [r4, #4]

	return_status = 1;
 8000c6e:	2001      	movs	r0, #1
 8000c70:	7160      	strb	r0, [r4, #5]

	while ((return_status) && (counter < 3))
 8000c72:	4d3c      	ldr	r5, [pc, #240]	; (8000d64 <WLAN_Apply_Patch+0x10c>)
 8000c74:	4e3d      	ldr	r6, [pc, #244]	; (8000d6c <WLAN_Apply_Patch+0x114>)
 8000c76:	7969      	ldrb	r1, [r5, #5]
 8000c78:	b169      	cbz	r1, 8000c96 <WLAN_Apply_Patch+0x3e>
 8000c7a:	7b32      	ldrb	r2, [r6, #12]
 8000c7c:	2a02      	cmp	r2, #2
 8000c7e:	d80a      	bhi.n	8000c96 <WLAN_Apply_Patch+0x3e>
	{
		// read RM parameters
		return_status = nvmem_read(NVMEM_RM_FILEID, 128, 0, cRMParamsFromEeprom);
 8000c80:	200b      	movs	r0, #11
 8000c82:	2180      	movs	r1, #128	; 0x80
 8000c84:	2200      	movs	r2, #0
 8000c86:	4b3a      	ldr	r3, [pc, #232]	; (8000d70 <WLAN_Apply_Patch+0x118>)
 8000c88:	f001 f804 	bl	8001c94 <nvmem_read>
 8000c8c:	7168      	strb	r0, [r5, #5]

		counter++;
 8000c8e:	7b30      	ldrb	r0, [r6, #12]
 8000c90:	1c44      	adds	r4, r0, #1
 8000c92:	7334      	strb	r4, [r6, #12]
 8000c94:	e7ed      	b.n	8000c72 <WLAN_Apply_Patch+0x1a>
	}

	// if RM file is not valid, load the default one
	if (counter == 3)
 8000c96:	7b34      	ldrb	r4, [r6, #12]
	{
		pRMParams = (unsigned char *)cRMdefaultParams;
 8000c98:	4b36      	ldr	r3, [pc, #216]	; (8000d74 <WLAN_Apply_Patch+0x11c>)
 8000c9a:	4835      	ldr	r0, [pc, #212]	; (8000d70 <WLAN_Apply_Patch+0x118>)
	else
	{
		pRMParams = cRMParamsFromEeprom;
	}

	return_status = 1;
 8000c9c:	4e31      	ldr	r6, [pc, #196]	; (8000d64 <WLAN_Apply_Patch+0x10c>)
 8000c9e:	2101      	movs	r1, #1
	}

	// if RM file is not valid, load the default one
	if (counter == 3)
	{
		pRMParams = (unsigned char *)cRMdefaultParams;
 8000ca0:	2c03      	cmp	r4, #3
 8000ca2:	bf14      	ite	ne
 8000ca4:	4605      	movne	r5, r0
 8000ca6:	461d      	moveq	r5, r3
	else
	{
		pRMParams = cRMParamsFromEeprom;
	}

	return_status = 1;
 8000ca8:	7171      	strb	r1, [r6, #5]

	while (return_status)
 8000caa:	4c2e      	ldr	r4, [pc, #184]	; (8000d64 <WLAN_Apply_Patch+0x10c>)
 8000cac:	7962      	ldrb	r2, [r4, #5]
 8000cae:	b132      	cbz	r2, 8000cbe <WLAN_Apply_Patch+0x66>
	{
		// write new FAT
		return_status = fat_write_content(aFATEntries[0], aFATEntries[1]);
 8000cb0:	1da0      	adds	r0, r4, #6
 8000cb2:	f104 011e 	add.w	r1, r4, #30
 8000cb6:	f7ff ff9b 	bl	8000bf0 <fat_write_content>
 8000cba:	7160      	strb	r0, [r4, #5]
 8000cbc:	e7f5      	b.n	8000caa <WLAN_Apply_Patch+0x52>
	}

	wlan_stop();
 8000cbe:	f001 f8e3 	bl	8001e88 <wlan_stop>
	WLAN_Init_Driver(1);
 8000cc2:	2001      	movs	r0, #1
 8000cc4:	f7ff ff56 	bl	8000b74 <WLAN_Init_Driver>

	return_status = 1;
 8000cc8:	2301      	movs	r3, #1
 8000cca:	7163      	strb	r3, [r4, #5]

	while (return_status)
 8000ccc:	4e25      	ldr	r6, [pc, #148]	; (8000d64 <WLAN_Apply_Patch+0x10c>)
 8000cce:	7970      	ldrb	r0, [r6, #5]
 8000cd0:	b138      	cbz	r0, 8000ce2 <WLAN_Apply_Patch+0x8a>
	{
		// write RM parameters
		return_status = nvmem_write(NVMEM_RM_FILEID, 128, 0, pRMParams);
 8000cd2:	200b      	movs	r0, #11
 8000cd4:	2180      	movs	r1, #128	; 0x80
 8000cd6:	2200      	movs	r2, #0
 8000cd8:	462b      	mov	r3, r5
 8000cda:	f001 f809 	bl	8001cf0 <nvmem_write>
 8000cde:	7170      	strb	r0, [r6, #5]
 8000ce0:	e7f4      	b.n	8000ccc <WLAN_Apply_Patch+0x74>
	}

	return_status = 1;

	// write back the MAC address, only if exist
	if (mac_status == 0)
 8000ce2:	f996 1004 	ldrsb.w	r1, [r6, #4]
	{
		// write RM parameters
		return_status = nvmem_write(NVMEM_RM_FILEID, 128, 0, pRMParams);
	}

	return_status = 1;
 8000ce6:	2501      	movs	r5, #1
 8000ce8:	7175      	strb	r5, [r6, #5]

	// write back the MAC address, only if exist
	if (mac_status == 0)
 8000cea:	b119      	cbz	r1, 8000cf4 <WLAN_Apply_Patch+0x9c>
		{
			return_status = nvmem_set_mac_address(cMacFromEeprom);
		}
	}

	ucStatus_Dr = 1;
 8000cec:	4922      	ldr	r1, [pc, #136]	; (8000d78 <WLAN_Apply_Patch+0x120>)
 8000cee:	2501      	movs	r5, #1
 8000cf0:	700d      	strb	r5, [r1, #0]

	while (ucStatus_Dr)
 8000cf2:	e00d      	b.n	8000d10 <WLAN_Apply_Patch+0xb8>

	// write back the MAC address, only if exist
	if (mac_status == 0)
	{
		// zero out MCAST bit if set
		cMacFromEeprom[0] &= 0xfe;
 8000cf4:	4c1c      	ldr	r4, [pc, #112]	; (8000d68 <WLAN_Apply_Patch+0x110>)
 8000cf6:	7822      	ldrb	r2, [r4, #0]
 8000cf8:	f022 0301 	bic.w	r3, r2, #1
 8000cfc:	7023      	strb	r3, [r4, #0]
		while (return_status)
 8000cfe:	4e19      	ldr	r6, [pc, #100]	; (8000d64 <WLAN_Apply_Patch+0x10c>)
 8000d00:	7970      	ldrb	r0, [r6, #5]
 8000d02:	2800      	cmp	r0, #0
 8000d04:	d0f2      	beq.n	8000cec <WLAN_Apply_Patch+0x94>
		{
			return_status = nvmem_set_mac_address(cMacFromEeprom);
 8000d06:	4818      	ldr	r0, [pc, #96]	; (8000d68 <WLAN_Apply_Patch+0x110>)
 8000d08:	f001 f824 	bl	8001d54 <nvmem_set_mac_address>
 8000d0c:	7170      	strb	r0, [r6, #5]
 8000d0e:	e7f6      	b.n	8000cfe <WLAN_Apply_Patch+0xa6>
		}
	}

	ucStatus_Dr = 1;

	while (ucStatus_Dr)
 8000d10:	4c19      	ldr	r4, [pc, #100]	; (8000d78 <WLAN_Apply_Patch+0x120>)
 8000d12:	7822      	ldrb	r2, [r4, #0]
 8000d14:	b13a      	cbz	r2, 8000d26 <WLAN_Apply_Patch+0xce>
	{
		// Writing driver patch to EEPROM
		// Note that the array itself is changing between the different Service Packs
		ucStatus_Dr = nvmem_write_patch(NVMEM_WLAN_DRIVER_SP_FILEID, drv_length, wlan_drv_patch);
 8000d16:	4913      	ldr	r1, [pc, #76]	; (8000d64 <WLAN_Apply_Patch+0x10c>)
 8000d18:	2004      	movs	r0, #4
 8000d1a:	8ec9      	ldrh	r1, [r1, #54]	; 0x36
 8000d1c:	4a17      	ldr	r2, [pc, #92]	; (8000d7c <WLAN_Apply_Patch+0x124>)
 8000d1e:	f001 f82b 	bl	8001d78 <nvmem_write_patch>
 8000d22:	7020      	strb	r0, [r4, #0]
 8000d24:	e7f4      	b.n	8000d10 <WLAN_Apply_Patch+0xb8>
	}

	ucStatus_FW = 1;
 8000d26:	4b16      	ldr	r3, [pc, #88]	; (8000d80 <WLAN_Apply_Patch+0x128>)
 8000d28:	2601      	movs	r6, #1
 8000d2a:	701e      	strb	r6, [r3, #0]

	while (ucStatus_FW)
 8000d2c:	4d14      	ldr	r5, [pc, #80]	; (8000d80 <WLAN_Apply_Patch+0x128>)
 8000d2e:	4e0d      	ldr	r6, [pc, #52]	; (8000d64 <WLAN_Apply_Patch+0x10c>)
 8000d30:	782c      	ldrb	r4, [r5, #0]
 8000d32:	b134      	cbz	r4, 8000d42 <WLAN_Apply_Patch+0xea>
	{
		// Writing FW patch to EEPROM
		// Note that the array itself is changing between the different Service Packs
		ucStatus_FW = nvmem_write_patch(NVMEM_WLAN_FW_SP_FILEID, fw_length, fw_patch);
 8000d34:	2005      	movs	r0, #5
 8000d36:	8f31      	ldrh	r1, [r6, #56]	; 0x38
 8000d38:	4a12      	ldr	r2, [pc, #72]	; (8000d84 <WLAN_Apply_Patch+0x12c>)
 8000d3a:	f001 f81d 	bl	8001d78 <nvmem_write_patch>
 8000d3e:	7028      	strb	r0, [r5, #0]
 8000d40:	e7f4      	b.n	8000d2c <WLAN_Apply_Patch+0xd4>
	}

	// Init WLAN and request to load with patches.
	WLAN_Init_Driver(0);
 8000d42:	4620      	mov	r0, r4
 8000d44:	f7ff ff16 	bl	8000b74 <WLAN_Init_Driver>

	CC3000_PATCH_APPLIED = 1;
 8000d48:	2501      	movs	r5, #1

	Delay(100);
 8000d4a:	2064      	movs	r0, #100	; 0x64
	}

	// Init WLAN and request to load with patches.
	WLAN_Init_Driver(0);

	CC3000_PATCH_APPLIED = 1;
 8000d4c:	7035      	strb	r5, [r6, #0]

	Delay(100);
 8000d4e:	f7ff fee7 	bl	8000b20 <Delay>

	LED_On(LED1);
 8000d52:	4620      	mov	r0, r4
 8000d54:	f7ff fc4c 	bl	80005f0 <LED_On>
	LED_On(LED2);
 8000d58:	4628      	mov	r0, r5
}
 8000d5a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	CC3000_PATCH_APPLIED = 1;

	Delay(100);

	LED_On(LED1);
	LED_On(LED2);
 8000d5e:	f7ff bc47 	b.w	80005f0 <LED_On>
 8000d62:	bf00      	nop
 8000d64:	2000001c 	.word	0x2000001c
 8000d68:	20000932 	.word	0x20000932
 8000d6c:	20000074 	.word	0x20000074
 8000d70:	20000899 	.word	0x20000899
 8000d74:	08002204 	.word	0x08002204
 8000d78:	20000931 	.word	0x20000931
 8000d7c:	08002284 	.word	0x08002284
 8000d80:	20000898 	.word	0x20000898
 8000d84:	0800413c 	.word	0x0800413c

08000d88 <main>:
 * Input          : None.
 * Output         : None.
 * Return         : None.
 *******************************************************************************/
int main(void)
{
 8000d88:	b508      	push	{r3, lr}
	Set_System();
 8000d8a:	f7ff fcf7 	bl	800077c <Set_System>

	/* Main loop */
	while (1)
	{
	    if(BUTTON_GetDebouncedState(BUTTON1) != 0x00)
 8000d8e:	2000      	movs	r0, #0
 8000d90:	f7ff fd4e 	bl	8000830 <BUTTON_GetDebouncedState>
 8000d94:	2800      	cmp	r0, #0
 8000d96:	d0fa      	beq.n	8000d8e <main+0x6>
	    {
	    	WLAN_Apply_Patch();
 8000d98:	f7ff ff5e 	bl	8000c58 <WLAN_Apply_Patch>
 8000d9c:	e7f7      	b.n	8000d8e <main+0x6>

08000d9e <NMI_Handler>:
 * Input          : None
 * Output         : None
 * Return         : None
 *******************************************************************************/
void NMI_Handler(void)
{
 8000d9e:	4770      	bx	lr

08000da0 <HardFault_Handler>:
 * Input          : None
 * Output         : None
 * Return         : None
 *******************************************************************************/
void HardFault_Handler(void)
{
 8000da0:	e7fe      	b.n	8000da0 <HardFault_Handler>

08000da2 <MemManage_Handler>:
 * Input          : None
 * Output         : None
 * Return         : None
 *******************************************************************************/
void MemManage_Handler(void)
{
 8000da2:	e7fe      	b.n	8000da2 <MemManage_Handler>

08000da4 <BusFault_Handler>:
 * Input          : None
 * Output         : None
 * Return         : None
 *******************************************************************************/
void BusFault_Handler(void)
{
 8000da4:	e7fe      	b.n	8000da4 <BusFault_Handler>

08000da6 <UsageFault_Handler>:
 * Input          : None
 * Output         : None
 * Return         : None
 *******************************************************************************/
void UsageFault_Handler(void)
{
 8000da6:	e7fe      	b.n	8000da6 <UsageFault_Handler>

08000da8 <SVC_Handler>:
 * Input          : None
 * Output         : None
 * Return         : None
 *******************************************************************************/
void SVC_Handler(void)
{
 8000da8:	4770      	bx	lr

08000daa <DebugMon_Handler>:
 * Input          : None
 * Output         : None
 * Return         : None
 *******************************************************************************/
void DebugMon_Handler(void)
{
 8000daa:	4770      	bx	lr

08000dac <PendSV_Handler>:
 * Input          : None
 * Output         : None
 * Return         : None
 *******************************************************************************/
void PendSV_Handler(void)
{
 8000dac:	4770      	bx	lr

08000dae <SysTick_Handler>:
 * Output         : None
 * Return         : None
 *******************************************************************************/
void SysTick_Handler(void)
{
	Timing_Decrement();
 8000dae:	f7ff bebf 	b.w	8000b30 <Timing_Decrement>

08000db2 <DMA1_Channel3_IRQHandler>:
 * Output         : None
 * Return         : None
 *******************************************************************************/
void DMA1_Channel3_IRQHandler(void)
{
	SPI_DMA_IntHandler();
 8000db2:	f7ff bb4b 	b.w	800044c <SPI_DMA_IntHandler>

08000db6 <DMA1_Channel5_IRQHandler>:
 * Output         : None
 * Return         : None
 *******************************************************************************/
void DMA1_Channel5_IRQHandler(void)
{
	SPI_DMA_IntHandler();
 8000db6:	f7ff bb49 	b.w	800044c <SPI_DMA_IntHandler>
	...

08000dbc <EXTI0_IRQHandler>:
 * Input          : None
 * Output         : None
 * Return         : None
 *******************************************************************************/
void EXTI0_IRQHandler(void)
{
 8000dbc:	b508      	push	{r3, lr}
	if (EXTI_GetITStatus(CC3000_WIFI_INT_EXTI_LINE ) != RESET)
 8000dbe:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8000dc2:	f000 fa21 	bl	8001208 <EXTI_GetITStatus>
 8000dc6:	b128      	cbz	r0, 8000dd4 <EXTI0_IRQHandler+0x18>
	{
		/* Clear the EXTI line pending flag */
		EXTI_ClearFlag(CC3000_WIFI_INT_EXTI_LINE );
 8000dc8:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8000dcc:	f000 fa16 	bl	80011fc <EXTI_ClearFlag>

		SPI_EXTI_IntHandler();
 8000dd0:	f7ff fbb4 	bl	800053c <SPI_EXTI_IntHandler>
	}

	if (EXTI_GetITStatus(BUTTON1_EXTI_LINE ) != RESET)
 8000dd4:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8000dd8:	f000 fa16 	bl	8001208 <EXTI_GetITStatus>
 8000ddc:	b168      	cbz	r0, 8000dfa <EXTI0_IRQHandler+0x3e>
	{
		/* Clear the EXTI line pending flag */
		EXTI_ClearFlag(BUTTON1_EXTI_LINE );
 8000dde:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8000de2:	f000 fa0b 	bl	80011fc <EXTI_ClearFlag>

		/* Disable BUTTON1 Interrupts */
		BUTTON_EXTI_Config(BUTTON1, DISABLE);
 8000de6:	2000      	movs	r0, #0
 8000de8:	4601      	mov	r1, r0
 8000dea:	f7ff fc2d 	bl	8000648 <BUTTON_EXTI_Config>

	    /* DEBOUNCE_TIMER Enable Counter */
	    TIM_Cmd(DEBOUNCE_TIMER, ENABLE);
 8000dee:	4803      	ldr	r0, [pc, #12]	; (8000dfc <EXTI0_IRQHandler+0x40>)
 8000df0:	2101      	movs	r1, #1
	}
}
 8000df2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

		/* Disable BUTTON1 Interrupts */
		BUTTON_EXTI_Config(BUTTON1, DISABLE);

	    /* DEBOUNCE_TIMER Enable Counter */
	    TIM_Cmd(DEBOUNCE_TIMER, ENABLE);
 8000df6:	f000 bb42 	b.w	800147e <TIM_Cmd>
 8000dfa:	bd08      	pop	{r3, pc}
 8000dfc:	40012c00 	.word	0x40012c00

08000e00 <EXTI15_10_IRQHandler>:
 * Input          : None
 * Output         : None
 * Return         : None
 *******************************************************************************/
void EXTI15_10_IRQHandler(void)
{
 8000e00:	b508      	push	{r3, lr}
	if (EXTI_GetITStatus(CC3000_WIFI_INT_EXTI_LINE ) != RESET)
 8000e02:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8000e06:	f000 f9ff 	bl	8001208 <EXTI_GetITStatus>
 8000e0a:	b128      	cbz	r0, 8000e18 <EXTI15_10_IRQHandler+0x18>
	{
		/* Clear the EXTI line pending flag */
		EXTI_ClearFlag(CC3000_WIFI_INT_EXTI_LINE );
 8000e0c:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8000e10:	f000 f9f4 	bl	80011fc <EXTI_ClearFlag>

		SPI_EXTI_IntHandler();
 8000e14:	f7ff fb92 	bl	800053c <SPI_EXTI_IntHandler>
	}

	if (EXTI_GetITStatus(BUTTON1_EXTI_LINE ) != RESET)
 8000e18:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8000e1c:	f000 f9f4 	bl	8001208 <EXTI_GetITStatus>
 8000e20:	b168      	cbz	r0, 8000e3e <EXTI15_10_IRQHandler+0x3e>
	{
		/* Clear the EXTI line pending flag */
		EXTI_ClearFlag(BUTTON1_EXTI_LINE );
 8000e22:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8000e26:	f000 f9e9 	bl	80011fc <EXTI_ClearFlag>

		/* Disable BUTTON1 Interrupts */
		BUTTON_EXTI_Config(BUTTON1, DISABLE);
 8000e2a:	2000      	movs	r0, #0
 8000e2c:	4601      	mov	r1, r0
 8000e2e:	f7ff fc0b 	bl	8000648 <BUTTON_EXTI_Config>

	    /* DEBOUNCE_TIMER Enable Counter */
	    TIM_Cmd(DEBOUNCE_TIMER, ENABLE);
 8000e32:	4803      	ldr	r0, [pc, #12]	; (8000e40 <EXTI15_10_IRQHandler+0x40>)
 8000e34:	2101      	movs	r1, #1
	}
}
 8000e36:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

		/* Disable BUTTON1 Interrupts */
		BUTTON_EXTI_Config(BUTTON1, DISABLE);

	    /* DEBOUNCE_TIMER Enable Counter */
	    TIM_Cmd(DEBOUNCE_TIMER, ENABLE);
 8000e3a:	f000 bb20 	b.w	800147e <TIM_Cmd>
 8000e3e:	bd08      	pop	{r3, pc}
 8000e40:	40012c00 	.word	0x40012c00

08000e44 <TIM1_UP_IRQHandler>:
 * Input          : None
 * Output         : None
 * Return         : None
 *******************************************************************************/
void TIM1_UP_IRQHandler(void)
{
 8000e44:	b508      	push	{r3, lr}
	if (TIM_GetITStatus(DEBOUNCE_TIMER, DEBOUNCE_TIMER_FLAG) != RESET)
 8000e46:	480c      	ldr	r0, [pc, #48]	; (8000e78 <TIM1_UP_IRQHandler+0x34>)
 8000e48:	2101      	movs	r1, #1
 8000e4a:	f000 fb38 	bl	80014be <TIM_GetITStatus>
 8000e4e:	b190      	cbz	r0, 8000e76 <TIM1_UP_IRQHandler+0x32>
	{
		TIM_ClearITPendingBit(DEBOUNCE_TIMER, DEBOUNCE_TIMER_FLAG);
 8000e50:	4809      	ldr	r0, [pc, #36]	; (8000e78 <TIM1_UP_IRQHandler+0x34>)
 8000e52:	2101      	movs	r1, #1
 8000e54:	f000 fb3e 	bl	80014d4 <TIM_ClearITPendingBit>

		if (BUTTON_GetState(BUTTON1) == BUTTON1_PRESSED)
 8000e58:	2000      	movs	r0, #0
 8000e5a:	f7ff fcdb 	bl	8000814 <BUTTON_GetState>
 8000e5e:	4b07      	ldr	r3, [pc, #28]	; (8000e7c <TIM1_UP_IRQHandler+0x38>)
 8000e60:	b908      	cbnz	r0, 8000e66 <TIM1_UP_IRQHandler+0x22>
			BUTTON_DEBOUNCED[BUTTON1] = 0x01;
 8000e62:	2201      	movs	r2, #1
 8000e64:	e000      	b.n	8000e68 <TIM1_UP_IRQHandler+0x24>
		else
			BUTTON_DEBOUNCED[BUTTON1] = 0x00;
 8000e66:	2200      	movs	r2, #0

		/* Enable BUTTON1 Interrupts */
		BUTTON_EXTI_Config(BUTTON1, ENABLE);
 8000e68:	2000      	movs	r0, #0
 8000e6a:	2101      	movs	r1, #1
		TIM_ClearITPendingBit(DEBOUNCE_TIMER, DEBOUNCE_TIMER_FLAG);

		if (BUTTON_GetState(BUTTON1) == BUTTON1_PRESSED)
			BUTTON_DEBOUNCED[BUTTON1] = 0x01;
		else
			BUTTON_DEBOUNCED[BUTTON1] = 0x00;
 8000e6c:	701a      	strb	r2, [r3, #0]

		/* Enable BUTTON1 Interrupts */
		BUTTON_EXTI_Config(BUTTON1, ENABLE);
	}
}
 8000e6e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
			BUTTON_DEBOUNCED[BUTTON1] = 0x01;
		else
			BUTTON_DEBOUNCED[BUTTON1] = 0x00;

		/* Enable BUTTON1 Interrupts */
		BUTTON_EXTI_Config(BUTTON1, ENABLE);
 8000e72:	f7ff bbe9 	b.w	8000648 <BUTTON_EXTI_Config>
 8000e76:	bd08      	pop	{r3, pc}
 8000e78:	40012c00 	.word	0x40012c00
 8000e7c:	20000070 	.word	0x20000070

08000e80 <SystemInit>:
  */
void SystemInit (void)
{
  /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000e80:	4b3a      	ldr	r3, [pc, #232]	; (8000f6c <SystemInit+0xec>)
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 8000e82:	b082      	sub	sp, #8
  /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000e84:	681a      	ldr	r2, [r3, #0]
 8000e86:	f042 0001 	orr.w	r0, r2, #1
 8000e8a:	6018      	str	r0, [r3, #0]

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */

  RCC->CFGR &= (uint32_t)0xF8FF0000;
 8000e8c:	6859      	ldr	r1, [r3, #4]
 8000e8e:	4a38      	ldr	r2, [pc, #224]	; (8000f70 <SystemInit+0xf0>)
 8000e90:	400a      	ands	r2, r1
 8000e92:	605a      	str	r2, [r3, #4]
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8000e94:	6818      	ldr	r0, [r3, #0]
 8000e96:	f020 7184 	bic.w	r1, r0, #17301504	; 0x1080000
 8000e9a:	f421 3280 	bic.w	r2, r1, #65536	; 0x10000
 8000e9e:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000ea0:	6818      	ldr	r0, [r3, #0]
 8000ea2:	f420 2180 	bic.w	r1, r0, #262144	; 0x40000
 8000ea6:	6019      	str	r1, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
 8000ea8:	685a      	ldr	r2, [r3, #4]

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000;      
#else
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000;
 8000eaa:	f44f 011f 	mov.w	r1, #10420224	; 0x9f0000

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
 8000eae:	f422 00fe 	bic.w	r0, r2, #8323072	; 0x7f0000
  * @param  None
  * @retval None
  */
static void SetSysClockTo72(void)
{
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 8000eb2:	2200      	movs	r2, #0

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
 8000eb4:	6058      	str	r0, [r3, #4]

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000;      
#else
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000;
 8000eb6:	6099      	str	r1, [r3, #8]
  * @param  None
  * @retval None
  */
static void SetSysClockTo72(void)
{
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 8000eb8:	9200      	str	r2, [sp, #0]
 8000eba:	9201      	str	r2, [sp, #4]
  
  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
  /* Enable HSE */    
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 8000ebc:	6818      	ldr	r0, [r3, #0]
 8000ebe:	f440 3180 	orr.w	r1, r0, #65536	; 0x10000
 8000ec2:	6019      	str	r1, [r3, #0]
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 8000ec4:	4b29      	ldr	r3, [pc, #164]	; (8000f6c <SystemInit+0xec>)
 8000ec6:	681a      	ldr	r2, [r3, #0]
 8000ec8:	f402 3000 	and.w	r0, r2, #131072	; 0x20000
 8000ecc:	9001      	str	r0, [sp, #4]
    StartUpCounter++;  
 8000ece:	9900      	ldr	r1, [sp, #0]
 8000ed0:	1c4a      	adds	r2, r1, #1
 8000ed2:	9200      	str	r2, [sp, #0]
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 8000ed4:	9801      	ldr	r0, [sp, #4]
 8000ed6:	b918      	cbnz	r0, 8000ee0 <SystemInit+0x60>
 8000ed8:	9900      	ldr	r1, [sp, #0]
 8000eda:	f5b1 6fa0 	cmp.w	r1, #1280	; 0x500
 8000ede:	d1f1      	bne.n	8000ec4 <SystemInit+0x44>

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 8000ee0:	681b      	ldr	r3, [r3, #0]
 8000ee2:	f413 3200 	ands.w	r2, r3, #131072	; 0x20000
  {
    HSEStatus = (uint32_t)0x01;
 8000ee6:	bf18      	it	ne
 8000ee8:	2201      	movne	r2, #1
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
 8000eea:	9201      	str	r2, [sp, #4]
  }  

  if (HSEStatus == (uint32_t)0x01)
 8000eec:	9801      	ldr	r0, [sp, #4]
 8000eee:	2801      	cmp	r0, #1
 8000ef0:	d005      	beq.n	8000efe <SystemInit+0x7e>
  SetSysClock();

#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
 8000ef2:	4b20      	ldr	r3, [pc, #128]	; (8000f74 <SystemInit+0xf4>)
 8000ef4:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8000ef8:	609a      	str	r2, [r3, #8]
#endif 
}
 8000efa:	b002      	add	sp, #8
 8000efc:	4770      	bx	lr
  }  

  if (HSEStatus == (uint32_t)0x01)
  {
    /* Enable Prefetch Buffer */
    FLASH->ACR |= FLASH_ACR_PRFTBE;
 8000efe:	491e      	ldr	r1, [pc, #120]	; (8000f78 <SystemInit+0xf8>)
 8000f00:	680b      	ldr	r3, [r1, #0]
 8000f02:	f043 0210 	orr.w	r2, r3, #16
 8000f06:	600a      	str	r2, [r1, #0]

    /* Flash 2 wait state */
    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
 8000f08:	6808      	ldr	r0, [r1, #0]
 8000f0a:	f020 0303 	bic.w	r3, r0, #3
 8000f0e:	600b      	str	r3, [r1, #0]
    FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;    
 8000f10:	680a      	ldr	r2, [r1, #0]

 
    /* HCLK = SYSCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
 8000f12:	f5a1 5380 	sub.w	r3, r1, #4096	; 0x1000
    /* Enable Prefetch Buffer */
    FLASH->ACR |= FLASH_ACR_PRFTBE;

    /* Flash 2 wait state */
    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
    FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;    
 8000f16:	f042 0002 	orr.w	r0, r2, #2
 8000f1a:	6008      	str	r0, [r1, #0]

 
    /* HCLK = SYSCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
 8000f1c:	6859      	ldr	r1, [r3, #4]
 8000f1e:	6059      	str	r1, [r3, #4]
      
    /* PCLK2 = HCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
 8000f20:	685a      	ldr	r2, [r3, #4]
 8000f22:	605a      	str	r2, [r3, #4]
    
    /* PCLK1 = HCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
 8000f24:	6858      	ldr	r0, [r3, #4]
 8000f26:	f440 6180 	orr.w	r1, r0, #1024	; 0x400
 8000f2a:	6059      	str	r1, [r3, #4]

    /*  PLL configuration: PLLCLK = HSE * 9 = 72 MHz */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE |
 8000f2c:	685a      	ldr	r2, [r3, #4]
 8000f2e:	f422 107c 	bic.w	r0, r2, #4128768	; 0x3f0000
 8000f32:	6058      	str	r0, [r3, #4]
                                        RCC_CFGR_PLLMULL));
    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);
 8000f34:	6859      	ldr	r1, [r3, #4]
 8000f36:	f441 12e8 	orr.w	r2, r1, #1900544	; 0x1d0000
 8000f3a:	605a      	str	r2, [r3, #4]

    /* Enable PLL */
    RCC->CR |= RCC_CR_PLLON;
 8000f3c:	6818      	ldr	r0, [r3, #0]
 8000f3e:	f040 7180 	orr.w	r1, r0, #16777216	; 0x1000000
 8000f42:	6019      	str	r1, [r3, #0]

    /* Wait till PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 8000f44:	6818      	ldr	r0, [r3, #0]
 8000f46:	4a09      	ldr	r2, [pc, #36]	; (8000f6c <SystemInit+0xec>)
 8000f48:	0181      	lsls	r1, r0, #6
 8000f4a:	d5fb      	bpl.n	8000f44 <SystemInit+0xc4>
    {
    }
    
    /* Select PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 8000f4c:	6853      	ldr	r3, [r2, #4]
 8000f4e:	f023 0103 	bic.w	r1, r3, #3
 8000f52:	6051      	str	r1, [r2, #4]
    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
 8000f54:	6850      	ldr	r0, [r2, #4]
 8000f56:	f040 0302 	orr.w	r3, r0, #2
 8000f5a:	6053      	str	r3, [r2, #4]

    /* Wait till PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
 8000f5c:	4a03      	ldr	r2, [pc, #12]	; (8000f6c <SystemInit+0xec>)
 8000f5e:	6851      	ldr	r1, [r2, #4]
 8000f60:	f001 000c 	and.w	r0, r1, #12
 8000f64:	2808      	cmp	r0, #8
 8000f66:	d1f9      	bne.n	8000f5c <SystemInit+0xdc>
 8000f68:	e7c3      	b.n	8000ef2 <SystemInit+0x72>
 8000f6a:	bf00      	nop
 8000f6c:	40021000 	.word	0x40021000
 8000f70:	f8ff0000 	.word	0xf8ff0000
 8000f74:	e000ed00 	.word	0xe000ed00
 8000f78:	40022000 	.word	0x40022000

08000f7c <NVIC_PriorityGroupConfig>:
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
 8000f7c:	f040 60bf 	orr.w	r0, r0, #100139008	; 0x5f80000
 8000f80:	4b02      	ldr	r3, [pc, #8]	; (8000f8c <NVIC_PriorityGroupConfig+0x10>)
 8000f82:	f440 3100 	orr.w	r1, r0, #131072	; 0x20000
 8000f86:	60d9      	str	r1, [r3, #12]
 8000f88:	4770      	bx	lr
 8000f8a:	bf00      	nop
 8000f8c:	e000ed00 	.word	0xe000ed00

08000f90 <NVIC_Init>:
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 8000f90:	78c3      	ldrb	r3, [r0, #3]
  * @param  NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure that contains
  *         the configuration information for the specified NVIC peripheral.
  * @retval None
  */
void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
{
 8000f92:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 8000f94:	b303      	cbz	r3, 8000fd8 <NVIC_Init+0x48>
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8000f96:	4c16      	ldr	r4, [pc, #88]	; (8000ff0 <NVIC_Init+0x60>)
 8000f98:	68e1      	ldr	r1, [r4, #12]
 8000f9a:	43cb      	mvns	r3, r1
 8000f9c:	f3c3 2402 	ubfx	r4, r3, #8, #3
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8000fa0:	7841      	ldrb	r1, [r0, #1]
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
    tmppre = (0x4 - tmppriority);
 8000fa2:	f1c4 0204 	rsb	r2, r4, #4
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8000fa6:	fa01 f102 	lsl.w	r1, r1, r2
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
 8000faa:	220f      	movs	r2, #15
 8000fac:	fa22 f204 	lsr.w	r2, r2, r4

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 8000fb0:	7884      	ldrb	r4, [r0, #2]
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8000fb2:	7803      	ldrb	r3, [r0, #0]
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 8000fb4:	4022      	ands	r2, r4
 8000fb6:	430a      	orrs	r2, r1
    tmppriority = tmppriority << 0x04;
 8000fb8:	0111      	lsls	r1, r2, #4
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8000fba:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 8000fbe:	b2ca      	uxtb	r2, r1
 8000fc0:	f503 4161 	add.w	r1, r3, #57600	; 0xe100
 8000fc4:	f881 2300 	strb.w	r2, [r1, #768]	; 0x300
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8000fc8:	7800      	ldrb	r0, [r0, #0]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8000fca:	2201      	movs	r2, #1
 8000fcc:	f000 031f 	and.w	r3, r0, #31
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8000fd0:	0941      	lsrs	r1, r0, #5
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8000fd2:	fa02 f003 	lsl.w	r0, r2, r3
 8000fd6:	e007      	b.n	8000fe8 <NVIC_Init+0x58>
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8000fd8:	7800      	ldrb	r0, [r0, #0]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8000fda:	2201      	movs	r2, #1
 8000fdc:	f000 031f 	and.w	r3, r0, #31
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8000fe0:	0941      	lsrs	r1, r0, #5
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8000fe2:	fa02 f003 	lsl.w	r0, r2, r3
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8000fe6:	3120      	adds	r1, #32
 8000fe8:	4b02      	ldr	r3, [pc, #8]	; (8000ff4 <NVIC_Init+0x64>)
 8000fea:	f843 0021 	str.w	r0, [r3, r1, lsl #2]
 8000fee:	bd10      	pop	{r4, pc}
 8000ff0:	e000ed00 	.word	0xe000ed00
 8000ff4:	e000e100 	.word	0xe000e100

08000ff8 <DMA_DeInit>:
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  
  /* Disable the selected DMAy Channelx */
  DMAy_Channelx->CCR &= (uint16_t)(~DMA_CCR1_EN);
 8000ff8:	6802      	ldr	r2, [r0, #0]
 8000ffa:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 8000ffe:	4013      	ands	r3, r2
 8001000:	6003      	str	r3, [r0, #0]
  DMAy_Channelx->CPAR  = 0;
  
  /* Reset DMAy Channelx memory address register */
  DMAy_Channelx->CMAR = 0;
  
  if (DMAy_Channelx == DMA1_Channel1)
 8001002:	4b2d      	ldr	r3, [pc, #180]	; (80010b8 <DMA_DeInit+0xc0>)
  
  /* Disable the selected DMAy Channelx */
  DMAy_Channelx->CCR &= (uint16_t)(~DMA_CCR1_EN);
  
  /* Reset DMAy Channelx control register */
  DMAy_Channelx->CCR  = 0;
 8001004:	2100      	movs	r1, #0
  DMAy_Channelx->CPAR  = 0;
  
  /* Reset DMAy Channelx memory address register */
  DMAy_Channelx->CMAR = 0;
  
  if (DMAy_Channelx == DMA1_Channel1)
 8001006:	4298      	cmp	r0, r3
  
  /* Disable the selected DMAy Channelx */
  DMAy_Channelx->CCR &= (uint16_t)(~DMA_CCR1_EN);
  
  /* Reset DMAy Channelx control register */
  DMAy_Channelx->CCR  = 0;
 8001008:	6001      	str	r1, [r0, #0]
  
  /* Reset DMAy Channelx remaining bytes register */
  DMAy_Channelx->CNDTR = 0;
 800100a:	6041      	str	r1, [r0, #4]
  
  /* Reset DMAy Channelx peripheral address register */
  DMAy_Channelx->CPAR  = 0;
 800100c:	6081      	str	r1, [r0, #8]
  
  /* Reset DMAy Channelx memory address register */
  DMAy_Channelx->CMAR = 0;
 800100e:	60c1      	str	r1, [r0, #12]
  
  if (DMAy_Channelx == DMA1_Channel1)
 8001010:	d022      	beq.n	8001058 <DMA_DeInit+0x60>
  {
    /* Reset interrupt pending bits for DMA1 Channel1 */
    DMA1->IFCR |= DMA1_Channel1_IT_Mask;
  }
  else if (DMAy_Channelx == DMA1_Channel2)
 8001012:	492a      	ldr	r1, [pc, #168]	; (80010bc <DMA_DeInit+0xc4>)
 8001014:	4288      	cmp	r0, r1
 8001016:	d029      	beq.n	800106c <DMA_DeInit+0x74>
  {
    /* Reset interrupt pending bits for DMA1 Channel2 */
    DMA1->IFCR |= DMA1_Channel2_IT_Mask;
  }
  else if (DMAy_Channelx == DMA1_Channel3)
 8001018:	4b29      	ldr	r3, [pc, #164]	; (80010c0 <DMA_DeInit+0xc8>)
 800101a:	4298      	cmp	r0, r3
 800101c:	d030      	beq.n	8001080 <DMA_DeInit+0x88>
  {
    /* Reset interrupt pending bits for DMA1 Channel3 */
    DMA1->IFCR |= DMA1_Channel3_IT_Mask;
  }
  else if (DMAy_Channelx == DMA1_Channel4)
 800101e:	4929      	ldr	r1, [pc, #164]	; (80010c4 <DMA_DeInit+0xcc>)
 8001020:	4288      	cmp	r0, r1
 8001022:	d037      	beq.n	8001094 <DMA_DeInit+0x9c>
  {
    /* Reset interrupt pending bits for DMA1 Channel4 */
    DMA1->IFCR |= DMA1_Channel4_IT_Mask;
  }
  else if (DMAy_Channelx == DMA1_Channel5)
 8001024:	4b28      	ldr	r3, [pc, #160]	; (80010c8 <DMA_DeInit+0xd0>)
 8001026:	4298      	cmp	r0, r3
 8001028:	d03e      	beq.n	80010a8 <DMA_DeInit+0xb0>
  {
    /* Reset interrupt pending bits for DMA1 Channel5 */
    DMA1->IFCR |= DMA1_Channel5_IT_Mask;
  }
  else if (DMAy_Channelx == DMA1_Channel6)
 800102a:	4b28      	ldr	r3, [pc, #160]	; (80010cc <DMA_DeInit+0xd4>)
 800102c:	4298      	cmp	r0, r3
 800102e:	d106      	bne.n	800103e <DMA_DeInit+0x46>
  {
    /* Reset interrupt pending bits for DMA1 Channel6 */
    DMA1->IFCR |= DMA1_Channel6_IT_Mask;
 8001030:	f853 1c68 	ldr.w	r1, [r3, #-104]
 8001034:	f441 0070 	orr.w	r0, r1, #15728640	; 0xf00000
 8001038:	f843 0c68 	str.w	r0, [r3, #-104]
 800103c:	4770      	bx	lr
  }
  else if (DMAy_Channelx == DMA1_Channel7)
 800103e:	4924      	ldr	r1, [pc, #144]	; (80010d0 <DMA_DeInit+0xd8>)
 8001040:	4288      	cmp	r0, r1
 8001042:	d106      	bne.n	8001052 <DMA_DeInit+0x5a>
  {
    /* Reset interrupt pending bits for DMA1 Channel7 */
    DMA1->IFCR |= DMA1_Channel7_IT_Mask;
 8001044:	f851 0c7c 	ldr.w	r0, [r1, #-124]
 8001048:	f040 6270 	orr.w	r2, r0, #251658240	; 0xf000000
 800104c:	f841 2c7c 	str.w	r2, [r1, #-124]
 8001050:	4770      	bx	lr
  }
  else if (DMAy_Channelx == DMA2_Channel1)
 8001052:	4b20      	ldr	r3, [pc, #128]	; (80010d4 <DMA_DeInit+0xdc>)
 8001054:	4298      	cmp	r0, r3
 8001056:	d106      	bne.n	8001066 <DMA_DeInit+0x6e>
  {
    /* Reset interrupt pending bits for DMA2 Channel1 */
    DMA2->IFCR |= DMA2_Channel1_IT_Mask;
 8001058:	f853 2c04 	ldr.w	r2, [r3, #-4]
 800105c:	f042 010f 	orr.w	r1, r2, #15
 8001060:	f843 1c04 	str.w	r1, [r3, #-4]
 8001064:	4770      	bx	lr
  }
  else if (DMAy_Channelx == DMA2_Channel2)
 8001066:	491c      	ldr	r1, [pc, #112]	; (80010d8 <DMA_DeInit+0xe0>)
 8001068:	4288      	cmp	r0, r1
 800106a:	d106      	bne.n	800107a <DMA_DeInit+0x82>
  {
    /* Reset interrupt pending bits for DMA2 Channel2 */
    DMA2->IFCR |= DMA2_Channel2_IT_Mask;
 800106c:	f851 3c18 	ldr.w	r3, [r1, #-24]
 8001070:	f043 00f0 	orr.w	r0, r3, #240	; 0xf0
 8001074:	f841 0c18 	str.w	r0, [r1, #-24]
 8001078:	4770      	bx	lr
  }
  else if (DMAy_Channelx == DMA2_Channel3)
 800107a:	4b18      	ldr	r3, [pc, #96]	; (80010dc <DMA_DeInit+0xe4>)
 800107c:	4298      	cmp	r0, r3
 800107e:	d106      	bne.n	800108e <DMA_DeInit+0x96>
  {
    /* Reset interrupt pending bits for DMA2 Channel3 */
    DMA2->IFCR |= DMA2_Channel3_IT_Mask;
 8001080:	f853 2c2c 	ldr.w	r2, [r3, #-44]
 8001084:	f442 6170 	orr.w	r1, r2, #3840	; 0xf00
 8001088:	f843 1c2c 	str.w	r1, [r3, #-44]
 800108c:	4770      	bx	lr
  }
  else if (DMAy_Channelx == DMA2_Channel4)
 800108e:	4914      	ldr	r1, [pc, #80]	; (80010e0 <DMA_DeInit+0xe8>)
 8001090:	4288      	cmp	r0, r1
 8001092:	d106      	bne.n	80010a2 <DMA_DeInit+0xaa>
  {
    /* Reset interrupt pending bits for DMA2 Channel4 */
    DMA2->IFCR |= DMA2_Channel4_IT_Mask;
 8001094:	f851 3c40 	ldr.w	r3, [r1, #-64]
 8001098:	f443 4070 	orr.w	r0, r3, #61440	; 0xf000
 800109c:	f841 0c40 	str.w	r0, [r1, #-64]
 80010a0:	4770      	bx	lr
  }
  else
  { 
    if (DMAy_Channelx == DMA2_Channel5)
 80010a2:	4b10      	ldr	r3, [pc, #64]	; (80010e4 <DMA_DeInit+0xec>)
 80010a4:	4298      	cmp	r0, r3
 80010a6:	d105      	bne.n	80010b4 <DMA_DeInit+0xbc>
    {
      /* Reset interrupt pending bits for DMA2 Channel5 */
      DMA2->IFCR |= DMA2_Channel5_IT_Mask;
 80010a8:	f853 2c54 	ldr.w	r2, [r3, #-84]
 80010ac:	f442 2170 	orr.w	r1, r2, #983040	; 0xf0000
 80010b0:	f843 1c54 	str.w	r1, [r3, #-84]
 80010b4:	4770      	bx	lr
 80010b6:	bf00      	nop
 80010b8:	40020008 	.word	0x40020008
 80010bc:	4002001c 	.word	0x4002001c
 80010c0:	40020030 	.word	0x40020030
 80010c4:	40020044 	.word	0x40020044
 80010c8:	40020058 	.word	0x40020058
 80010cc:	4002006c 	.word	0x4002006c
 80010d0:	40020080 	.word	0x40020080
 80010d4:	40020408 	.word	0x40020408
 80010d8:	4002041c 	.word	0x4002041c
 80010dc:	40020430 	.word	0x40020430
 80010e0:	40020444 	.word	0x40020444
 80010e4:	40020458 	.word	0x40020458

080010e8 <DMA_Init>:
  * @param  DMA_InitStruct: pointer to a DMA_InitTypeDef structure that
  *         contains the configuration information for the specified DMA Channel.
  * @retval None
  */
void DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct)
{
 80010e8:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_DMA_PRIORITY(DMA_InitStruct->DMA_Priority));
  assert_param(IS_DMA_M2M_STATE(DMA_InitStruct->DMA_M2M));

/*--------------------------- DMAy Channelx CCR Configuration -----------------*/
  /* Get the DMAy_Channelx CCR value */
  tmpreg = DMAy_Channelx->CCR;
 80010ea:	6806      	ldr	r6, [r0, #0]
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 80010ec:	688c      	ldr	r4, [r1, #8]
 80010ee:	6a0d      	ldr	r5, [r1, #32]

/*--------------------------- DMAy Channelx CCR Configuration -----------------*/
  /* Get the DMAy_Channelx CCR value */
  tmpreg = DMAy_Channelx->CCR;
  /* Clear MEM2MEM, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
  tmpreg &= CCR_CLEAR_Mask;
 80010f0:	f426 42ff 	bic.w	r2, r6, #32640	; 0x7f80
 80010f4:	f022 0670 	bic.w	r6, r2, #112	; 0x70
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 80010f8:	690a      	ldr	r2, [r1, #16]
 80010fa:	ea45 0304 	orr.w	r3, r5, r4
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 80010fe:	694c      	ldr	r4, [r1, #20]
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 8001100:	4313      	orrs	r3, r2
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 8001102:	698a      	ldr	r2, [r1, #24]
 8001104:	4323      	orrs	r3, r4
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 8001106:	69cc      	ldr	r4, [r1, #28]
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 8001108:	4313      	orrs	r3, r2
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 800110a:	431c      	orrs	r4, r3
 800110c:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 800110e:	ea44 0203 	orr.w	r2, r4, r3
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;
 8001112:	6a8b      	ldr	r3, [r1, #40]	; 0x28
 8001114:	431a      	orrs	r2, r3
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 8001116:	4332      	orrs	r2, r6
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;

  /* Write to DMAy Channelx CCR */
  DMAy_Channelx->CCR = tmpreg;
 8001118:	6002      	str	r2, [r0, #0]

/*--------------------------- DMAy Channelx CNDTR Configuration ---------------*/
  /* Write to DMAy Channelx CNDTR */
  DMAy_Channelx->CNDTR = DMA_InitStruct->DMA_BufferSize;
 800111a:	68cb      	ldr	r3, [r1, #12]

/*--------------------------- DMAy Channelx CPAR Configuration ----------------*/
  /* Write to DMAy Channelx CPAR */
  DMAy_Channelx->CPAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
 800111c:	680a      	ldr	r2, [r1, #0]

/*--------------------------- DMAy Channelx CMAR Configuration ----------------*/
  /* Write to DMAy Channelx CMAR */
  DMAy_Channelx->CMAR = DMA_InitStruct->DMA_MemoryBaseAddr;
 800111e:	6849      	ldr	r1, [r1, #4]
  /* Write to DMAy Channelx CCR */
  DMAy_Channelx->CCR = tmpreg;

/*--------------------------- DMAy Channelx CNDTR Configuration ---------------*/
  /* Write to DMAy Channelx CNDTR */
  DMAy_Channelx->CNDTR = DMA_InitStruct->DMA_BufferSize;
 8001120:	6043      	str	r3, [r0, #4]

/*--------------------------- DMAy Channelx CPAR Configuration ----------------*/
  /* Write to DMAy Channelx CPAR */
  DMAy_Channelx->CPAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
 8001122:	6082      	str	r2, [r0, #8]

/*--------------------------- DMAy Channelx CMAR Configuration ----------------*/
  /* Write to DMAy Channelx CMAR */
  DMAy_Channelx->CMAR = DMA_InitStruct->DMA_MemoryBaseAddr;
 8001124:	60c1      	str	r1, [r0, #12]
 8001126:	bd70      	pop	{r4, r5, r6, pc}

08001128 <DMA_Cmd>:
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8001128:	b119      	cbz	r1, 8001132 <DMA_Cmd+0xa>
  {
    /* Enable the selected DMAy Channelx */
    DMAy_Channelx->CCR |= DMA_CCR1_EN;
 800112a:	6801      	ldr	r1, [r0, #0]
 800112c:	f041 0301 	orr.w	r3, r1, #1
 8001130:	e003      	b.n	800113a <DMA_Cmd+0x12>
  }
  else
  {
    /* Disable the selected DMAy Channelx */
    DMAy_Channelx->CCR &= (uint16_t)(~DMA_CCR1_EN);
 8001132:	6802      	ldr	r2, [r0, #0]
 8001134:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 8001138:	4013      	ands	r3, r2
 800113a:	6003      	str	r3, [r0, #0]
 800113c:	4770      	bx	lr

0800113e <DMA_ITConfig>:
  assert_param(IS_DMA_CONFIG_IT(DMA_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected DMA interrupts */
    DMAy_Channelx->CCR |= DMA_IT;
 800113e:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  assert_param(IS_DMA_CONFIG_IT(DMA_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001140:	b10a      	cbz	r2, 8001146 <DMA_ITConfig+0x8>
  {
    /* Enable the selected DMA interrupts */
    DMAy_Channelx->CCR |= DMA_IT;
 8001142:	4319      	orrs	r1, r3
 8001144:	e001      	b.n	800114a <DMA_ITConfig+0xc>
  }
  else
  {
    /* Disable the selected DMA interrupts */
    DMAy_Channelx->CCR &= ~DMA_IT;
 8001146:	ea23 0101 	bic.w	r1, r3, r1
 800114a:	6001      	str	r1, [r0, #0]
 800114c:	4770      	bx	lr

0800114e <DMA_GetCurrDataCounter>:
uint16_t DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx)
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  /* Return the number of remaining data units for DMAy Channelx */
  return ((uint16_t)(DMAy_Channelx->CNDTR));
 800114e:	6840      	ldr	r0, [r0, #4]
}
 8001150:	b280      	uxth	r0, r0
 8001152:	4770      	bx	lr

08001154 <DMA_GetFlagStatus>:
  
  /* Check the parameters */
  assert_param(IS_DMA_GET_FLAG(DMAy_FLAG));

  /* Calculate the used DMAy */
  if ((DMAy_FLAG & FLAG_Mask) != (uint32_t)RESET)
 8001154:	00c3      	lsls	r3, r0, #3
  {
    /* Get DMA2 ISR register value */
    tmpreg = DMA2->ISR ;
 8001156:	bf4c      	ite	mi
 8001158:	4b03      	ldrmi	r3, [pc, #12]	; (8001168 <DMA_GetFlagStatus+0x14>)
  }
  else
  {
    /* Get DMA1 ISR register value */
    tmpreg = DMA1->ISR ;
 800115a:	4b04      	ldrpl	r3, [pc, #16]	; (800116c <DMA_GetFlagStatus+0x18>)
 800115c:	6819      	ldr	r1, [r3, #0]
  }

  /* Check the status of the specified DMAy flag */
  if ((tmpreg & DMAy_FLAG) != (uint32_t)RESET)
 800115e:	4201      	tst	r1, r0
    bitstatus = RESET;
  }
  
  /* Return the DMAy_FLAG status */
  return  bitstatus;
}
 8001160:	bf0c      	ite	eq
 8001162:	2000      	moveq	r0, #0
 8001164:	2001      	movne	r0, #1
 8001166:	4770      	bx	lr
 8001168:	40020400 	.word	0x40020400
 800116c:	40020000 	.word	0x40020000

08001170 <DMA_ClearFlag>:
{
  /* Check the parameters */
  assert_param(IS_DMA_CLEAR_FLAG(DMAy_FLAG));

  /* Calculate the used DMAy */
  if ((DMAy_FLAG & FLAG_Mask) != (uint32_t)RESET)
 8001170:	00c2      	lsls	r2, r0, #3
  {
    /* Clear the selected DMAy flags */
    DMA2->IFCR = DMAy_FLAG;
 8001172:	bf4c      	ite	mi
 8001174:	4b01      	ldrmi	r3, [pc, #4]	; (800117c <DMA_ClearFlag+0xc>)
  }
  else
  {
    /* Clear the selected DMAy flags */
    DMA1->IFCR = DMAy_FLAG;
 8001176:	4b02      	ldrpl	r3, [pc, #8]	; (8001180 <DMA_ClearFlag+0x10>)
 8001178:	6058      	str	r0, [r3, #4]
 800117a:	4770      	bx	lr
 800117c:	40020400 	.word	0x40020400
 8001180:	40020000 	.word	0x40020000

08001184 <EXTI_Init>:
  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));  
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 8001184:	7983      	ldrb	r3, [r0, #6]
  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure
  *         that contains the configuration information for the EXTI peripheral.
  * @retval None
  */
void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)
{
 8001186:	b510      	push	{r4, lr}
  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));  
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 8001188:	2b00      	cmp	r3, #0
 800118a:	d029      	beq.n	80011e0 <EXTI_Init+0x5c>
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
 800118c:	4b1a      	ldr	r3, [pc, #104]	; (80011f8 <EXTI_Init+0x74>)
 800118e:	6801      	ldr	r1, [r0, #0]
 8001190:	681c      	ldr	r4, [r3, #0]
 8001192:	43ca      	mvns	r2, r1
 8001194:	4014      	ands	r4, r2
 8001196:	601c      	str	r4, [r3, #0]
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
 8001198:	685c      	ldr	r4, [r3, #4]
 800119a:	4022      	ands	r2, r4
 800119c:	605a      	str	r2, [r3, #4]
    
    tmp += EXTI_InitStruct->EXTI_Mode;
 800119e:	7902      	ldrb	r2, [r0, #4]
 80011a0:	f102 4480 	add.w	r4, r2, #1073741824	; 0x40000000
 80011a4:	f504 3282 	add.w	r2, r4, #66560	; 0x10400

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 80011a8:	6814      	ldr	r4, [r2, #0]
 80011aa:	4321      	orrs	r1, r4
 80011ac:	6011      	str	r1, [r2, #0]

    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
 80011ae:	6802      	ldr	r2, [r0, #0]
 80011b0:	689c      	ldr	r4, [r3, #8]
 80011b2:	43d1      	mvns	r1, r2
 80011b4:	400c      	ands	r4, r1
 80011b6:	609c      	str	r4, [r3, #8]
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
 80011b8:	68dc      	ldr	r4, [r3, #12]
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 80011ba:	7940      	ldrb	r0, [r0, #5]

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;

    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
 80011bc:	4021      	ands	r1, r4
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 80011be:	2810      	cmp	r0, #16

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;

    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
 80011c0:	60d9      	str	r1, [r3, #12]
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 80011c2:	d106      	bne.n	80011d2 <EXTI_Init+0x4e>
    {
      /* Rising Falling edge */
      EXTI->RTSR |= EXTI_InitStruct->EXTI_Line;
 80011c4:	6898      	ldr	r0, [r3, #8]
 80011c6:	4310      	orrs	r0, r2
 80011c8:	6098      	str	r0, [r3, #8]
      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;
 80011ca:	68d9      	ldr	r1, [r3, #12]
 80011cc:	430a      	orrs	r2, r1
 80011ce:	60da      	str	r2, [r3, #12]
 80011d0:	bd10      	pop	{r4, pc}
    }
    else
    {
      tmp = (uint32_t)EXTI_BASE;
      tmp += EXTI_InitStruct->EXTI_Trigger;
 80011d2:	f100 4380 	add.w	r3, r0, #1073741824	; 0x40000000
 80011d6:	f503 3382 	add.w	r3, r3, #66560	; 0x10400

      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 80011da:	6819      	ldr	r1, [r3, #0]
 80011dc:	430a      	orrs	r2, r1
 80011de:	e008      	b.n	80011f2 <EXTI_Init+0x6e>
    }
  }
  else
  {
    tmp += EXTI_InitStruct->EXTI_Mode;
 80011e0:	7901      	ldrb	r1, [r0, #4]

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
 80011e2:	6800      	ldr	r0, [r0, #0]
      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
    }
  }
  else
  {
    tmp += EXTI_InitStruct->EXTI_Mode;
 80011e4:	f101 4280 	add.w	r2, r1, #1073741824	; 0x40000000
 80011e8:	f502 3382 	add.w	r3, r2, #66560	; 0x10400

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
 80011ec:	681a      	ldr	r2, [r3, #0]
 80011ee:	ea22 0200 	bic.w	r2, r2, r0
 80011f2:	601a      	str	r2, [r3, #0]
 80011f4:	bd10      	pop	{r4, pc}
 80011f6:	bf00      	nop
 80011f8:	40010400 	.word	0x40010400

080011fc <EXTI_ClearFlag>:
void EXTI_ClearFlag(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->PR = EXTI_Line;
 80011fc:	4b01      	ldr	r3, [pc, #4]	; (8001204 <EXTI_ClearFlag+0x8>)
 80011fe:	6158      	str	r0, [r3, #20]
 8001200:	4770      	bx	lr
 8001202:	bf00      	nop
 8001204:	40010400 	.word	0x40010400

08001208 <EXTI_GetITStatus>:
  ITStatus bitstatus = RESET;
  uint32_t enablestatus = 0;
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
  
  enablestatus =  EXTI->IMR & EXTI_Line;
 8001208:	4b06      	ldr	r3, [pc, #24]	; (8001224 <EXTI_GetITStatus+0x1c>)
 800120a:	681a      	ldr	r2, [r3, #0]
  if (((EXTI->PR & EXTI_Line) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
 800120c:	6959      	ldr	r1, [r3, #20]
 800120e:	ea10 0301 	ands.w	r3, r0, r1
 8001212:	d004      	beq.n	800121e <EXTI_GetITStatus+0x16>
 8001214:	4210      	tst	r0, r2
  {
    bitstatus = SET;
 8001216:	bf0c      	ite	eq
 8001218:	2000      	moveq	r0, #0
 800121a:	2001      	movne	r0, #1
 800121c:	4770      	bx	lr
  }
  else
  {
    bitstatus = RESET;
 800121e:	4618      	mov	r0, r3
  }
  return bitstatus;
}
 8001220:	4770      	bx	lr
 8001222:	bf00      	nop
 8001224:	40010400 	.word	0x40010400

08001228 <GPIO_Init>:
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
 8001228:	78cb      	ldrb	r3, [r1, #3]
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
  *         contains the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 800122a:	b5f0      	push	{r4, r5, r6, r7, lr}
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
  if ((((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x10)) != 0x00)
 800122c:	06da      	lsls	r2, r3, #27
  { 
    /* Check the parameters */
    assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
    /* Output mode */
    currentmode |= (uint32_t)GPIO_InitStruct->GPIO_Speed;
 800122e:	bf48      	it	mi
 8001230:	788a      	ldrbmi	r2, [r1, #2]
  }
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
 8001232:	8809      	ldrh	r1, [r1, #0]
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
 8001234:	f003 050f 	and.w	r5, r3, #15
  if ((((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x10)) != 0x00)
  { 
    /* Check the parameters */
    assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
    /* Output mode */
    currentmode |= (uint32_t)GPIO_InitStruct->GPIO_Speed;
 8001238:	bf48      	it	mi
 800123a:	4315      	orrmi	r5, r2
  }
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
 800123c:	f011 0fff 	tst.w	r1, #255	; 0xff
 8001240:	d01e      	beq.n	8001280 <GPIO_Init+0x58>
  {
    tmpreg = GPIOx->CRL;
 8001242:	6804      	ldr	r4, [r0, #0]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8001244:	2200      	movs	r2, #0
    {
      pos = ((uint32_t)0x01) << pinpos;
 8001246:	2701      	movs	r7, #1
 8001248:	fa07 f702 	lsl.w	r7, r7, r2
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 800124c:	ea07 0601 	and.w	r6, r7, r1
      if (currentpin == pos)
 8001250:	42be      	cmp	r6, r7
 8001252:	d111      	bne.n	8001278 <GPIO_Init+0x50>
      {
        pos = pinpos << 2;
 8001254:	0097      	lsls	r7, r2, #2
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 8001256:	f04f 0c0f 	mov.w	ip, #15
 800125a:	fa0c fc07 	lsl.w	ip, ip, r7
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 800125e:	fa05 f707 	lsl.w	r7, r5, r7
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 8001262:	ea24 040c 	bic.w	r4, r4, ip
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8001266:	2b28      	cmp	r3, #40	; 0x28
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8001268:	ea44 0407 	orr.w	r4, r4, r7
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 800126c:	d101      	bne.n	8001272 <GPIO_Init+0x4a>
        {
          GPIOx->BRR = (((uint32_t)0x01) << pinpos);
 800126e:	6146      	str	r6, [r0, #20]
 8001270:	e002      	b.n	8001278 <GPIO_Init+0x50>
        }
        else
        {
          /* Set the corresponding ODR bit */
          if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
 8001272:	2b48      	cmp	r3, #72	; 0x48
          {
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
 8001274:	bf08      	it	eq
 8001276:	6106      	streq	r6, [r0, #16]
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
  {
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8001278:	3201      	adds	r2, #1
 800127a:	2a08      	cmp	r2, #8
 800127c:	d1e3      	bne.n	8001246 <GPIO_Init+0x1e>
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
          }
        }
      }
    }
    GPIOx->CRL = tmpreg;
 800127e:	6004      	str	r4, [r0, #0]
  }
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
 8001280:	29ff      	cmp	r1, #255	; 0xff
 8001282:	d920      	bls.n	80012c6 <GPIO_Init+0x9e>
  {
    tmpreg = GPIOx->CRH;
 8001284:	6844      	ldr	r4, [r0, #4]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8001286:	2200      	movs	r2, #0
  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
  *         contains the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
 8001288:	f102 0608 	add.w	r6, r2, #8
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
  {
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
 800128c:	2701      	movs	r7, #1
 800128e:	fa07 f706 	lsl.w	r7, r7, r6
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
 8001292:	ea07 0601 	and.w	r6, r7, r1
      if (currentpin == pos)
 8001296:	42be      	cmp	r6, r7
 8001298:	d111      	bne.n	80012be <GPIO_Init+0x96>
      {
        pos = pinpos << 2;
 800129a:	0097      	lsls	r7, r2, #2
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 800129c:	f04f 0c0f 	mov.w	ip, #15
 80012a0:	fa0c fc07 	lsl.w	ip, ip, r7
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 80012a4:	fa05 f707 	lsl.w	r7, r5, r7
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 80012a8:	ea24 040c 	bic.w	r4, r4, ip
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 80012ac:	2b28      	cmp	r3, #40	; 0x28
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 80012ae:	ea44 0407 	orr.w	r4, r4, r7
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 80012b2:	d101      	bne.n	80012b8 <GPIO_Init+0x90>
        {
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
 80012b4:	6146      	str	r6, [r0, #20]
 80012b6:	e002      	b.n	80012be <GPIO_Init+0x96>
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
 80012b8:	2b48      	cmp	r3, #72	; 0x48
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
 80012ba:	bf08      	it	eq
 80012bc:	6106      	streq	r6, [r0, #16]
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
  {
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 80012be:	3201      	adds	r2, #1
 80012c0:	2a08      	cmp	r2, #8
 80012c2:	d1e1      	bne.n	8001288 <GPIO_Init+0x60>
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
        }
      }
    }
    GPIOx->CRH = tmpreg;
 80012c4:	6044      	str	r4, [r0, #4]
 80012c6:	bdf0      	pop	{r4, r5, r6, r7, pc}

080012c8 <GPIO_ReadInputDataBit>:
  
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
  
  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
 80012c8:	6883      	ldr	r3, [r0, #8]
 80012ca:	4219      	tst	r1, r3
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
}
 80012cc:	bf0c      	ite	eq
 80012ce:	2000      	moveq	r0, #0
 80012d0:	2001      	movne	r0, #1
 80012d2:	4770      	bx	lr

080012d4 <GPIO_SetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BSRR = GPIO_Pin;
 80012d4:	6101      	str	r1, [r0, #16]
 80012d6:	4770      	bx	lr

080012d8 <GPIO_ResetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BRR = GPIO_Pin;
 80012d8:	6141      	str	r1, [r0, #20]
 80012da:	4770      	bx	lr

080012dc <GPIO_EXTILineConfig>:
  uint32_t tmp = 0x00;
  /* Check the parameters */
  assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  
  tmp = ((uint32_t)0x0F) << (0x04 * (GPIO_PinSource & (uint8_t)0x03));
 80012dc:	f001 0203 	and.w	r2, r1, #3
  * @param  GPIO_PinSource: specifies the EXTI line to be configured.
  *   This parameter can be GPIO_PinSourcex where x can be (0..15).
  * @retval None
  */
void GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)
{
 80012e0:	b530      	push	{r4, r5, lr}
  uint32_t tmp = 0x00;
  /* Check the parameters */
  assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  
  tmp = ((uint32_t)0x0F) << (0x04 * (GPIO_PinSource & (uint8_t)0x03));
 80012e2:	0092      	lsls	r2, r2, #2
 80012e4:	240f      	movs	r4, #15
 80012e6:	fa04 f402 	lsl.w	r4, r4, r2
  AFIO->EXTICR[GPIO_PinSource >> 0x02] &= ~tmp;
  AFIO->EXTICR[GPIO_PinSource >> 0x02] |= (((uint32_t)GPIO_PortSource) << (0x04 * (GPIO_PinSource & (uint8_t)0x03)));
 80012ea:	fa00 f002 	lsl.w	r0, r0, r2
  /* Check the parameters */
  assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  
  tmp = ((uint32_t)0x0F) << (0x04 * (GPIO_PinSource & (uint8_t)0x03));
  AFIO->EXTICR[GPIO_PinSource >> 0x02] &= ~tmp;
 80012ee:	4b07      	ldr	r3, [pc, #28]	; (800130c <GPIO_EXTILineConfig+0x30>)
 80012f0:	0889      	lsrs	r1, r1, #2
 80012f2:	3102      	adds	r1, #2
 80012f4:	f853 5021 	ldr.w	r5, [r3, r1, lsl #2]
 80012f8:	ea25 0404 	bic.w	r4, r5, r4
 80012fc:	f843 4021 	str.w	r4, [r3, r1, lsl #2]
  AFIO->EXTICR[GPIO_PinSource >> 0x02] |= (((uint32_t)GPIO_PortSource) << (0x04 * (GPIO_PinSource & (uint8_t)0x03)));
 8001300:	f853 4021 	ldr.w	r4, [r3, r1, lsl #2]
 8001304:	4304      	orrs	r4, r0
 8001306:	f843 4021 	str.w	r4, [r3, r1, lsl #2]
 800130a:	bd30      	pop	{r4, r5, pc}
 800130c:	40010000 	.word	0x40010000

08001310 <PWR_BackupAccessCmd>:
  */
void PWR_BackupAccessCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;
 8001310:	4b01      	ldr	r3, [pc, #4]	; (8001318 <PWR_BackupAccessCmd+0x8>)
 8001312:	6018      	str	r0, [r3, #0]
 8001314:	4770      	bx	lr
 8001316:	bf00      	nop
 8001318:	420e0020 	.word	0x420e0020

0800131c <RCC_AHBPeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
{
 800131c:	4b04      	ldr	r3, [pc, #16]	; (8001330 <RCC_AHBPeriphClockCmd+0x14>)
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHBENR |= RCC_AHBPeriph;
 800131e:	695a      	ldr	r2, [r3, #20]
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8001320:	b109      	cbz	r1, 8001326 <RCC_AHBPeriphClockCmd+0xa>
  {
    RCC->AHBENR |= RCC_AHBPeriph;
 8001322:	4310      	orrs	r0, r2
 8001324:	e001      	b.n	800132a <RCC_AHBPeriphClockCmd+0xe>
  }
  else
  {
    RCC->AHBENR &= ~RCC_AHBPeriph;
 8001326:	ea22 0000 	bic.w	r0, r2, r0
 800132a:	6158      	str	r0, [r3, #20]
 800132c:	4770      	bx	lr
 800132e:	bf00      	nop
 8001330:	40021000 	.word	0x40021000

08001334 <RCC_APB2PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 8001334:	4b04      	ldr	r3, [pc, #16]	; (8001348 <RCC_APB2PeriphClockCmd+0x14>)
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 8001336:	699a      	ldr	r2, [r3, #24]
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001338:	b109      	cbz	r1, 800133e <RCC_APB2PeriphClockCmd+0xa>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 800133a:	4310      	orrs	r0, r2
 800133c:	e001      	b.n	8001342 <RCC_APB2PeriphClockCmd+0xe>
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 800133e:	ea22 0000 	bic.w	r0, r2, r0
 8001342:	6198      	str	r0, [r3, #24]
 8001344:	4770      	bx	lr
 8001346:	bf00      	nop
 8001348:	40021000 	.word	0x40021000

0800134c <RCC_APB1PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 800134c:	4b04      	ldr	r3, [pc, #16]	; (8001360 <RCC_APB1PeriphClockCmd+0x14>)
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 800134e:	69da      	ldr	r2, [r3, #28]
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001350:	b109      	cbz	r1, 8001356 <RCC_APB1PeriphClockCmd+0xa>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 8001352:	4310      	orrs	r0, r2
 8001354:	e001      	b.n	800135a <RCC_APB1PeriphClockCmd+0xe>
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 8001356:	ea22 0000 	bic.w	r0, r2, r0
 800135a:	61d8      	str	r0, [r3, #28]
 800135c:	4770      	bx	lr
 800135e:	bf00      	nop
 8001360:	40021000 	.word	0x40021000

08001364 <SPI_Init>:
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8001364:	880b      	ldrh	r3, [r1, #0]
  * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
  *         contains the configuration information for the specified SPI peripheral.
  * @retval None
  */
void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
{
 8001366:	b510      	push	{r4, lr}
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8001368:	884c      	ldrh	r4, [r1, #2]
  assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
  assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));

/*---------------------------- SPIx CR1 Configuration ------------------------*/
  /* Get the SPIx CR1 value */
  tmpreg = SPIx->CR1;
 800136a:	8802      	ldrh	r2, [r0, #0]
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 800136c:	4323      	orrs	r3, r4
 800136e:	888c      	ldrh	r4, [r1, #4]

/*---------------------------- SPIx CR1 Configuration ------------------------*/
  /* Get the SPIx CR1 value */
  tmpreg = SPIx->CR1;
  /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
  tmpreg &= CR1_CLEAR_Mask;
 8001370:	f402 5241 	and.w	r2, r2, #12352	; 0x3040
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8001374:	4323      	orrs	r3, r4
 8001376:	88cc      	ldrh	r4, [r1, #6]
 8001378:	4323      	orrs	r3, r4
 800137a:	890c      	ldrh	r4, [r1, #8]
 800137c:	4323      	orrs	r3, r4
 800137e:	894c      	ldrh	r4, [r1, #10]
 8001380:	4323      	orrs	r3, r4
 8001382:	898c      	ldrh	r4, [r1, #12]
 8001384:	4323      	orrs	r3, r4
 8001386:	89cc      	ldrh	r4, [r1, #14]
  /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
  SPIx->I2SCFGR &= SPI_Mode_Select;		

/*---------------------------- SPIx CRCPOLY Configuration --------------------*/
  /* Write to SPIx CRCPOLY */
  SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
 8001388:	8a09      	ldrh	r1, [r1, #16]
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 800138a:	4323      	orrs	r3, r4
 800138c:	431a      	orrs	r2, r3
 800138e:	b293      	uxth	r3, r2
                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
                  SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
                  SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
  /* Write to SPIx CR1 */
  SPIx->CR1 = tmpreg;
 8001390:	8003      	strh	r3, [r0, #0]
  
  /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
  SPIx->I2SCFGR &= SPI_Mode_Select;		
 8001392:	8b82      	ldrh	r2, [r0, #28]
 8001394:	f422 6300 	bic.w	r3, r2, #2048	; 0x800
 8001398:	041a      	lsls	r2, r3, #16
 800139a:	0c13      	lsrs	r3, r2, #16
 800139c:	8383      	strh	r3, [r0, #28]

/*---------------------------- SPIx CRCPOLY Configuration --------------------*/
  /* Write to SPIx CRCPOLY */
  SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
 800139e:	8201      	strh	r1, [r0, #16]
 80013a0:	bd10      	pop	{r4, pc}

080013a2 <SPI_Cmd>:
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected SPI peripheral */
    SPIx->CR1 |= CR1_SPE_Set;
 80013a2:	8803      	ldrh	r3, [r0, #0]
void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80013a4:	b119      	cbz	r1, 80013ae <SPI_Cmd+0xc>
  {
    /* Enable the selected SPI peripheral */
    SPIx->CR1 |= CR1_SPE_Set;
 80013a6:	b299      	uxth	r1, r3
 80013a8:	f041 0340 	orr.w	r3, r1, #64	; 0x40
 80013ac:	e003      	b.n	80013b6 <SPI_Cmd+0x14>
  }
  else
  {
    /* Disable the selected SPI peripheral */
    SPIx->CR1 &= CR1_SPE_Reset;
 80013ae:	f023 0140 	bic.w	r1, r3, #64	; 0x40
 80013b2:	040a      	lsls	r2, r1, #16
 80013b4:	0c13      	lsrs	r3, r2, #16
 80013b6:	8003      	strh	r3, [r0, #0]
 80013b8:	4770      	bx	lr

080013ba <SPI_I2S_DMACmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
  if (NewState != DISABLE)
  {
    /* Enable the selected SPI/I2S DMA requests */
    SPIx->CR2 |= SPI_I2S_DMAReq;
 80013ba:	8883      	ldrh	r3, [r0, #4]
 80013bc:	b29b      	uxth	r3, r3
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
  if (NewState != DISABLE)
 80013be:	b10a      	cbz	r2, 80013c4 <SPI_I2S_DMACmd+0xa>
  {
    /* Enable the selected SPI/I2S DMA requests */
    SPIx->CR2 |= SPI_I2S_DMAReq;
 80013c0:	4319      	orrs	r1, r3
 80013c2:	e001      	b.n	80013c8 <SPI_I2S_DMACmd+0xe>
  }
  else
  {
    /* Disable the selected SPI/I2S DMA requests */
    SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
 80013c4:	ea23 0101 	bic.w	r1, r3, r1
 80013c8:	8081      	strh	r1, [r0, #4]
 80013ca:	4770      	bx	lr

080013cc <SPI_I2S_GetFlagStatus>:
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
  /* Check the status of the specified SPI/I2S flag */
  if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
 80013cc:	8903      	ldrh	r3, [r0, #8]
 80013ce:	4219      	tst	r1, r3
    /* SPI_I2S_FLAG is reset */
    bitstatus = RESET;
  }
  /* Return the SPI_I2S_FLAG status */
  return  bitstatus;
}
 80013d0:	bf0c      	ite	eq
 80013d2:	2000      	moveq	r0, #0
 80013d4:	2001      	movne	r0, #1
 80013d6:	4770      	bx	lr

080013d8 <TIM_TimeBaseInit>:
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
 80013d8:	4a22      	ldr	r2, [pc, #136]	; (8001464 <TIM_TimeBaseInit+0x8c>)
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  
 80013da:	8803      	ldrh	r3, [r0, #0]

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
 80013dc:	4290      	cmp	r0, r2
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  
 80013de:	b29b      	uxth	r3, r3

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
 80013e0:	d012      	beq.n	8001408 <TIM_TimeBaseInit+0x30>
 80013e2:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 80013e6:	4290      	cmp	r0, r2
 80013e8:	d00e      	beq.n	8001408 <TIM_TimeBaseInit+0x30>
 80013ea:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 80013ee:	d00b      	beq.n	8001408 <TIM_TimeBaseInit+0x30>
 80013f0:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 80013f4:	4290      	cmp	r0, r2
 80013f6:	d007      	beq.n	8001408 <TIM_TimeBaseInit+0x30>
 80013f8:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80013fc:	4290      	cmp	r0, r2
 80013fe:	d003      	beq.n	8001408 <TIM_TimeBaseInit+0x30>
     (TIMx == TIM4) || (TIMx == TIM5)) 
 8001400:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001404:	4290      	cmp	r0, r2
 8001406:	d103      	bne.n	8001410 <TIM_TimeBaseInit+0x38>
  {
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 8001408:	884a      	ldrh	r2, [r1, #2]

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
     (TIMx == TIM4) || (TIMx == TIM5)) 
  {
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
 800140a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 800140e:	4313      	orrs	r3, r2
  }
 
  if((TIMx != TIM6) && (TIMx != TIM7))
 8001410:	4a15      	ldr	r2, [pc, #84]	; (8001468 <TIM_TimeBaseInit+0x90>)
 8001412:	4290      	cmp	r0, r2
 8001414:	d008      	beq.n	8001428 <TIM_TimeBaseInit+0x50>
 8001416:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800141a:	4290      	cmp	r0, r2
 800141c:	d004      	beq.n	8001428 <TIM_TimeBaseInit+0x50>
  {
    /* Set the clock division */
    tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
 800141e:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 8001422:	88ca      	ldrh	r2, [r1, #6]
  }
 
  if((TIMx != TIM6) && (TIMx != TIM7))
  {
    /* Set the clock division */
    tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
 8001424:	b29b      	uxth	r3, r3
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 8001426:	4313      	orrs	r3, r2
  }

  TIMx->CR1 = tmpcr1;
 8001428:	8003      	strh	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
 800142a:	888b      	ldrh	r3, [r1, #4]
 
  /* Set the Prescaler value */
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
 800142c:	880a      	ldrh	r2, [r1, #0]
  }

  TIMx->CR1 = tmpcr1;

  /* Set the Autoreload value */
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
 800142e:	8583      	strh	r3, [r0, #44]	; 0x2c
 
  /* Set the Prescaler value */
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
    
  if ((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15)|| (TIMx == TIM16) || (TIMx == TIM17))  
 8001430:	4b0c      	ldr	r3, [pc, #48]	; (8001464 <TIM_TimeBaseInit+0x8c>)

  /* Set the Autoreload value */
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
 
  /* Set the Prescaler value */
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
 8001432:	8502      	strh	r2, [r0, #40]	; 0x28
    
  if ((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15)|| (TIMx == TIM16) || (TIMx == TIM17))  
 8001434:	4298      	cmp	r0, r3
 8001436:	d00f      	beq.n	8001458 <TIM_TimeBaseInit+0x80>
 8001438:	f503 6200 	add.w	r2, r3, #2048	; 0x800
 800143c:	4290      	cmp	r0, r2
 800143e:	d00b      	beq.n	8001458 <TIM_TimeBaseInit+0x80>
 8001440:	f502 6340 	add.w	r3, r2, #3072	; 0xc00
 8001444:	4298      	cmp	r0, r3
 8001446:	d007      	beq.n	8001458 <TIM_TimeBaseInit+0x80>
 8001448:	f503 6280 	add.w	r2, r3, #1024	; 0x400
 800144c:	4290      	cmp	r0, r2
 800144e:	d003      	beq.n	8001458 <TIM_TimeBaseInit+0x80>
 8001450:	f502 6380 	add.w	r3, r2, #1024	; 0x400
 8001454:	4298      	cmp	r0, r3
 8001456:	d101      	bne.n	800145c <TIM_TimeBaseInit+0x84>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
 8001458:	7a09      	ldrb	r1, [r1, #8]
 800145a:	8601      	strh	r1, [r0, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler and the Repetition counter
     values immediately */
  TIMx->EGR = TIM_PSCReloadMode_Immediate;           
 800145c:	2201      	movs	r2, #1
 800145e:	8282      	strh	r2, [r0, #20]
 8001460:	4770      	bx	lr
 8001462:	bf00      	nop
 8001464:	40012c00 	.word	0x40012c00
 8001468:	40001000 	.word	0x40001000

0800146c <TIM_TimeBaseStructInit>:
  */
void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
{
  /* Set the default configuration */
  TIM_TimeBaseInitStruct->TIM_Period = 0xFFFF;
  TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
 800146c:	2100      	movs	r1, #0
  * @retval None
  */
void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
{
  /* Set the default configuration */
  TIM_TimeBaseInitStruct->TIM_Period = 0xFFFF;
 800146e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8001472:	8083      	strh	r3, [r0, #4]
  TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
 8001474:	8001      	strh	r1, [r0, #0]
  TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
 8001476:	80c1      	strh	r1, [r0, #6]
  TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
 8001478:	8041      	strh	r1, [r0, #2]
  TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
 800147a:	7201      	strb	r1, [r0, #8]
 800147c:	4770      	bx	lr

0800147e <TIM_Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_CEN;
 800147e:	8803      	ldrh	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8001480:	b119      	cbz	r1, 800148a <TIM_Cmd+0xc>
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_CEN;
 8001482:	b299      	uxth	r1, r3
 8001484:	f041 0301 	orr.w	r3, r1, #1
 8001488:	e003      	b.n	8001492 <TIM_Cmd+0x14>
  }
  else
  {
    /* Disable the TIM Counter */
    TIMx->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN));
 800148a:	f023 0101 	bic.w	r1, r3, #1
 800148e:	040a      	lsls	r2, r1, #16
 8001490:	0c13      	lsrs	r3, r2, #16
 8001492:	8003      	strh	r3, [r0, #0]
 8001494:	4770      	bx	lr

08001496 <TIM_ITConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the Interrupt sources */
    TIMx->DIER |= TIM_IT;
 8001496:	8983      	ldrh	r3, [r0, #12]
 8001498:	b29b      	uxth	r3, r3
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_IT(TIM_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800149a:	b10a      	cbz	r2, 80014a0 <TIM_ITConfig+0xa>
  {
    /* Enable the Interrupt sources */
    TIMx->DIER |= TIM_IT;
 800149c:	4319      	orrs	r1, r3
 800149e:	e001      	b.n	80014a4 <TIM_ITConfig+0xe>
  }
  else
  {
    /* Disable the Interrupt sources */
    TIMx->DIER &= (uint16_t)~TIM_IT;
 80014a0:	ea23 0101 	bic.w	r1, r3, r1
 80014a4:	8181      	strh	r1, [r0, #12]
 80014a6:	4770      	bx	lr

080014a8 <TIM_SelectOnePulseMode>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
  /* Reset the OPM Bit */
  TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_OPM);
 80014a8:	8803      	ldrh	r3, [r0, #0]
 80014aa:	f023 0208 	bic.w	r2, r3, #8
 80014ae:	0413      	lsls	r3, r2, #16
 80014b0:	0c1a      	lsrs	r2, r3, #16
 80014b2:	8002      	strh	r2, [r0, #0]
  /* Configure the OPM Mode */
  TIMx->CR1 |= TIM_OPMode;
 80014b4:	8803      	ldrh	r3, [r0, #0]
 80014b6:	b29a      	uxth	r2, r3
 80014b8:	4311      	orrs	r1, r2
 80014ba:	8001      	strh	r1, [r0, #0]
 80014bc:	4770      	bx	lr

080014be <TIM_GetITStatus>:
  uint16_t itstatus = 0x0, itenable = 0x0;
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_IT(TIM_IT));
   
  itstatus = TIMx->SR & TIM_IT;
 80014be:	8a03      	ldrh	r3, [r0, #16]
  
  itenable = TIMx->DIER & TIM_IT;
 80014c0:	8982      	ldrh	r2, [r0, #12]
  if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
 80014c2:	ea11 0003 	ands.w	r0, r1, r3
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_IT(TIM_IT));
   
  itstatus = TIMx->SR & TIM_IT;
  
  itenable = TIMx->DIER & TIM_IT;
 80014c6:	b292      	uxth	r2, r2
  if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
 80014c8:	d003      	beq.n	80014d2 <TIM_GetITStatus+0x14>
 80014ca:	4211      	tst	r1, r2
  {
    bitstatus = SET;
 80014cc:	bf0c      	ite	eq
 80014ce:	2000      	moveq	r0, #0
 80014d0:	2001      	movne	r0, #1
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 80014d2:	4770      	bx	lr

080014d4 <TIM_ClearITPendingBit>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_IT(TIM_IT));
  /* Clear the IT pending Bit */
  TIMx->SR = (uint16_t)~TIM_IT;
 80014d4:	43c9      	mvns	r1, r1
 80014d6:	b28a      	uxth	r2, r1
 80014d8:	8202      	strh	r2, [r0, #16]
 80014da:	4770      	bx	lr

080014dc <UINT32_TO_STREAM_f>:
//
//*****************************************************************************

unsigned char* UINT32_TO_STREAM_f (unsigned char *p, unsigned long u32)
{
	*(p)++ = (unsigned char)(u32);
 80014dc:	7001      	strb	r1, [r0, #0]
	*(p)++ = (unsigned char)((u32) >> 8);
 80014de:	0a0b      	lsrs	r3, r1, #8
	*(p)++ = (unsigned char)((u32) >> 16);
 80014e0:	0c0a      	lsrs	r2, r1, #16
	*(p)++ = (unsigned char)((u32) >> 24);
 80014e2:	0e09      	lsrs	r1, r1, #24
//*****************************************************************************

unsigned char* UINT32_TO_STREAM_f (unsigned char *p, unsigned long u32)
{
	*(p)++ = (unsigned char)(u32);
	*(p)++ = (unsigned char)((u32) >> 8);
 80014e4:	7043      	strb	r3, [r0, #1]
	*(p)++ = (unsigned char)((u32) >> 16);
 80014e6:	7082      	strb	r2, [r0, #2]
	*(p)++ = (unsigned char)((u32) >> 24);
 80014e8:	70c1      	strb	r1, [r0, #3]
	return p;
}
 80014ea:	3004      	adds	r0, #4
 80014ec:	4770      	bx	lr

080014ee <UINT16_TO_STREAM_f>:
//
//*****************************************************************************

unsigned char* UINT16_TO_STREAM_f (unsigned char *p, unsigned short u16)
{
	*(p)++ = (unsigned char)(u16);
 80014ee:	7001      	strb	r1, [r0, #0]
	*(p)++ = (unsigned char)((u16) >> 8);
 80014f0:	0a09      	lsrs	r1, r1, #8
 80014f2:	7041      	strb	r1, [r0, #1]
	return p;
}
 80014f4:	3002      	adds	r0, #2
 80014f6:	4770      	bx	lr

080014f8 <STREAM_TO_UINT16_f>:
//*****************************************************************************

unsigned short STREAM_TO_UINT16_f(char* p, unsigned short offset)
{
        return (unsigned short)((unsigned short)((unsigned short)
								(*(p + offset + 1)) << 8) + (unsigned short)(*(p + offset)));
 80014f8:	1843      	adds	r3, r0, r1
//
//*****************************************************************************

unsigned short STREAM_TO_UINT16_f(char* p, unsigned short offset)
{
        return (unsigned short)((unsigned short)((unsigned short)
 80014fa:	785a      	ldrb	r2, [r3, #1]
 80014fc:	5c40      	ldrb	r0, [r0, r1]
 80014fe:	eb00 2102 	add.w	r1, r0, r2, lsl #8
								(*(p + offset + 1)) << 8) + (unsigned short)(*(p + offset)));
}
 8001502:	b288      	uxth	r0, r1
 8001504:	4770      	bx	lr

08001506 <STREAM_TO_UINT32_f>:
//!                       32 bit in little endian format.
//
//*****************************************************************************

unsigned long STREAM_TO_UINT32_f(char* p, unsigned short offset)
{
 8001506:	b510      	push	{r4, lr}
        return (unsigned long)((unsigned long)((unsigned long)
							 (*(p + offset + 3)) << 24) + (unsigned long)((unsigned long)
 8001508:	1843      	adds	r3, r0, r1
 800150a:	789a      	ldrb	r2, [r3, #2]
//
//*****************************************************************************

unsigned long STREAM_TO_UINT32_f(char* p, unsigned short offset)
{
        return (unsigned long)((unsigned long)((unsigned long)
 800150c:	78dc      	ldrb	r4, [r3, #3]
							 (*(p + offset + 3)) << 24) + (unsigned long)((unsigned long)
							 (*(p + offset + 2)) << 16) + (unsigned long)((unsigned long)
							 (*(p + offset + 1)) << 8) + (unsigned long)(*(p + offset)));
 800150e:	5c41      	ldrb	r1, [r0, r1]
//*****************************************************************************

unsigned long STREAM_TO_UINT32_f(char* p, unsigned short offset)
{
        return (unsigned long)((unsigned long)((unsigned long)
							 (*(p + offset + 3)) << 24) + (unsigned long)((unsigned long)
 8001510:	0412      	lsls	r2, r2, #16
 8001512:	eb02 6204 	add.w	r2, r2, r4, lsl #24
							 (*(p + offset + 2)) << 16) + (unsigned long)((unsigned long)
 8001516:	7858      	ldrb	r0, [r3, #1]
 8001518:	1852      	adds	r2, r2, r1
							 (*(p + offset + 1)) << 8) + (unsigned long)(*(p + offset)));
}
 800151a:	eb02 2000 	add.w	r0, r2, r0, lsl #8
 800151e:	bd10      	pop	{r4, pc}

08001520 <hci_unsol_handle_patch_request>:
//!
//!  @brief   Handle unsolicited event from type patch request
//
//*****************************************************************************
void hci_unsol_handle_patch_request(char *event_hdr)
{
 8001520:	b573      	push	{r0, r1, r4, r5, r6, lr}
	char *params = (char *)(event_hdr) + HCI_EVENT_HEADER_SIZE;
	unsigned long ucLength = 0;
	char *patch;
	
	switch (*params)
 8001522:	7944      	ldrb	r4, [r0, #5]
//
//*****************************************************************************
void hci_unsol_handle_patch_request(char *event_hdr)
{
	char *params = (char *)(event_hdr) + HCI_EVENT_HEADER_SIZE;
	unsigned long ucLength = 0;
 8001524:	2300      	movs	r3, #0
	char *patch;
	
	switch (*params)
 8001526:	2c02      	cmp	r4, #2
//
//*****************************************************************************
void hci_unsol_handle_patch_request(char *event_hdr)
{
	char *params = (char *)(event_hdr) + HCI_EVENT_HEADER_SIZE;
	unsigned long ucLength = 0;
 8001528:	9301      	str	r3, [sp, #4]
	char *patch;
	
	switch (*params)
 800152a:	d00f      	beq.n	800154c <hci_unsol_handle_patch_request+0x2c>
 800152c:	2c03      	cmp	r4, #3
 800152e:	d019      	beq.n	8001564 <hci_unsol_handle_patch_request+0x44>
 8001530:	2c01      	cmp	r4, #1
 8001532:	d12b      	bne.n	800158c <hci_unsol_handle_patch_request+0x6c>
	{
	case HCI_EVENT_PATCHES_DRV_REQ:
		
		if (tSLInformation.sDriverPatches)
 8001534:	4d16      	ldr	r5, [pc, #88]	; (8001590 <hci_unsol_handle_patch_request+0x70>)
 8001536:	6928      	ldr	r0, [r5, #16]
 8001538:	462e      	mov	r6, r5
 800153a:	b120      	cbz	r0, 8001546 <hci_unsol_handle_patch_request+0x26>
		{
			patch = tSLInformation.sDriverPatches(&ucLength);
 800153c:	6929      	ldr	r1, [r5, #16]
 800153e:	a801      	add	r0, sp, #4
 8001540:	4788      	blx	r1
			
			if (patch)
 8001542:	4602      	mov	r2, r0
 8001544:	b9b8      	cbnz	r0, 8001576 <hci_unsol_handle_patch_request+0x56>
				return;
			}
		}
		
		// Send 0 length Patches response event
		hci_patch_send(HCI_EVENT_PATCHES_DRV_REQ, 
 8001546:	68b1      	ldr	r1, [r6, #8]
 8001548:	2001      	movs	r0, #1
 800154a:	e01b      	b.n	8001584 <hci_unsol_handle_patch_request+0x64>
									 tSLInformation.pucTxCommandBuffer, 0, 0);
		break;
		
	case HCI_EVENT_PATCHES_FW_REQ:
		
		if (tSLInformation.sFWPatches)
 800154c:	4d10      	ldr	r5, [pc, #64]	; (8001590 <hci_unsol_handle_patch_request+0x70>)
 800154e:	68e8      	ldr	r0, [r5, #12]
 8001550:	462e      	mov	r6, r5
 8001552:	b120      	cbz	r0, 800155e <hci_unsol_handle_patch_request+0x3e>
		{
			patch = tSLInformation.sFWPatches(&ucLength);
 8001554:	68e9      	ldr	r1, [r5, #12]
 8001556:	a801      	add	r0, sp, #4
 8001558:	4788      	blx	r1
			
			// Build and send a patch
			if (patch)
 800155a:	4602      	mov	r2, r0
 800155c:	b958      	cbnz	r0, 8001576 <hci_unsol_handle_patch_request+0x56>
				return;
			}
		}
		
		// Send 0 length Patches response event
		hci_patch_send(HCI_EVENT_PATCHES_FW_REQ, 
 800155e:	68b1      	ldr	r1, [r6, #8]
 8001560:	2002      	movs	r0, #2
 8001562:	e00f      	b.n	8001584 <hci_unsol_handle_patch_request+0x64>
									 tSLInformation.pucTxCommandBuffer, 0, 0);
		break;
		
	case HCI_EVENT_PATCHES_BOOTLOAD_REQ:
		
		if (tSLInformation.sBootLoaderPatches)
 8001564:	4d0a      	ldr	r5, [pc, #40]	; (8001590 <hci_unsol_handle_patch_request+0x70>)
 8001566:	696a      	ldr	r2, [r5, #20]
 8001568:	462e      	mov	r6, r5
 800156a:	b14a      	cbz	r2, 8001580 <hci_unsol_handle_patch_request+0x60>
		{
			patch = tSLInformation.sBootLoaderPatches(&ucLength);
 800156c:	696b      	ldr	r3, [r5, #20]
 800156e:	a801      	add	r0, sp, #4
 8001570:	4798      	blx	r3
			
			if (patch)
 8001572:	4602      	mov	r2, r0
 8001574:	b120      	cbz	r0, 8001580 <hci_unsol_handle_patch_request+0x60>
			{
				hci_patch_send(HCI_EVENT_PATCHES_BOOTLOAD_REQ,  
 8001576:	68a9      	ldr	r1, [r5, #8]
 8001578:	4620      	mov	r0, r4
 800157a:	f8bd 3004 	ldrh.w	r3, [sp, #4]
 800157e:	e003      	b.n	8001588 <hci_unsol_handle_patch_request+0x68>
				return;
			}
		}
		
		// Send 0 length Patches response event
		hci_patch_send(HCI_EVENT_PATCHES_BOOTLOAD_REQ, 
 8001580:	68b1      	ldr	r1, [r6, #8]
 8001582:	2003      	movs	r0, #3
 8001584:	2200      	movs	r2, #0
 8001586:	4613      	mov	r3, r2
 8001588:	f000 fb21 	bl	8001bce <hci_patch_send>
									 tSLInformation.pucTxCommandBuffer, 0, 0);
		break;
	}
}
 800158c:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}
 800158e:	bf00      	nop
 8001590:	200009b8 	.word	0x200009b8

08001594 <set_socket_active_status>:
//!                  accordingly  the global socket status
//
//*****************************************************************************
void set_socket_active_status(long Sd, long Status)
{
	if(M_IS_VALID_SD(Sd) && M_IS_VALID_STATUS(Status))
 8001594:	2807      	cmp	r0, #7
//!  @brief          Check if the socket ID and status are valid and set 
//!                  accordingly  the global socket status
//
//*****************************************************************************
void set_socket_active_status(long Sd, long Status)
{
 8001596:	b510      	push	{r4, lr}
	if(M_IS_VALID_SD(Sd) && M_IS_VALID_STATUS(Status))
 8001598:	d80c      	bhi.n	80015b4 <set_socket_active_status+0x20>
 800159a:	2901      	cmp	r1, #1
 800159c:	d80a      	bhi.n	80015b4 <set_socket_active_status+0x20>
	{
		socket_active_status &= ~(1 << Sd);      /* clean socket's mask */
 800159e:	2401      	movs	r4, #1
 80015a0:	fa04 f400 	lsl.w	r4, r4, r0
		socket_active_status |= (Status << Sd); /* set new socket's mask */
 80015a4:	fa01 f000 	lsl.w	r0, r1, r0
 80015a8:	4b03      	ldr	r3, [pc, #12]	; (80015b8 <set_socket_active_status+0x24>)
//*****************************************************************************
void set_socket_active_status(long Sd, long Status)
{
	if(M_IS_VALID_SD(Sd) && M_IS_VALID_STATUS(Status))
	{
		socket_active_status &= ~(1 << Sd);      /* clean socket's mask */
 80015aa:	681a      	ldr	r2, [r3, #0]
 80015ac:	ea22 0204 	bic.w	r2, r2, r4
		socket_active_status |= (Status << Sd); /* set new socket's mask */
 80015b0:	4302      	orrs	r2, r0
 80015b2:	601a      	str	r2, [r3, #0]
 80015b4:	bd10      	pop	{r4, pc}
 80015b6:	bf00      	nop
 80015b8:	2000006c 	.word	0x2000006c

080015bc <hci_unsol_event_handler>:
//!  @brief              Handle unsolicited events
//
//*****************************************************************************
long
hci_unsol_event_handler(char *event_hdr)
{
 80015bc:	b5f0      	push	{r4, r5, r6, r7, lr}
	char * data = NULL;
	long event_type;
	unsigned long NumberOfReleasedPackets;
	unsigned long NumberOfSentPackets;
	
	STREAM_TO_UINT16(event_hdr, HCI_EVENT_OPCODE_OFFSET,event_type);
 80015be:	2101      	movs	r1, #1
//!  @brief              Handle unsolicited events
//
//*****************************************************************************
long
hci_unsol_event_handler(char *event_hdr)
{
 80015c0:	b087      	sub	sp, #28
 80015c2:	4605      	mov	r5, r0
	char * data = NULL;
	long event_type;
	unsigned long NumberOfReleasedPackets;
	unsigned long NumberOfSentPackets;
	
	STREAM_TO_UINT16(event_hdr, HCI_EVENT_OPCODE_OFFSET,event_type);
 80015c4:	f7ff ff98 	bl	80014f8 <STREAM_TO_UINT16_f>
	
	if (event_type & HCI_EVNT_UNSOL_BASE)
 80015c8:	f400 4380 	and.w	r3, r0, #16384	; 0x4000
	char * data = NULL;
	long event_type;
	unsigned long NumberOfReleasedPackets;
	unsigned long NumberOfSentPackets;
	
	STREAM_TO_UINT16(event_hdr, HCI_EVENT_OPCODE_OFFSET,event_type);
 80015cc:	4604      	mov	r4, r0
	
	if (event_type & HCI_EVNT_UNSOL_BASE)
 80015ce:	b298      	uxth	r0, r3
 80015d0:	b350      	cbz	r0, 8001628 <hci_unsol_event_handler+0x6c>
	{
		switch(event_type)
 80015d2:	f5b4 4f82 	cmp.w	r4, #16640	; 0x4100
 80015d6:	d127      	bne.n	8001628 <hci_unsol_event_handler+0x6c>
	long temp, value;
	unsigned short i;
	unsigned short  pusNumberOfHandles=0;
	char *pReadPayload;
	
	STREAM_TO_UINT16((char *)pEvent,HCI_EVENT_HEADER_SIZE,pusNumberOfHandles);
 80015d8:	4628      	mov	r0, r5
 80015da:	2105      	movs	r1, #5
 80015dc:	f7ff ff8c 	bl	80014f8 <STREAM_TO_UINT16_f>
	pReadPayload = ((char *)pEvent +
									HCI_EVENT_HEADER_SIZE + sizeof(pusNumberOfHandles));	
	temp = 0;
	
	for(i = 0; i < pusNumberOfHandles ; i++)
 80015e0:	2600      	movs	r6, #0
	long temp, value;
	unsigned short i;
	unsigned short  pusNumberOfHandles=0;
	char *pReadPayload;
	
	STREAM_TO_UINT16((char *)pEvent,HCI_EVENT_HEADER_SIZE,pusNumberOfHandles);
 80015e2:	4607      	mov	r7, r0
	pReadPayload = ((char *)pEvent +
 80015e4:	3507      	adds	r5, #7
									HCI_EVENT_HEADER_SIZE + sizeof(pusNumberOfHandles));	
	temp = 0;
 80015e6:	4634      	mov	r4, r6
	
	for(i = 0; i < pusNumberOfHandles ; i++)
 80015e8:	42be      	cmp	r6, r7
 80015ea:	d008      	beq.n	80015fe <hci_unsol_event_handler+0x42>
	{
		STREAM_TO_UINT16(pReadPayload, FLOW_CONTROL_EVENT_FREE_BUFFS_OFFSET, value);
 80015ec:	4628      	mov	r0, r5
 80015ee:	2102      	movs	r1, #2
 80015f0:	f7ff ff82 	bl	80014f8 <STREAM_TO_UINT16_f>
	STREAM_TO_UINT16((char *)pEvent,HCI_EVENT_HEADER_SIZE,pusNumberOfHandles);
	pReadPayload = ((char *)pEvent +
									HCI_EVENT_HEADER_SIZE + sizeof(pusNumberOfHandles));	
	temp = 0;
	
	for(i = 0; i < pusNumberOfHandles ; i++)
 80015f4:	3601      	adds	r6, #1
	{
		STREAM_TO_UINT16(pReadPayload, FLOW_CONTROL_EVENT_FREE_BUFFS_OFFSET, value);
		temp += value;
 80015f6:	1824      	adds	r4, r4, r0
		pReadPayload += FLOW_CONTROL_EVENT_SIZE;  
 80015f8:	3504      	adds	r5, #4
	STREAM_TO_UINT16((char *)pEvent,HCI_EVENT_HEADER_SIZE,pusNumberOfHandles);
	pReadPayload = ((char *)pEvent +
									HCI_EVENT_HEADER_SIZE + sizeof(pusNumberOfHandles));	
	temp = 0;
	
	for(i = 0; i < pusNumberOfHandles ; i++)
 80015fa:	b2b6      	uxth	r6, r6
 80015fc:	e7f4      	b.n	80015e8 <hci_unsol_event_handler+0x2c>
		STREAM_TO_UINT16(pReadPayload, FLOW_CONTROL_EVENT_FREE_BUFFS_OFFSET, value);
		temp += value;
		pReadPayload += FLOW_CONTROL_EVENT_SIZE;  
	}
	
	tSLInformation.usNumberOfFreeBuffers += temp;
 80015fe:	4b6a      	ldr	r3, [pc, #424]	; (80017a8 <hci_unsol_event_handler+0x1ec>)
 8001600:	8e18      	ldrh	r0, [r3, #48]	; 0x30
 8001602:	1821      	adds	r1, r4, r0
 8001604:	b28a      	uxth	r2, r1
 8001606:	861a      	strh	r2, [r3, #48]	; 0x30
	tSLInformation.NumberOfReleasedPackets += temp;
 8001608:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
 800160a:	1824      	adds	r4, r4, r0
 800160c:	63dc      	str	r4, [r3, #60]	; 0x3c
	
		case HCI_EVNT_DATA_UNSOL_FREE_BUFF:
			{
				hci_event_unsol_flowcontrol_handler(event_hdr);
				
				NumberOfReleasedPackets = tSLInformation.NumberOfReleasedPackets;
 800160e:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
				NumberOfSentPackets = tSLInformation.NumberOfSentPackets;
 8001610:	6b9a      	ldr	r2, [r3, #56]	; 0x38
								
				if (NumberOfReleasedPackets == NumberOfSentPackets)
 8001612:	4291      	cmp	r1, r2
 8001614:	f040 80c2 	bne.w	800179c <hci_unsol_event_handler+0x1e0>
				{
					if (tSLInformation.InformHostOnTxComplete)
 8001618:	f893 0040 	ldrb.w	r0, [r3, #64]	; 0x40
 800161c:	2800      	cmp	r0, #0
 800161e:	f000 80bd 	beq.w	800179c <hci_unsol_event_handler+0x1e0>
					{
						tSLInformation.sWlanCB(HCI_EVENT_CC3000_CAN_SHUT_DOWN, NULL, 0);
 8001622:	699b      	ldr	r3, [r3, #24]
 8001624:	2099      	movs	r0, #153	; 0x99
 8001626:	e092      	b.n	800174e <hci_unsol_event_handler+0x192>
				
			}
		}
	}
	
	if(event_type & HCI_EVNT_WLAN_UNSOL_BASE)
 8001628:	f424 41ff 	bic.w	r1, r4, #32640	; 0x7f80
 800162c:	f021 027f 	bic.w	r2, r1, #127	; 0x7f
 8001630:	b293      	uxth	r3, r2
 8001632:	2b00      	cmp	r3, #0
 8001634:	f000 808f 	beq.w	8001756 <hci_unsol_event_handler+0x19a>
	{           
		switch(event_type)
 8001638:	f248 0310 	movw	r3, #32784	; 0x8010
 800163c:	429c      	cmp	r4, r3
 800163e:	d01e      	beq.n	800167e <hci_unsol_event_handler+0xc2>
 8001640:	d80a      	bhi.n	8001658 <hci_unsol_event_handler+0x9c>
 8001642:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
 8001646:	f240 80ab 	bls.w	80017a0 <hci_unsol_event_handler+0x1e4>
 800164a:	f248 0002 	movw	r0, #32770	; 0x8002
 800164e:	4284      	cmp	r4, r0
 8001650:	d978      	bls.n	8001744 <hci_unsol_event_handler+0x188>
 8001652:	1c81      	adds	r1, r0, #2
 8001654:	428c      	cmp	r4, r1
 8001656:	e00f      	b.n	8001678 <hci_unsol_event_handler+0xbc>
 8001658:	f248 0280 	movw	r2, #32896	; 0x8080
 800165c:	4294      	cmp	r4, r2
 800165e:	d071      	beq.n	8001744 <hci_unsol_event_handler+0x188>
 8001660:	d805      	bhi.n	800166e <hci_unsol_event_handler+0xb2>
 8001662:	f248 0340 	movw	r3, #32832	; 0x8040
 8001666:	429c      	cmp	r4, r3
 8001668:	f040 809a 	bne.w	80017a0 <hci_unsol_event_handler+0x1e4>
 800166c:	e047      	b.n	80016fe <hci_unsol_event_handler+0x142>
 800166e:	f5b4 4f02 	cmp.w	r4, #33280	; 0x8200
 8001672:	d067      	beq.n	8001744 <hci_unsol_event_handler+0x188>
 8001674:	f5b4 4f08 	cmp.w	r4, #34816	; 0x8800
 8001678:	f040 8092 	bne.w	80017a0 <hci_unsol_event_handler+0x1e4>
 800167c:	e062      	b.n	8001744 <hci_unsol_event_handler+0x188>
 800167e:	2200      	movs	r2, #0
//!
//!  @brief              Handle unsolicited events
//
//*****************************************************************************
long
hci_unsol_event_handler(char *event_hdr)
 8001680:	18a8      	adds	r0, r5, r2
				unsigned char *recParams = params;
				
				data = (char*)(event_hdr) + HCI_EVENT_HEADER_SIZE;
				
				//Read IP address
				STREAM_TO_STREAM(data,recParams,NETAPP_IPCONFIG_IP_LENGTH);
 8001682:	7941      	ldrb	r1, [r0, #5]
 8001684:	f80d 1002 	strb.w	r1, [sp, r2]
 8001688:	3201      	adds	r2, #1
 800168a:	2a04      	cmp	r2, #4
 800168c:	d1f8      	bne.n	8001680 <hci_unsol_event_handler+0xc4>
				data += 4;
				//Read subnet
				STREAM_TO_STREAM(data,recParams,NETAPP_IPCONFIG_IP_LENGTH);
 800168e:	7a6b      	ldrb	r3, [r5, #9]
 8001690:	7aa8      	ldrb	r0, [r5, #10]
 8001692:	7ae9      	ldrb	r1, [r5, #11]
 8001694:	7b2a      	ldrb	r2, [r5, #12]
 8001696:	f88d 3004 	strb.w	r3, [sp, #4]
 800169a:	f88d 0005 	strb.w	r0, [sp, #5]
 800169e:	f88d 1006 	strb.w	r1, [sp, #6]
 80016a2:	f88d 2007 	strb.w	r2, [sp, #7]
				data += 4;
 80016a6:	f105 000d 	add.w	r0, r5, #13
 80016aa:	2300      	movs	r3, #0
//!
//!  @brief              Handle unsolicited events
//
//*****************************************************************************
long
hci_unsol_event_handler(char *event_hdr)
 80016ac:	a906      	add	r1, sp, #24
 80016ae:	18ca      	adds	r2, r1, r3
				data += 4;
				//Read subnet
				STREAM_TO_STREAM(data,recParams,NETAPP_IPCONFIG_IP_LENGTH);
				data += 4;
				//Read default GW
				STREAM_TO_STREAM(data,recParams,NETAPP_IPCONFIG_IP_LENGTH); 
 80016b0:	5cc1      	ldrb	r1, [r0, r3]
 80016b2:	3301      	adds	r3, #1
 80016b4:	2b04      	cmp	r3, #4
 80016b6:	f802 1c10 	strb.w	r1, [r2, #-16]
 80016ba:	d1f7      	bne.n	80016ac <hci_unsol_event_handler+0xf0>
				data += 4;
 80016bc:	f105 0011 	add.w	r0, r5, #17
 80016c0:	2300      	movs	r3, #0
//!
//!  @brief              Handle unsolicited events
//
//*****************************************************************************
long
hci_unsol_event_handler(char *event_hdr)
 80016c2:	aa06      	add	r2, sp, #24
 80016c4:	18d2      	adds	r2, r2, r3
				data += 4;
				//Read default GW
				STREAM_TO_STREAM(data,recParams,NETAPP_IPCONFIG_IP_LENGTH); 
				data += 4;
				//Read DHCP server  
				STREAM_TO_STREAM(data,recParams,NETAPP_IPCONFIG_IP_LENGTH);     
 80016c6:	5cc1      	ldrb	r1, [r0, r3]
 80016c8:	3301      	adds	r3, #1
 80016ca:	2b04      	cmp	r3, #4
 80016cc:	f802 1c0c 	strb.w	r1, [r2, #-12]
 80016d0:	d1f7      	bne.n	80016c2 <hci_unsol_event_handler+0x106>
				data += 4;
 80016d2:	f105 0015 	add.w	r0, r5, #21
 80016d6:	2300      	movs	r3, #0
//!
//!  @brief              Handle unsolicited events
//
//*****************************************************************************
long
hci_unsol_event_handler(char *event_hdr)
 80016d8:	aa00      	add	r2, sp, #0
 80016da:	18d2      	adds	r2, r2, r3
				data += 4;
				//Read DHCP server  
				STREAM_TO_STREAM(data,recParams,NETAPP_IPCONFIG_IP_LENGTH);     
				data += 4;
				//Read DNS server  
				STREAM_TO_STREAM(data,recParams,NETAPP_IPCONFIG_IP_LENGTH); 
 80016dc:	5cc1      	ldrb	r1, [r0, r3]
 80016de:	3301      	adds	r3, #1
 80016e0:	2b04      	cmp	r3, #4
 80016e2:	7411      	strb	r1, [r2, #16]
 80016e4:	d1f8      	bne.n	80016d8 <hci_unsol_event_handler+0x11c>
				// read the status
				STREAM_TO_UINT8(event_hdr, HCI_EVENT_STATUS_OFFSET, *recParams);


				if( tSLInformation.sWlanCB )
 80016e6:	4930      	ldr	r1, [pc, #192]	; (80017a8 <hci_unsol_event_handler+0x1ec>)
				STREAM_TO_STREAM(data,recParams,NETAPP_IPCONFIG_IP_LENGTH);     
				data += 4;
				//Read DNS server  
				STREAM_TO_STREAM(data,recParams,NETAPP_IPCONFIG_IP_LENGTH); 
				// read the status
				STREAM_TO_UINT8(event_hdr, HCI_EVENT_STATUS_OFFSET, *recParams);
 80016e8:	7928      	ldrb	r0, [r5, #4]


				if( tSLInformation.sWlanCB )
 80016ea:	698a      	ldr	r2, [r1, #24]
				STREAM_TO_STREAM(data,recParams,NETAPP_IPCONFIG_IP_LENGTH);     
				data += 4;
				//Read DNS server  
				STREAM_TO_STREAM(data,recParams,NETAPP_IPCONFIG_IP_LENGTH); 
				// read the status
				STREAM_TO_UINT8(event_hdr, HCI_EVENT_STATUS_OFFSET, *recParams);
 80016ec:	f88d 0014 	strb.w	r0, [sp, #20]


				if( tSLInformation.sWlanCB )
 80016f0:	2a00      	cmp	r2, #0
 80016f2:	d053      	beq.n	800179c <hci_unsol_event_handler+0x1e0>
				{
					tSLInformation.sWlanCB(event_type, (char *)params, sizeof(params));
 80016f4:	698b      	ldr	r3, [r1, #24]
 80016f6:	4620      	mov	r0, r4
 80016f8:	4669      	mov	r1, sp
 80016fa:	2215      	movs	r2, #21
 80016fc:	e029      	b.n	8001752 <hci_unsol_event_handler+0x196>
			break;
			
		case HCI_EVNT_WLAN_ASYNC_PING_REPORT:
			{
				netapp_pingreport_args_t params;			
				data = (char*)(event_hdr) + HCI_EVENT_HEADER_SIZE;			
 80016fe:	3505      	adds	r5, #5
				STREAM_TO_UINT32(data, NETAPP_PING_PACKETS_SENT_OFFSET, params.packets_sent);			
 8001700:	2100      	movs	r1, #0
 8001702:	4628      	mov	r0, r5
 8001704:	f7ff feff 	bl	8001506 <STREAM_TO_UINT32_f>
				STREAM_TO_UINT32(data, NETAPP_PING_PACKETS_RCVD_OFFSET, params.packets_received);			
 8001708:	2104      	movs	r1, #4
			
		case HCI_EVNT_WLAN_ASYNC_PING_REPORT:
			{
				netapp_pingreport_args_t params;			
				data = (char*)(event_hdr) + HCI_EVENT_HEADER_SIZE;			
				STREAM_TO_UINT32(data, NETAPP_PING_PACKETS_SENT_OFFSET, params.packets_sent);			
 800170a:	9000      	str	r0, [sp, #0]
				STREAM_TO_UINT32(data, NETAPP_PING_PACKETS_RCVD_OFFSET, params.packets_received);			
 800170c:	4628      	mov	r0, r5
 800170e:	f7ff fefa 	bl	8001506 <STREAM_TO_UINT32_f>
				STREAM_TO_UINT32(data, NETAPP_PING_MIN_RTT_OFFSET, params.min_round_time);		
 8001712:	2108      	movs	r1, #8
		case HCI_EVNT_WLAN_ASYNC_PING_REPORT:
			{
				netapp_pingreport_args_t params;			
				data = (char*)(event_hdr) + HCI_EVENT_HEADER_SIZE;			
				STREAM_TO_UINT32(data, NETAPP_PING_PACKETS_SENT_OFFSET, params.packets_sent);			
				STREAM_TO_UINT32(data, NETAPP_PING_PACKETS_RCVD_OFFSET, params.packets_received);			
 8001714:	9001      	str	r0, [sp, #4]
				STREAM_TO_UINT32(data, NETAPP_PING_MIN_RTT_OFFSET, params.min_round_time);		
 8001716:	4628      	mov	r0, r5
 8001718:	f7ff fef5 	bl	8001506 <STREAM_TO_UINT32_f>
				STREAM_TO_UINT32(data, NETAPP_PING_MAX_RTT_OFFSET, params.max_round_time);	
 800171c:	210c      	movs	r1, #12
			{
				netapp_pingreport_args_t params;			
				data = (char*)(event_hdr) + HCI_EVENT_HEADER_SIZE;			
				STREAM_TO_UINT32(data, NETAPP_PING_PACKETS_SENT_OFFSET, params.packets_sent);			
				STREAM_TO_UINT32(data, NETAPP_PING_PACKETS_RCVD_OFFSET, params.packets_received);			
				STREAM_TO_UINT32(data, NETAPP_PING_MIN_RTT_OFFSET, params.min_round_time);		
 800171e:	9002      	str	r0, [sp, #8]
				STREAM_TO_UINT32(data, NETAPP_PING_MAX_RTT_OFFSET, params.max_round_time);	
 8001720:	4628      	mov	r0, r5
 8001722:	f7ff fef0 	bl	8001506 <STREAM_TO_UINT32_f>
				STREAM_TO_UINT32(data, NETAPP_PING_AVG_RTT_OFFSET, params.avg_round_time);
 8001726:	2110      	movs	r1, #16
				netapp_pingreport_args_t params;			
				data = (char*)(event_hdr) + HCI_EVENT_HEADER_SIZE;			
				STREAM_TO_UINT32(data, NETAPP_PING_PACKETS_SENT_OFFSET, params.packets_sent);			
				STREAM_TO_UINT32(data, NETAPP_PING_PACKETS_RCVD_OFFSET, params.packets_received);			
				STREAM_TO_UINT32(data, NETAPP_PING_MIN_RTT_OFFSET, params.min_round_time);		
				STREAM_TO_UINT32(data, NETAPP_PING_MAX_RTT_OFFSET, params.max_round_time);	
 8001728:	9003      	str	r0, [sp, #12]
				STREAM_TO_UINT32(data, NETAPP_PING_AVG_RTT_OFFSET, params.avg_round_time);
 800172a:	4628      	mov	r0, r5
 800172c:	f7ff feeb 	bl	8001506 <STREAM_TO_UINT32_f>
 8001730:	9004      	str	r0, [sp, #16]
				
				if( tSLInformation.sWlanCB )
 8001732:	481d      	ldr	r0, [pc, #116]	; (80017a8 <hci_unsol_event_handler+0x1ec>)
 8001734:	6981      	ldr	r1, [r0, #24]
 8001736:	2900      	cmp	r1, #0
 8001738:	d030      	beq.n	800179c <hci_unsol_event_handler+0x1e0>
				{
					tSLInformation.sWlanCB(event_type, (char *)&params, sizeof(params));
 800173a:	6983      	ldr	r3, [r0, #24]
 800173c:	4669      	mov	r1, sp
 800173e:	4620      	mov	r0, r4
 8001740:	2214      	movs	r2, #20
 8001742:	e006      	b.n	8001752 <hci_unsol_event_handler+0x196>
				}
			}
			break;
		case HCI_EVNT_BSD_TCP_CLOSE_WAIT:
			{
				if( tSLInformation.sWlanCB )
 8001744:	4b18      	ldr	r3, [pc, #96]	; (80017a8 <hci_unsol_event_handler+0x1ec>)
 8001746:	699a      	ldr	r2, [r3, #24]
 8001748:	b342      	cbz	r2, 800179c <hci_unsol_event_handler+0x1e0>
				{
					tSLInformation.sWlanCB(event_type, NULL, 0);
 800174a:	699b      	ldr	r3, [r3, #24]
 800174c:	4620      	mov	r0, r4
 800174e:	2100      	movs	r1, #0
 8001750:	460a      	mov	r2, r1
 8001752:	4798      	blx	r3
 8001754:	e022      	b.n	800179c <hci_unsol_event_handler+0x1e0>
			return (0);
		}
		return(1);
	}
	
	if ((event_type == HCI_EVNT_SEND) || (event_type == HCI_EVNT_SENDTO)
 8001756:	f241 0003 	movw	r0, #4099	; 0x1003
 800175a:	4284      	cmp	r4, r0
 800175c:	d005      	beq.n	800176a <hci_unsol_event_handler+0x1ae>
 800175e:	300c      	adds	r0, #12
 8001760:	4284      	cmp	r4, r0
 8001762:	d002      	beq.n	800176a <hci_unsol_event_handler+0x1ae>
			|| (event_type == HCI_EVNT_WRITE))
 8001764:	1e41      	subs	r1, r0, #1
 8001766:	428c      	cmp	r4, r1
 8001768:	d11a      	bne.n	80017a0 <hci_unsol_event_handler+0x1e4>
	{
                char *pArg;
                long status;
                
                pArg = M_BSD_RESP_PARAMS_OFFSET(event_hdr);
 800176a:	1d6c      	adds	r4, r5, #5
                STREAM_TO_UINT32(pArg, BSD_RSP_PARAMS_STATUS_OFFSET,status);
 800176c:	2104      	movs	r1, #4
 800176e:	4620      	mov	r0, r4
 8001770:	f7ff fec9 	bl	8001506 <STREAM_TO_UINT32_f>
                
                if (ERROR_SOCKET_INACTIVE == status)
 8001774:	3039      	adds	r0, #57	; 0x39
 8001776:	d113      	bne.n	80017a0 <hci_unsol_event_handler+0x1e4>
                {
                    // The only synchronous event that can come from SL device in form of 
                    // command complete is "Command Complete" on data sent, in case SL device 
                    // was unable to transmit
                    STREAM_TO_UINT8(event_hdr, HCI_EVENT_STATUS_OFFSET, tSLInformation.slTransmitDataError);
 8001778:	792d      	ldrb	r5, [r5, #4]
 800177a:	4a0b      	ldr	r2, [pc, #44]	; (80017a8 <hci_unsol_event_handler+0x1ec>)
void
update_socket_active_status(char *resp_params)
{
	long status, sd;
	
	STREAM_TO_UINT32(resp_params, BSD_RSP_PARAMS_SOCKET_OFFSET,sd);
 800177c:	2100      	movs	r1, #0
 800177e:	4620      	mov	r0, r4
                if (ERROR_SOCKET_INACTIVE == status)
                {
                    // The only synchronous event that can come from SL device in form of 
                    // command complete is "Command Complete" on data sent, in case SL device 
                    // was unable to transmit
                    STREAM_TO_UINT8(event_hdr, HCI_EVENT_STATUS_OFFSET, tSLInformation.slTransmitDataError);
 8001780:	62d5      	str	r5, [r2, #44]	; 0x2c
void
update_socket_active_status(char *resp_params)
{
	long status, sd;
	
	STREAM_TO_UINT32(resp_params, BSD_RSP_PARAMS_SOCKET_OFFSET,sd);
 8001782:	f7ff fec0 	bl	8001506 <STREAM_TO_UINT32_f>
	STREAM_TO_UINT32(resp_params, BSD_RSP_PARAMS_STATUS_OFFSET,status);
 8001786:	2104      	movs	r1, #4
void
update_socket_active_status(char *resp_params)
{
	long status, sd;
	
	STREAM_TO_UINT32(resp_params, BSD_RSP_PARAMS_SOCKET_OFFSET,sd);
 8001788:	4605      	mov	r5, r0
	STREAM_TO_UINT32(resp_params, BSD_RSP_PARAMS_STATUS_OFFSET,status);
 800178a:	4620      	mov	r0, r4
 800178c:	f7ff febb 	bl	8001506 <STREAM_TO_UINT32_f>
	
	if(ERROR_SOCKET_INACTIVE == status)
 8001790:	3039      	adds	r0, #57	; 0x39
 8001792:	d103      	bne.n	800179c <hci_unsol_event_handler+0x1e0>
	{
		set_socket_active_status(sd, SOCKET_STATUS_INACTIVE);
 8001794:	4628      	mov	r0, r5
 8001796:	2101      	movs	r1, #1
 8001798:	f7ff fefc 	bl	8001594 <set_socket_active_status>
                    // command complete is "Command Complete" on data sent, in case SL device 
                    // was unable to transmit
                    STREAM_TO_UINT8(event_hdr, HCI_EVENT_STATUS_OFFSET, tSLInformation.slTransmitDataError);
                    update_socket_active_status(M_BSD_RESP_PARAMS_OFFSET(event_hdr));
                    
                    return (1);
 800179c:	2001      	movs	r0, #1
 800179e:	e000      	b.n	80017a2 <hci_unsol_event_handler+0x1e6>
			}
			break;
			
		//'default' case which means "event not supported" 	
		default: 
			return (0);
 80017a0:	2000      	movs	r0, #0
                else
                    return (0);
	}
	
	return(0);
}
 80017a2:	b007      	add	sp, #28
 80017a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80017a6:	bf00      	nop
 80017a8:	200009b8 	.word	0x200009b8

080017ac <hci_unsolicited_event_handler>:
//!                  corresponding event handler.
//
//*****************************************************************************
long
hci_unsolicited_event_handler(void)
{
 80017ac:	b538      	push	{r3, r4, r5, lr}
	unsigned long   res = 0;
	unsigned char *pucReceivedData;
	
	if (tSLInformation.usEventOrDataReceived != 0)
 80017ae:	4c0a      	ldr	r4, [pc, #40]	; (80017d8 <hci_unsolicited_event_handler+0x2c>)
 80017b0:	8863      	ldrh	r3, [r4, #2]
 80017b2:	b298      	uxth	r0, r3
 80017b4:	b908      	cbnz	r0, 80017ba <hci_unsolicited_event_handler+0xe>
//
//*****************************************************************************
long
hci_unsolicited_event_handler(void)
{
	unsigned long   res = 0;
 80017b6:	2000      	movs	r0, #0
 80017b8:	bd38      	pop	{r3, r4, r5, pc}
	unsigned char *pucReceivedData;
	
	if (tSLInformation.usEventOrDataReceived != 0)
	{
		pucReceivedData = (tSLInformation.pucReceivedData);
 80017ba:	6860      	ldr	r0, [r4, #4]
		
		if (*pucReceivedData == HCI_TYPE_EVNT)
 80017bc:	7801      	ldrb	r1, [r0, #0]
 80017be:	2904      	cmp	r1, #4
 80017c0:	d1f9      	bne.n	80017b6 <hci_unsolicited_event_handler+0xa>
		{			
			
			// In case unsolicited event received - here the handling finished
			if (hci_unsol_event_handler((char *)pucReceivedData) == 1)
 80017c2:	f7ff fefb 	bl	80015bc <hci_unsol_event_handler>
 80017c6:	2801      	cmp	r0, #1
 80017c8:	4605      	mov	r5, r0
 80017ca:	d1f4      	bne.n	80017b6 <hci_unsolicited_event_handler+0xa>
			{
				
				// There was an unsolicited event received - we can release the buffer
				// and clean the event received 
				tSLInformation.usEventOrDataReceived = 0;
 80017cc:	2200      	movs	r2, #0
 80017ce:	8062      	strh	r2, [r4, #2]
				
				res = 1;
				SpiResumeSpi();
 80017d0:	f7fe fce6 	bl	80001a0 <SpiResumeSpi>
				
				// There was an unsolicited event received - we can release the buffer
				// and clean the event received 
				tSLInformation.usEventOrDataReceived = 0;
				
				res = 1;
 80017d4:	4628      	mov	r0, r5
			}
		}
	}
	
	return res;
}
 80017d6:	bd38      	pop	{r3, r4, r5, pc}
 80017d8:	200009b8 	.word	0x200009b8

080017dc <hci_event_handler>:
//*****************************************************************************

	
unsigned char *
hci_event_handler(void *pRetParams, unsigned char *from, unsigned char *fromlen)
{
 80017dc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80017e0:	4604      	mov	r4, r0
 80017e2:	4688      	mov	r8, r1
 80017e4:	4691      	mov	r9, r2
	unsigned char *pucReceivedData, ucArgsize;
	unsigned short usLength;
	unsigned char *pucReceivedParams;
	unsigned short usReceivedEventOpcode = 0;
 80017e6:	2500      	movs	r5, #0
  unsigned char *RetParams;
	
	
	while (1)
	{
		if (tSLInformation.usEventOrDataReceived != 0)
 80017e8:	4bbc      	ldr	r3, [pc, #752]	; (8001adc <hci_event_handler+0x300>)
 80017ea:	885a      	ldrh	r2, [r3, #2]
 80017ec:	b290      	uxth	r0, r2
 80017ee:	2800      	cmp	r0, #0
 80017f0:	d0fa      	beq.n	80017e8 <hci_event_handler+0xc>
		{				
			pucReceivedData = (tSLInformation.pucReceivedData);
 80017f2:	685e      	ldr	r6, [r3, #4]

			if (*pucReceivedData == HCI_TYPE_EVNT)
 80017f4:	7831      	ldrb	r1, [r6, #0]
 80017f6:	2904      	cmp	r1, #4
 80017f8:	f040 8172 	bne.w	8001ae0 <hci_event_handler+0x304>
			{
				// Event Received
				STREAM_TO_UINT16((char *)pucReceivedData, HCI_EVENT_OPCODE_OFFSET,
 80017fc:	4630      	mov	r0, r6
 80017fe:	2101      	movs	r1, #1
 8001800:	f7ff fe7a 	bl	80014f8 <STREAM_TO_UINT16_f>
 8001804:	4605      	mov	r5, r0
				pucReceivedParams = pucReceivedData + HCI_EVENT_HEADER_SIZE;		
				RecvParams = pucReceivedParams;
				RetParams = pRetParams;
				
				// In case unsolicited event received - here the handling finished
				if (hci_unsol_event_handler((char *)pucReceivedData) == 0)
 8001806:	4630      	mov	r0, r6
 8001808:	f7ff fed8 	bl	80015bc <hci_unsol_event_handler>
 800180c:	2800      	cmp	r0, #0
 800180e:	f040 815c 	bne.w	8001aca <hci_event_handler+0x2ee>
				{
					STREAM_TO_UINT8(pucReceivedData, HCI_DATA_LENGTH_OFFSET, usLength);
					
					switch(usReceivedEventOpcode)
 8001812:	f241 0307 	movw	r3, #4103	; 0x1007
			if (*pucReceivedData == HCI_TYPE_EVNT)
			{
				// Event Received
				STREAM_TO_UINT16((char *)pucReceivedData, HCI_EVENT_OPCODE_OFFSET,
												 usReceivedEventOpcode);
				pucReceivedParams = pucReceivedData + HCI_EVENT_HEADER_SIZE;		
 8001816:	1d77      	adds	r7, r6, #5
				// In case unsolicited event received - here the handling finished
				if (hci_unsol_event_handler((char *)pucReceivedData) == 0)
				{
					STREAM_TO_UINT8(pucReceivedData, HCI_DATA_LENGTH_OFFSET, usLength);
					
					switch(usReceivedEventOpcode)
 8001818:	429d      	cmp	r5, r3
 800181a:	d853      	bhi.n	80018c4 <hci_event_handler+0xe8>
 800181c:	1e5a      	subs	r2, r3, #1
 800181e:	4295      	cmp	r5, r2
 8001820:	f080 80ac 	bcs.w	800197c <hci_event_handler+0x1a0>
 8001824:	f240 2002 	movw	r0, #514	; 0x202
 8001828:	4285      	cmp	r5, r0
 800182a:	f000 80a7 	beq.w	800197c <hci_event_handler+0x1a0>
 800182e:	d814      	bhi.n	800185a <hci_event_handler+0x7e>
 8001830:	2d0c      	cmp	r5, #12
 8001832:	d809      	bhi.n	8001848 <hci_event_handler+0x6c>
 8001834:	2d08      	cmp	r5, #8
 8001836:	f080 80a1 	bcs.w	800197c <hci_event_handler+0x1a0>
 800183a:	2d00      	cmp	r5, #0
 800183c:	f000 8145 	beq.w	8001aca <hci_event_handler+0x2ee>
 8001840:	2d06      	cmp	r5, #6
 8001842:	f240 809b 	bls.w	800197c <hci_event_handler+0x1a0>
 8001846:	e0dd      	b.n	8001a04 <hci_event_handler+0x228>
 8001848:	2d0d      	cmp	r5, #13
 800184a:	f000 8094 	beq.w	8001976 <hci_event_handler+0x19a>
 800184e:	f240 2701 	movw	r7, #513	; 0x201
 8001852:	42bd      	cmp	r5, r7
 8001854:	f040 8139 	bne.w	8001aca <hci_event_handler+0x2ee>
 8001858:	e08d      	b.n	8001976 <hci_event_handler+0x19a>
 800185a:	f241 0202 	movw	r2, #4098	; 0x1002
 800185e:	4295      	cmp	r5, r2
 8001860:	d818      	bhi.n	8001894 <hci_event_handler+0xb8>
 8001862:	f5b5 5f80 	cmp.w	r5, #4096	; 0x1000
 8001866:	f200 8089 	bhi.w	800197c <hci_event_handler+0x1a0>
 800186a:	f5b5 7f01 	cmp.w	r5, #516	; 0x204
 800186e:	f240 8082 	bls.w	8001976 <hci_event_handler+0x19a>
 8001872:	f240 2107 	movw	r1, #519	; 0x207
 8001876:	428d      	cmp	r5, r1
 8001878:	f040 8127 	bne.w	8001aca <hci_event_handler+0x2ee>
														 ,*(unsigned long *)pRetParams);
						break;
						
					case HCI_EVNT_READ_SP_VERSION:
						
						STREAM_TO_UINT8(pucReceivedData, HCI_EVENT_STATUS_OFFSET
 800187c:	7933      	ldrb	r3, [r6, #4]
														,*(unsigned char *)pRetParams);
						pRetParams = ((char *)pRetParams) + 1;
						STREAM_TO_UINT32((char *)pucReceivedParams, 0, retValue32);
 800187e:	2100      	movs	r1, #0
														 ,*(unsigned long *)pRetParams);
						break;
						
					case HCI_EVNT_READ_SP_VERSION:
						
						STREAM_TO_UINT8(pucReceivedData, HCI_EVENT_STATUS_OFFSET
 8001880:	f804 3b01 	strb.w	r3, [r4], #1
														,*(unsigned char *)pRetParams);
						pRetParams = ((char *)pRetParams) + 1;
						STREAM_TO_UINT32((char *)pucReceivedParams, 0, retValue32);
 8001884:	4638      	mov	r0, r7
 8001886:	f7ff fe3e 	bl	8001506 <STREAM_TO_UINT32_f>
 800188a:	4601      	mov	r1, r0
						UINT32_TO_STREAM((unsigned char *)pRetParams, retValue32);				
 800188c:	4620      	mov	r0, r4
 800188e:	f7ff fe25 	bl	80014dc <UINT32_TO_STREAM_f>
						break;
 8001892:	e11a      	b.n	8001aca <hci_event_handler+0x2ee>
				// In case unsolicited event received - here the handling finished
				if (hci_unsol_event_handler((char *)pucReceivedData) == 0)
				{
					STREAM_TO_UINT8(pucReceivedData, HCI_DATA_LENGTH_OFFSET, usLength);
					
					switch(usReceivedEventOpcode)
 8001894:	f241 0004 	movw	r0, #4100	; 0x1004
 8001898:	4285      	cmp	r5, r0
 800189a:	f000 8089 	beq.w	80019b0 <hci_event_handler+0x1d4>
 800189e:	f240 80a0 	bls.w	80019e2 <hci_event_handler+0x206>
									,GET_HOST_BY_NAME_ADDR_OFFSET,*(unsigned long *)pRetParams);					
						break;
						
					case HCI_EVNT_ACCEPT:
						{
							STREAM_TO_UINT32((char *)pucReceivedParams,ACCEPT_SD_OFFSET
 80018a2:	4638      	mov	r0, r7
 80018a4:	2100      	movs	r1, #0
 80018a6:	f7ff fe2e 	bl	8001506 <STREAM_TO_UINT32_f>
															 ,*(unsigned long *)pRetParams);
							pRetParams = ((char *)pRetParams) + 4;
							STREAM_TO_UINT32((char *)pucReceivedParams
 80018aa:	2104      	movs	r1, #4
									,GET_HOST_BY_NAME_ADDR_OFFSET,*(unsigned long *)pRetParams);					
						break;
						
					case HCI_EVNT_ACCEPT:
						{
							STREAM_TO_UINT32((char *)pucReceivedParams,ACCEPT_SD_OFFSET
 80018ac:	6020      	str	r0, [r4, #0]
															 ,*(unsigned long *)pRetParams);
							pRetParams = ((char *)pRetParams) + 4;
							STREAM_TO_UINT32((char *)pucReceivedParams
 80018ae:	4638      	mov	r0, r7
 80018b0:	f7ff fe29 	bl	8001506 <STREAM_TO_UINT32_f>
 80018b4:	6060      	str	r0, [r4, #4]
										,ACCEPT_RETURN_STATUS_OFFSET,*(unsigned long *)pRetParams);
              pRetParams = ((char *)pRetParams) + 4; 
 80018b6:	3408      	adds	r4, #8
							
							//This argument returns in network order
							memcpy((unsigned char *)pRetParams, 
 80018b8:	f106 070d 	add.w	r7, r6, #13
 80018bc:	4622      	mov	r2, r4
 80018be:	f106 011d 	add.w	r1, r6, #29
 80018c2:	e06e      	b.n	80019a2 <hci_event_handler+0x1c6>
				// In case unsolicited event received - here the handling finished
				if (hci_unsol_event_handler((char *)pucReceivedData) == 0)
				{
					STREAM_TO_UINT8(pucReceivedData, HCI_DATA_LENGTH_OFFSET, usLength);
					
					switch(usReceivedEventOpcode)
 80018c4:	f241 0011 	movw	r0, #4113	; 0x1011
 80018c8:	4285      	cmp	r5, r0
 80018ca:	d054      	beq.n	8001976 <hci_event_handler+0x19a>
 80018cc:	d82c      	bhi.n	8001928 <hci_event_handler+0x14c>
 80018ce:	f241 020b 	movw	r2, #4107	; 0x100b
 80018d2:	4295      	cmp	r5, r2
 80018d4:	d052      	beq.n	800197c <hci_event_handler+0x1a0>
 80018d6:	d81c      	bhi.n	8001912 <hci_event_handler+0x136>
 80018d8:	f241 0109 	movw	r1, #4105	; 0x1009
 80018dc:	428d      	cmp	r5, r1
 80018de:	d04d      	beq.n	800197c <hci_event_handler+0x1a0>
 80018e0:	f200 808b 	bhi.w	80019fa <hci_event_handler+0x21e>
							break;
						}
						
					case HCI_EVNT_SELECT:
						{ 
							STREAM_TO_UINT32((char *)pucReceivedParams,SELECT_STATUS_OFFSET,*(unsigned long *)pRetParams);
 80018e4:	2100      	movs	r1, #0
 80018e6:	4638      	mov	r0, r7
 80018e8:	f7ff fe0d 	bl	8001506 <STREAM_TO_UINT32_f>
							pRetParams = ((char *)pRetParams) + 4;
							STREAM_TO_UINT32((char *)pucReceivedParams,SELECT_READFD_OFFSET,*(unsigned long *)pRetParams);
 80018ec:	2104      	movs	r1, #4
							break;
						}
						
					case HCI_EVNT_SELECT:
						{ 
							STREAM_TO_UINT32((char *)pucReceivedParams,SELECT_STATUS_OFFSET,*(unsigned long *)pRetParams);
 80018ee:	6020      	str	r0, [r4, #0]
							pRetParams = ((char *)pRetParams) + 4;
							STREAM_TO_UINT32((char *)pucReceivedParams,SELECT_READFD_OFFSET,*(unsigned long *)pRetParams);
 80018f0:	4638      	mov	r0, r7
 80018f2:	f7ff fe08 	bl	8001506 <STREAM_TO_UINT32_f>
							pRetParams = ((char *)pRetParams) + 4;
							STREAM_TO_UINT32((char *)pucReceivedParams,SELECT_WRITEFD_OFFSET,*(unsigned long *)pRetParams);
 80018f6:	2108      	movs	r1, #8
						
					case HCI_EVNT_SELECT:
						{ 
							STREAM_TO_UINT32((char *)pucReceivedParams,SELECT_STATUS_OFFSET,*(unsigned long *)pRetParams);
							pRetParams = ((char *)pRetParams) + 4;
							STREAM_TO_UINT32((char *)pucReceivedParams,SELECT_READFD_OFFSET,*(unsigned long *)pRetParams);
 80018f8:	6060      	str	r0, [r4, #4]
							pRetParams = ((char *)pRetParams) + 4;
							STREAM_TO_UINT32((char *)pucReceivedParams,SELECT_WRITEFD_OFFSET,*(unsigned long *)pRetParams);
 80018fa:	4638      	mov	r0, r7
 80018fc:	f7ff fe03 	bl	8001506 <STREAM_TO_UINT32_f>
							pRetParams = ((char *)pRetParams) + 4;
							STREAM_TO_UINT32((char *)pucReceivedParams,SELECT_EXFD_OFFSET,*(unsigned long *)pRetParams);			
 8001900:	210c      	movs	r1, #12
						{ 
							STREAM_TO_UINT32((char *)pucReceivedParams,SELECT_STATUS_OFFSET,*(unsigned long *)pRetParams);
							pRetParams = ((char *)pRetParams) + 4;
							STREAM_TO_UINT32((char *)pucReceivedParams,SELECT_READFD_OFFSET,*(unsigned long *)pRetParams);
							pRetParams = ((char *)pRetParams) + 4;
							STREAM_TO_UINT32((char *)pucReceivedParams,SELECT_WRITEFD_OFFSET,*(unsigned long *)pRetParams);
 8001902:	60a0      	str	r0, [r4, #8]
							pRetParams = ((char *)pRetParams) + 4;
							STREAM_TO_UINT32((char *)pucReceivedParams,SELECT_EXFD_OFFSET,*(unsigned long *)pRetParams);			
 8001904:	4638      	mov	r0, r7
 8001906:	f7ff fdfe 	bl	8001506 <STREAM_TO_UINT32_f>
							STREAM_TO_UINT32((char *)pucReceivedParams,SELECT_STATUS_OFFSET,*(unsigned long *)pRetParams);
							pRetParams = ((char *)pRetParams) + 4;
							STREAM_TO_UINT32((char *)pucReceivedParams,SELECT_READFD_OFFSET,*(unsigned long *)pRetParams);
							pRetParams = ((char *)pRetParams) + 4;
							STREAM_TO_UINT32((char *)pucReceivedParams,SELECT_WRITEFD_OFFSET,*(unsigned long *)pRetParams);
							pRetParams = ((char *)pRetParams) + 4;
 800190a:	f104 0a0c 	add.w	sl, r4, #12
							STREAM_TO_UINT32((char *)pucReceivedParams,SELECT_EXFD_OFFSET,*(unsigned long *)pRetParams);			
 800190e:	60e0      	str	r0, [r4, #12]
 8001910:	e0da      	b.n	8001ac8 <hci_event_handler+0x2ec>
				// In case unsolicited event received - here the handling finished
				if (hci_unsol_event_handler((char *)pucReceivedData) == 0)
				{
					STREAM_TO_UINT8(pucReceivedData, HCI_DATA_LENGTH_OFFSET, usLength);
					
					switch(usReceivedEventOpcode)
 8001912:	f241 000f 	movw	r0, #4111	; 0x100f
 8001916:	4285      	cmp	r5, r0
 8001918:	d063      	beq.n	80019e2 <hci_event_handler+0x206>
 800191a:	d835      	bhi.n	8001988 <hci_event_handler+0x1ac>
 800191c:	f241 020d 	movw	r2, #4109	; 0x100d
 8001920:	4295      	cmp	r5, r2
 8001922:	f040 80d2 	bne.w	8001aca <hci_event_handler+0x2ee>
 8001926:	e043      	b.n	80019b0 <hci_event_handler+0x1d4>
 8001928:	f242 0106 	movw	r1, #8198	; 0x2006
 800192c:	428d      	cmp	r5, r1
 800192e:	d022      	beq.n	8001976 <hci_event_handler+0x19a>
 8001930:	d808      	bhi.n	8001944 <hci_event_handler+0x168>
 8001932:	f5b5 5f00 	cmp.w	r5, #8192	; 0x2000
 8001936:	f240 80c8 	bls.w	8001aca <hci_event_handler+0x2ee>
 800193a:	f242 0304 	movw	r3, #8196	; 0x2004
 800193e:	429d      	cmp	r5, r3
 8001940:	d919      	bls.n	8001976 <hci_event_handler+0x19a>
 8001942:	e083      	b.n	8001a4c <hci_event_handler+0x270>
 8001944:	f242 0308 	movw	r3, #8200	; 0x2008
 8001948:	429d      	cmp	r5, r3
 800194a:	f0c0 80be 	bcc.w	8001aca <hci_event_handler+0x2ee>
 800194e:	1c58      	adds	r0, r3, #1
 8001950:	4285      	cmp	r5, r0
 8001952:	d910      	bls.n	8001976 <hci_event_handler+0x19a>
 8001954:	f244 020b 	movw	r2, #16395	; 0x400b
 8001958:	4295      	cmp	r5, r2
 800195a:	f040 80b6 	bne.w	8001aca <hci_event_handler+0x2ee>
					{		
					case HCI_CMND_READ_BUFFER_SIZE:
						{
							STREAM_TO_UINT8((char *)pucReceivedParams, 0, 
 800195e:	7971      	ldrb	r1, [r6, #5]
 8001960:	f8df a178 	ldr.w	sl, [pc, #376]	; 8001adc <hci_event_handler+0x300>
															tSLInformation.usNumberOfFreeBuffers);
							STREAM_TO_UINT16((char *)pucReceivedParams, 1, 
 8001964:	4638      	mov	r0, r7
					
					switch(usReceivedEventOpcode)
					{		
					case HCI_CMND_READ_BUFFER_SIZE:
						{
							STREAM_TO_UINT8((char *)pucReceivedParams, 0, 
 8001966:	f8aa 1030 	strh.w	r1, [sl, #48]	; 0x30
															tSLInformation.usNumberOfFreeBuffers);
							STREAM_TO_UINT16((char *)pucReceivedParams, 1, 
 800196a:	2101      	movs	r1, #1
 800196c:	f7ff fdc4 	bl	80014f8 <STREAM_TO_UINT16_f>
 8001970:	f8aa 0032 	strh.w	r0, [sl, #50]	; 0x32
															 tSLInformation.usSlBufferLength);
						}
						break;
 8001974:	e0a9      	b.n	8001aca <hci_event_handler+0x2ee>
					case HCI_EVNT_NVMEM_CREATE_ENTRY:
					case HCI_CMND_NVMEM_WRITE_PATCH:
					case HCI_NETAPP_PING_REPORT:
					case HCI_EVNT_MDNS_ADVERTISE:
						
						STREAM_TO_UINT8(pucReceivedData, HCI_EVENT_STATUS_OFFSET
 8001976:	7937      	ldrb	r7, [r6, #4]
 8001978:	7027      	strb	r7, [r4, #0]
														,*(unsigned char *)pRetParams);
						break;
 800197a:	e0a6      	b.n	8001aca <hci_event_handler+0x2ee>
					case HCI_CMND_LISTEN:
					case HCI_EVNT_CLOSE_SOCKET:
					case HCI_EVNT_CONNECT:
					case HCI_EVNT_NVMEM_WRITE:
						
						STREAM_TO_UINT32((char *)pucReceivedParams,0
 800197c:	4638      	mov	r0, r7
 800197e:	2100      	movs	r1, #0
 8001980:	f7ff fdc1 	bl	8001506 <STREAM_TO_UINT32_f>
 8001984:	6020      	str	r0, [r4, #0]
														 ,*(unsigned long *)pRetParams);
						break;
 8001986:	e0a0      	b.n	8001aca <hci_event_handler+0x2ee>
						UINT32_TO_STREAM((unsigned char *)pRetParams, retValue32);				
						break;
						
					case HCI_EVNT_BSD_GETHOSTBYNAME:
						
						STREAM_TO_UINT32((char *)pucReceivedParams
 8001988:	2100      	movs	r1, #0
 800198a:	4638      	mov	r0, r7
 800198c:	f7ff fdbb 	bl	8001506 <STREAM_TO_UINT32_f>
 8001990:	46a2      	mov	sl, r4
 8001992:	f84a 0b04 	str.w	r0, [sl], #4
						      ,GET_HOST_BY_NAME_RETVAL_OFFSET,*(unsigned long *)pRetParams);
						pRetParams = ((char *)pRetParams) + 4;
						STREAM_TO_UINT32((char *)pucReceivedParams
 8001996:	2104      	movs	r1, #4
 8001998:	4638      	mov	r0, r7
 800199a:	f7ff fdb4 	bl	8001506 <STREAM_TO_UINT32_f>
 800199e:	6060      	str	r0, [r4, #4]
 80019a0:	e092      	b.n	8001ac8 <hci_event_handler+0x2ec>
							STREAM_TO_UINT32((char *)pucReceivedParams
										,ACCEPT_RETURN_STATUS_OFFSET,*(unsigned long *)pRetParams);
              pRetParams = ((char *)pRetParams) + 4; 
							
							//This argument returns in network order
							memcpy((unsigned char *)pRetParams, 
 80019a2:	f857 3b04 	ldr.w	r3, [r7], #4
 80019a6:	428f      	cmp	r7, r1
 80019a8:	f842 3b04 	str.w	r3, [r2], #4
 80019ac:	d1f9      	bne.n	80019a2 <hci_event_handler+0x1c6>
 80019ae:	e08c      	b.n	8001aca <hci_event_handler+0x2ee>
						}
						
					case HCI_EVNT_RECV:
					case HCI_EVNT_RECVFROM:
						{
							STREAM_TO_UINT32((char *)pucReceivedParams,SL_RECEIVE_SD_OFFSET ,*(unsigned long *)pRetParams);
 80019b0:	2100      	movs	r1, #0
 80019b2:	4638      	mov	r0, r7
 80019b4:	f7ff fda7 	bl	8001506 <STREAM_TO_UINT32_f>
							pRetParams = ((char *)pRetParams) + 4;
							STREAM_TO_UINT32((char *)pucReceivedParams,SL_RECEIVE_NUM_BYTES_OFFSET,*(unsigned long *)pRetParams);
 80019b8:	2104      	movs	r1, #4
						}
						
					case HCI_EVNT_RECV:
					case HCI_EVNT_RECVFROM:
						{
							STREAM_TO_UINT32((char *)pucReceivedParams,SL_RECEIVE_SD_OFFSET ,*(unsigned long *)pRetParams);
 80019ba:	6020      	str	r0, [r4, #0]
							pRetParams = ((char *)pRetParams) + 4;
							STREAM_TO_UINT32((char *)pucReceivedParams,SL_RECEIVE_NUM_BYTES_OFFSET,*(unsigned long *)pRetParams);
 80019bc:	4638      	mov	r0, r7
 80019be:	f7ff fda2 	bl	8001506 <STREAM_TO_UINT32_f>
							pRetParams = ((char *)pRetParams) + 4;
							STREAM_TO_UINT32((char *)pucReceivedParams,SL_RECEIVE__FLAGS__OFFSET,*(unsigned long *)pRetParams);
 80019c2:	2108      	movs	r1, #8
					case HCI_EVNT_RECV:
					case HCI_EVNT_RECVFROM:
						{
							STREAM_TO_UINT32((char *)pucReceivedParams,SL_RECEIVE_SD_OFFSET ,*(unsigned long *)pRetParams);
							pRetParams = ((char *)pRetParams) + 4;
							STREAM_TO_UINT32((char *)pucReceivedParams,SL_RECEIVE_NUM_BYTES_OFFSET,*(unsigned long *)pRetParams);
 80019c4:	6060      	str	r0, [r4, #4]
							pRetParams = ((char *)pRetParams) + 4;
							STREAM_TO_UINT32((char *)pucReceivedParams,SL_RECEIVE__FLAGS__OFFSET,*(unsigned long *)pRetParams);
 80019c6:	4638      	mov	r0, r7
 80019c8:	f7ff fd9d 	bl	8001506 <STREAM_TO_UINT32_f>
					case HCI_EVNT_RECVFROM:
						{
							STREAM_TO_UINT32((char *)pucReceivedParams,SL_RECEIVE_SD_OFFSET ,*(unsigned long *)pRetParams);
							pRetParams = ((char *)pRetParams) + 4;
							STREAM_TO_UINT32((char *)pucReceivedParams,SL_RECEIVE_NUM_BYTES_OFFSET,*(unsigned long *)pRetParams);
							pRetParams = ((char *)pRetParams) + 4;
 80019cc:	f104 0a08 	add.w	sl, r4, #8
							STREAM_TO_UINT32((char *)pucReceivedParams,SL_RECEIVE__FLAGS__OFFSET,*(unsigned long *)pRetParams);
 80019d0:	60a0      	str	r0, [r4, #8]
							
							if(((tBsdReadReturnParams *)pRetParams)->iNumberOfBytes == ERROR_SOCKET_INACTIVE)
 80019d2:	68e4      	ldr	r4, [r4, #12]
 80019d4:	f114 0339 	adds.w	r3, r4, #57	; 0x39
 80019d8:	d176      	bne.n	8001ac8 <hci_event_handler+0x2ec>
							{
								set_socket_active_status(((tBsdReadReturnParams *)pRetParams)->iSocketDescriptor,SOCKET_STATUS_INACTIVE);
 80019da:	2101      	movs	r1, #1
 80019dc:	f7ff fdda 	bl	8001594 <set_socket_active_status>
 80019e0:	e072      	b.n	8001ac8 <hci_event_handler+0x2ec>
						}
                                                
                                        case HCI_EVNT_SEND:
					case HCI_EVNT_SENDTO:
						{
							STREAM_TO_UINT32((char *)pucReceivedParams,SL_RECEIVE_SD_OFFSET ,*(unsigned long *)pRetParams);
 80019e2:	2100      	movs	r1, #0
 80019e4:	4638      	mov	r0, r7
 80019e6:	f7ff fd8e 	bl	8001506 <STREAM_TO_UINT32_f>
							pRetParams = ((char *)pRetParams) + 4;
							STREAM_TO_UINT32((char *)pucReceivedParams,SL_RECEIVE_NUM_BYTES_OFFSET,*(unsigned long *)pRetParams);
 80019ea:	2104      	movs	r1, #4
						}
                                                
                                        case HCI_EVNT_SEND:
					case HCI_EVNT_SENDTO:
						{
							STREAM_TO_UINT32((char *)pucReceivedParams,SL_RECEIVE_SD_OFFSET ,*(unsigned long *)pRetParams);
 80019ec:	6020      	str	r0, [r4, #0]
							pRetParams = ((char *)pRetParams) + 4;
							STREAM_TO_UINT32((char *)pucReceivedParams,SL_RECEIVE_NUM_BYTES_OFFSET,*(unsigned long *)pRetParams);
 80019ee:	4638      	mov	r0, r7
 80019f0:	f7ff fd89 	bl	8001506 <STREAM_TO_UINT32_f>
 80019f4:	6060      	str	r0, [r4, #4]
							pRetParams = ((char *)pRetParams) + 4;
 80019f6:	3408      	adds	r4, #8
							
							break;
 80019f8:	e067      	b.n	8001aca <hci_event_handler+0x2ee>
							break;
						}
						
					case HCI_CMND_GETSOCKOPT:
						
						STREAM_TO_UINT8(pucReceivedData, HCI_EVENT_STATUS_OFFSET,((tBsdGetSockOptReturnParams *)pRetParams)->iStatus);
 80019fa:	7933      	ldrb	r3, [r6, #4]
 80019fc:	7123      	strb	r3, [r4, #4]
						//This argument returns in network order
						memcpy((unsigned char *)pRetParams, pucReceivedParams, 4);
 80019fe:	683f      	ldr	r7, [r7, #0]
 8001a00:	6027      	str	r7, [r4, #0]
						break;
 8001a02:	e062      	b.n	8001aca <hci_event_handler+0x2ee>
						
					case HCI_CMND_WLAN_IOCTL_GET_SCAN_RESULTS:
						
						STREAM_TO_UINT32((char *)pucReceivedParams,GET_SCAN_RESULTS_TABlE_COUNT_OFFSET,*(unsigned long *)pRetParams);
 8001a04:	4638      	mov	r0, r7
 8001a06:	2100      	movs	r1, #0
 8001a08:	f7ff fd7d 	bl	8001506 <STREAM_TO_UINT32_f>
						pRetParams = ((char *)pRetParams) + 4;   					
						STREAM_TO_UINT32((char *)pucReceivedParams,GET_SCAN_RESULTS_SCANRESULT_STATUS_OFFSET,*(unsigned long *)pRetParams);
 8001a0c:	2104      	movs	r1, #4
						memcpy((unsigned char *)pRetParams, pucReceivedParams, 4);
						break;
						
					case HCI_CMND_WLAN_IOCTL_GET_SCAN_RESULTS:
						
						STREAM_TO_UINT32((char *)pucReceivedParams,GET_SCAN_RESULTS_TABlE_COUNT_OFFSET,*(unsigned long *)pRetParams);
 8001a0e:	6020      	str	r0, [r4, #0]
						pRetParams = ((char *)pRetParams) + 4;   					
						STREAM_TO_UINT32((char *)pucReceivedParams,GET_SCAN_RESULTS_SCANRESULT_STATUS_OFFSET,*(unsigned long *)pRetParams);
 8001a10:	4638      	mov	r0, r7
 8001a12:	f7ff fd78 	bl	8001506 <STREAM_TO_UINT32_f>
						pRetParams = ((char *)pRetParams) + 4;                                                        					
						STREAM_TO_UINT16((char *)pucReceivedParams,GET_SCAN_RESULTS_ISVALID_TO_SSIDLEN_OFFSET,*(unsigned long *)pRetParams);
 8001a16:	2108      	movs	r1, #8
						
					case HCI_CMND_WLAN_IOCTL_GET_SCAN_RESULTS:
						
						STREAM_TO_UINT32((char *)pucReceivedParams,GET_SCAN_RESULTS_TABlE_COUNT_OFFSET,*(unsigned long *)pRetParams);
						pRetParams = ((char *)pRetParams) + 4;   					
						STREAM_TO_UINT32((char *)pucReceivedParams,GET_SCAN_RESULTS_SCANRESULT_STATUS_OFFSET,*(unsigned long *)pRetParams);
 8001a18:	6060      	str	r0, [r4, #4]
						pRetParams = ((char *)pRetParams) + 4;                                                        					
						STREAM_TO_UINT16((char *)pucReceivedParams,GET_SCAN_RESULTS_ISVALID_TO_SSIDLEN_OFFSET,*(unsigned long *)pRetParams);
 8001a1a:	4638      	mov	r0, r7
 8001a1c:	f7ff fd6c 	bl	80014f8 <STREAM_TO_UINT16_f>
						pRetParams = ((char *)pRetParams) + 2;   					
						STREAM_TO_UINT16((char *)pucReceivedParams,GET_SCAN_RESULTS_FRAME_TIME_OFFSET,*(unsigned long *)pRetParams);
 8001a20:	210a      	movs	r1, #10
						
						STREAM_TO_UINT32((char *)pucReceivedParams,GET_SCAN_RESULTS_TABlE_COUNT_OFFSET,*(unsigned long *)pRetParams);
						pRetParams = ((char *)pRetParams) + 4;   					
						STREAM_TO_UINT32((char *)pucReceivedParams,GET_SCAN_RESULTS_SCANRESULT_STATUS_OFFSET,*(unsigned long *)pRetParams);
						pRetParams = ((char *)pRetParams) + 4;                                                        					
						STREAM_TO_UINT16((char *)pucReceivedParams,GET_SCAN_RESULTS_ISVALID_TO_SSIDLEN_OFFSET,*(unsigned long *)pRetParams);
 8001a22:	60a0      	str	r0, [r4, #8]
						pRetParams = ((char *)pRetParams) + 2;   					
						STREAM_TO_UINT16((char *)pucReceivedParams,GET_SCAN_RESULTS_FRAME_TIME_OFFSET,*(unsigned long *)pRetParams);
 8001a24:	4638      	mov	r0, r7
 8001a26:	f7ff fd67 	bl	80014f8 <STREAM_TO_UINT16_f>
 8001a2a:	f8c4 000a 	str.w	r0, [r4, #10]
						pRetParams = ((char *)pRetParams) + 2;  
 8001a2e:	340c      	adds	r4, #12
						memcpy((unsigned char *)pRetParams, (char *)(pucReceivedParams + GET_SCAN_RESULTS_FRAME_TIME_OFFSET + 2), GET_SCAN_RESULTS_SSID_MAC_LENGTH);	
 8001a30:	f106 0711 	add.w	r7, r6, #17
 8001a34:	4622      	mov	r2, r4
 8001a36:	f106 0135 	add.w	r1, r6, #53	; 0x35
 8001a3a:	f857 3b04 	ldr.w	r3, [r7], #4
 8001a3e:	428f      	cmp	r7, r1
 8001a40:	f842 3b04 	str.w	r3, [r2], #4
 8001a44:	d1f9      	bne.n	8001a3a <hci_event_handler+0x25e>
 8001a46:	8838      	ldrh	r0, [r7, #0]
 8001a48:	8010      	strh	r0, [r2, #0]
						break;
 8001a4a:	e03e      	b.n	8001aca <hci_event_handler+0x2ee>
				// In case unsolicited event received - here the handling finished
				if (hci_unsol_event_handler((char *)pucReceivedData) == 0)
				{
					STREAM_TO_UINT8(pucReceivedData, HCI_DATA_LENGTH_OFFSET, usLength);
					
					switch(usReceivedEventOpcode)
 8001a4c:	2200      	movs	r2, #0
//
//*****************************************************************************

	
unsigned char *
hci_event_handler(void *pRetParams, unsigned char *from, unsigned char *fromlen)
 8001a4e:	18b7      	adds	r7, r6, r2
						break;
						
					case HCI_NETAPP_IPCONFIG:
						
						//Read IP address
						STREAM_TO_STREAM(RecvParams,RetParams,NETAPP_IPCONFIG_IP_LENGTH);
 8001a50:	7978      	ldrb	r0, [r7, #5]
 8001a52:	54a0      	strb	r0, [r4, r2]
 8001a54:	3201      	adds	r2, #1
 8001a56:	2a04      	cmp	r2, #4
 8001a58:	d1f9      	bne.n	8001a4e <hci_event_handler+0x272>
						RecvParams += 4;
 8001a5a:	f106 0709 	add.w	r7, r6, #9
 8001a5e:	2300      	movs	r3, #0
						
						//Read subnet
						STREAM_TO_STREAM(RecvParams,RetParams,NETAPP_IPCONFIG_IP_LENGTH);
 8001a60:	5cf9      	ldrb	r1, [r7, r3]
//
//*****************************************************************************

	
unsigned char *
hci_event_handler(void *pRetParams, unsigned char *from, unsigned char *fromlen)
 8001a62:	18e0      	adds	r0, r4, r3
 8001a64:	3301      	adds	r3, #1
						//Read IP address
						STREAM_TO_STREAM(RecvParams,RetParams,NETAPP_IPCONFIG_IP_LENGTH);
						RecvParams += 4;
						
						//Read subnet
						STREAM_TO_STREAM(RecvParams,RetParams,NETAPP_IPCONFIG_IP_LENGTH);
 8001a66:	2b04      	cmp	r3, #4
 8001a68:	7101      	strb	r1, [r0, #4]
 8001a6a:	d1f9      	bne.n	8001a60 <hci_event_handler+0x284>
						RecvParams += 4;
 8001a6c:	f106 070d 	add.w	r7, r6, #13
 8001a70:	2000      	movs	r0, #0
						
						//Read default GW
						STREAM_TO_STREAM(RecvParams,RetParams,NETAPP_IPCONFIG_IP_LENGTH);
 8001a72:	5c39      	ldrb	r1, [r7, r0]
//
//*****************************************************************************

	
unsigned char *
hci_event_handler(void *pRetParams, unsigned char *from, unsigned char *fromlen)
 8001a74:	1822      	adds	r2, r4, r0
 8001a76:	3001      	adds	r0, #1
						//Read subnet
						STREAM_TO_STREAM(RecvParams,RetParams,NETAPP_IPCONFIG_IP_LENGTH);
						RecvParams += 4;
						
						//Read default GW
						STREAM_TO_STREAM(RecvParams,RetParams,NETAPP_IPCONFIG_IP_LENGTH);
 8001a78:	2804      	cmp	r0, #4
 8001a7a:	7211      	strb	r1, [r2, #8]
 8001a7c:	d1f9      	bne.n	8001a72 <hci_event_handler+0x296>
						RecvParams += 4;
 8001a7e:	f106 0711 	add.w	r7, r6, #17
 8001a82:	2300      	movs	r3, #0
						
						//Read DHCP server                                          	
						STREAM_TO_STREAM(RecvParams,RetParams,NETAPP_IPCONFIG_IP_LENGTH);
 8001a84:	5cf9      	ldrb	r1, [r7, r3]
//
//*****************************************************************************

	
unsigned char *
hci_event_handler(void *pRetParams, unsigned char *from, unsigned char *fromlen)
 8001a86:	18e2      	adds	r2, r4, r3
 8001a88:	3301      	adds	r3, #1
						//Read default GW
						STREAM_TO_STREAM(RecvParams,RetParams,NETAPP_IPCONFIG_IP_LENGTH);
						RecvParams += 4;
						
						//Read DHCP server                                          	
						STREAM_TO_STREAM(RecvParams,RetParams,NETAPP_IPCONFIG_IP_LENGTH);
 8001a8a:	2b04      	cmp	r3, #4
 8001a8c:	7311      	strb	r1, [r2, #12]
 8001a8e:	d1f9      	bne.n	8001a84 <hci_event_handler+0x2a8>
						RecvParams += 4;
 8001a90:	f106 0015 	add.w	r0, r6, #21
 8001a94:	2200      	movs	r2, #0
						
						//Read DNS server                                           
						STREAM_TO_STREAM(RecvParams,RetParams,NETAPP_IPCONFIG_IP_LENGTH);
 8001a96:	5c87      	ldrb	r7, [r0, r2]
//
//*****************************************************************************

	
unsigned char *
hci_event_handler(void *pRetParams, unsigned char *from, unsigned char *fromlen)
 8001a98:	18a1      	adds	r1, r4, r2
 8001a9a:	3201      	adds	r2, #1
						//Read DHCP server                                          	
						STREAM_TO_STREAM(RecvParams,RetParams,NETAPP_IPCONFIG_IP_LENGTH);
						RecvParams += 4;
						
						//Read DNS server                                           
						STREAM_TO_STREAM(RecvParams,RetParams,NETAPP_IPCONFIG_IP_LENGTH);
 8001a9c:	2a04      	cmp	r2, #4
 8001a9e:	740f      	strb	r7, [r1, #16]
 8001aa0:	d1f9      	bne.n	8001a96 <hci_event_handler+0x2ba>
						RecvParams += 4;
 8001aa2:	f106 0019 	add.w	r0, r6, #25
 8001aa6:	2300      	movs	r3, #0
						
						//Read Mac address                            	
						STREAM_TO_STREAM(RecvParams,RetParams,NETAPP_IPCONFIG_MAC_LENGTH);
 8001aa8:	5cc7      	ldrb	r7, [r0, r3]
//
//*****************************************************************************

	
unsigned char *
hci_event_handler(void *pRetParams, unsigned char *from, unsigned char *fromlen)
 8001aaa:	18e1      	adds	r1, r4, r3
 8001aac:	3301      	adds	r3, #1
						//Read DNS server                                           
						STREAM_TO_STREAM(RecvParams,RetParams,NETAPP_IPCONFIG_IP_LENGTH);
						RecvParams += 4;
						
						//Read Mac address                            	
						STREAM_TO_STREAM(RecvParams,RetParams,NETAPP_IPCONFIG_MAC_LENGTH);
 8001aae:	2b06      	cmp	r3, #6
 8001ab0:	750f      	strb	r7, [r1, #20]
 8001ab2:	d1f9      	bne.n	8001aa8 <hci_event_handler+0x2cc>
						RecvParams += 6;
 8001ab4:	f106 001f 	add.w	r0, r6, #31
 8001ab8:	2100      	movs	r1, #0
						
						//Read SSID
						STREAM_TO_STREAM(RecvParams,RetParams,NETAPP_IPCONFIG_SSID_LENGTH);
 8001aba:	5c47      	ldrb	r7, [r0, r1]
//
//*****************************************************************************

	
unsigned char *
hci_event_handler(void *pRetParams, unsigned char *from, unsigned char *fromlen)
 8001abc:	1862      	adds	r2, r4, r1
 8001abe:	3101      	adds	r1, #1
						//Read Mac address                            	
						STREAM_TO_STREAM(RecvParams,RetParams,NETAPP_IPCONFIG_MAC_LENGTH);
						RecvParams += 6;
						
						//Read SSID
						STREAM_TO_STREAM(RecvParams,RetParams,NETAPP_IPCONFIG_SSID_LENGTH);
 8001ac0:	2920      	cmp	r1, #32
 8001ac2:	7697      	strb	r7, [r2, #26]
 8001ac4:	d1f9      	bne.n	8001aba <hci_event_handler+0x2de>
 8001ac6:	e000      	b.n	8001aca <hci_event_handler+0x2ee>
					case HCI_EVNT_RECVFROM:
						{
							STREAM_TO_UINT32((char *)pucReceivedParams,SL_RECEIVE_SD_OFFSET ,*(unsigned long *)pRetParams);
							pRetParams = ((char *)pRetParams) + 4;
							STREAM_TO_UINT32((char *)pucReceivedParams,SL_RECEIVE_NUM_BYTES_OFFSET,*(unsigned long *)pRetParams);
							pRetParams = ((char *)pRetParams) + 4;
 8001ac8:	4654      	mov	r4, sl
						STREAM_TO_STREAM(RecvParams,RetParams,NETAPP_IPCONFIG_SSID_LENGTH);
	
					}
				}
				
				if (usReceivedEventOpcode == tSLInformation.usRxEventOpcode)
 8001aca:	4b04      	ldr	r3, [pc, #16]	; (8001adc <hci_event_handler+0x300>)
 8001acc:	8818      	ldrh	r0, [r3, #0]
 8001ace:	b282      	uxth	r2, r0
 8001ad0:	4295      	cmp	r5, r2
 8001ad2:	d125      	bne.n	8001b20 <hci_event_handler+0x344>
				{
					tSLInformation.usRxEventOpcode = 0;
 8001ad4:	2100      	movs	r1, #0
 8001ad6:	8019      	strh	r1, [r3, #0]
 8001ad8:	e022      	b.n	8001b20 <hci_event_handler+0x344>
 8001ada:	bf00      	nop
 8001adc:	200009b8 	.word	0x200009b8
			else
			{				
				pucReceivedParams = pucReceivedData;
				STREAM_TO_UINT8((char *)pucReceivedData, HCI_PACKET_ARGSIZE_OFFSET, ucArgsize);
				
				STREAM_TO_UINT16((char *)pucReceivedData, HCI_PACKET_LENGTH_OFFSET, usLength);
 8001ae0:	4630      	mov	r0, r6
 8001ae2:	2103      	movs	r1, #3
				}
			}
			else
			{				
				pucReceivedParams = pucReceivedData;
				STREAM_TO_UINT8((char *)pucReceivedData, HCI_PACKET_ARGSIZE_OFFSET, ucArgsize);
 8001ae4:	78b7      	ldrb	r7, [r6, #2]
				
				STREAM_TO_UINT16((char *)pucReceivedData, HCI_PACKET_LENGTH_OFFSET, usLength);
 8001ae6:	f7ff fd07 	bl	80014f8 <STREAM_TO_UINT16_f>
 8001aea:	4682      	mov	sl, r0

				// Data received: note that the only case where from and from length 
				// are not null is in recv from, so fill the args accordingly
				if (from)
 8001aec:	f1b8 0f00 	cmp.w	r8, #0
 8001af0:	d00c      	beq.n	8001b0c <hci_event_handler+0x330>
				{
					STREAM_TO_UINT32((char *)(pucReceivedData + HCI_DATA_HEADER_SIZE), BSD_RECV_FROM_FROMLEN_OFFSET, *(unsigned long *)fromlen);
 8001af2:	2104      	movs	r1, #4
 8001af4:	1d70      	adds	r0, r6, #5
 8001af6:	f7ff fd06 	bl	8001506 <STREAM_TO_UINT32_f>
 8001afa:	4603      	mov	r3, r0
 8001afc:	f8c9 0000 	str.w	r0, [r9]
					memcpy(from, (pucReceivedData + HCI_DATA_HEADER_SIZE + BSD_RECV_FROM_FROM_OFFSET) ,*fromlen);
 8001b00:	f106 0115 	add.w	r1, r6, #21
 8001b04:	4640      	mov	r0, r8
 8001b06:	b2da      	uxtb	r2, r3
 8001b08:	f000 fa24 	bl	8001f54 <memcpy>
				}
				
				memcpy(pRetParams, pucReceivedParams + HCI_DATA_HEADER_SIZE + ucArgsize,
 8001b0c:	1d7a      	adds	r2, r7, #5
 8001b0e:	18b1      	adds	r1, r6, r2
 8001b10:	4620      	mov	r0, r4
 8001b12:	ebc7 020a 	rsb	r2, r7, sl
 8001b16:	f000 fa1d 	bl	8001f54 <memcpy>
							 usLength - ucArgsize);
				
				tSLInformation.usRxDataPending = 0;
 8001b1a:	490f      	ldr	r1, [pc, #60]	; (8001b58 <hci_event_handler+0x37c>)
 8001b1c:	2000      	movs	r0, #0
 8001b1e:	86c8      	strh	r0, [r1, #54]	; 0x36
			}
		
			tSLInformation.usEventOrDataReceived = 0;
 8001b20:	4f0d      	ldr	r7, [pc, #52]	; (8001b58 <hci_event_handler+0x37c>)
 8001b22:	2300      	movs	r3, #0
 8001b24:	807b      	strh	r3, [r7, #2]
			
			SpiResumeSpi();
 8001b26:	f7fe fb3b 	bl	80001a0 <SpiResumeSpi>
			
			// Since we are going to TX - we need to handle this event after the 
			// ResumeSPi since we need interrupts
			if ((*pucReceivedData == HCI_TYPE_EVNT) &&
 8001b2a:	7830      	ldrb	r0, [r6, #0]
 8001b2c:	2804      	cmp	r0, #4
 8001b2e:	d105      	bne.n	8001b3c <hci_event_handler+0x360>
 8001b30:	f5b5 5f80 	cmp.w	r5, #4096	; 0x1000
 8001b34:	d102      	bne.n	8001b3c <hci_event_handler+0x360>
					(usReceivedEventOpcode == HCI_EVNT_PATCHES_REQ))
			{
				hci_unsol_handle_patch_request((char *)pucReceivedData);
 8001b36:	4630      	mov	r0, r6
 8001b38:	f7ff fcf2 	bl	8001520 <hci_unsol_handle_patch_request>
			}
			
			if ((tSLInformation.usRxEventOpcode == 0) && (tSLInformation.usRxDataPending == 0))
 8001b3c:	883a      	ldrh	r2, [r7, #0]
 8001b3e:	b291      	uxth	r1, r2
 8001b40:	2900      	cmp	r1, #0
 8001b42:	f47f ae51 	bne.w	80017e8 <hci_event_handler+0xc>
 8001b46:	4b04      	ldr	r3, [pc, #16]	; (8001b58 <hci_event_handler+0x37c>)
 8001b48:	8ed8      	ldrh	r0, [r3, #54]	; 0x36
 8001b4a:	b280      	uxth	r0, r0
 8001b4c:	2800      	cmp	r0, #0
 8001b4e:	f47f ae4b 	bne.w	80017e8 <hci_event_handler+0xc>
				return NULL;
			}	
		}
	}

}
 8001b52:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8001b56:	bf00      	nop
 8001b58:	200009b8 	.word	0x200009b8

08001b5c <SimpleLinkWaitEvent>:
void 
SimpleLinkWaitEvent(unsigned short usOpcode, void *pRetParams)
{
	// In the blocking implementation the control to caller will be returned only 
	// after the end of current transaction
	tSLInformation.usRxEventOpcode = usOpcode;
 8001b5c:	4b03      	ldr	r3, [pc, #12]	; (8001b6c <SimpleLinkWaitEvent+0x10>)
 8001b5e:	8018      	strh	r0, [r3, #0]
	hci_event_handler(pRetParams, 0, 0);
 8001b60:	4608      	mov	r0, r1
 8001b62:	2100      	movs	r1, #0
 8001b64:	460a      	mov	r2, r1
 8001b66:	f7ff be39 	b.w	80017dc <hci_event_handler>
 8001b6a:	bf00      	nop
 8001b6c:	200009b8 	.word	0x200009b8

08001b70 <SimpleLinkWaitData>:
//*****************************************************************************

void 
SimpleLinkWaitData(unsigned char *pBuf, unsigned char *from, 
									 unsigned char *fromlen)
{
 8001b70:	b510      	push	{r4, lr}
	// In the blocking implementation the control to caller will be returned only 
	// after the end of current transaction, i.e. only after data will be received
	tSLInformation.usRxDataPending = 1;
 8001b72:	4b03      	ldr	r3, [pc, #12]	; (8001b80 <SimpleLinkWaitData+0x10>)
 8001b74:	2401      	movs	r4, #1
 8001b76:	86dc      	strh	r4, [r3, #54]	; 0x36
	hci_event_handler(pBuf, from, fromlen);
}
 8001b78:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
									 unsigned char *fromlen)
{
	// In the blocking implementation the control to caller will be returned only 
	// after the end of current transaction, i.e. only after data will be received
	tSLInformation.usRxDataPending = 1;
	hci_event_handler(pBuf, from, fromlen);
 8001b7c:	f7ff be2e 	b.w	80017dc <hci_event_handler>
 8001b80:	200009b8 	.word	0x200009b8

08001b84 <hci_command_send>:
//
//*****************************************************************************
unsigned short 
hci_command_send(unsigned short usOpcode, unsigned char *pucBuff,
                     unsigned char ucArgsLength)
{ 
 8001b84:	b538      	push	{r3, r4, r5, lr}
 8001b86:	4603      	mov	r3, r0
 8001b88:	4615      	mov	r5, r2
	unsigned char *stream;
	
	stream = (pucBuff + SPI_HEADER_SIZE);
	
	UINT8_TO_STREAM(stream, HCI_TYPE_CMND);
 8001b8a:	2201      	movs	r2, #1
 8001b8c:	714a      	strb	r2, [r1, #5]
//
//*****************************************************************************
unsigned short 
hci_command_send(unsigned short usOpcode, unsigned char *pucBuff,
                     unsigned char ucArgsLength)
{ 
 8001b8e:	460c      	mov	r4, r1
	unsigned char *stream;
	
	stream = (pucBuff + SPI_HEADER_SIZE);
	
	UINT8_TO_STREAM(stream, HCI_TYPE_CMND);
	stream = UINT16_TO_STREAM(stream, usOpcode);
 8001b90:	1d88      	adds	r0, r1, #6
 8001b92:	4619      	mov	r1, r3
 8001b94:	f7ff fcab 	bl	80014ee <UINT16_TO_STREAM_f>
	UINT8_TO_STREAM(stream, ucArgsLength);
	
	//Update the opcode of the event we will be waiting for
	SpiWrite(pucBuff, ucArgsLength + SIMPLE_LINK_HCI_CMND_HEADER_SIZE);
 8001b98:	1d29      	adds	r1, r5, #4
	
	stream = (pucBuff + SPI_HEADER_SIZE);
	
	UINT8_TO_STREAM(stream, HCI_TYPE_CMND);
	stream = UINT16_TO_STREAM(stream, usOpcode);
	UINT8_TO_STREAM(stream, ucArgsLength);
 8001b9a:	7005      	strb	r5, [r0, #0]
	
	//Update the opcode of the event we will be waiting for
	SpiWrite(pucBuff, ucArgsLength + SIMPLE_LINK_HCI_CMND_HEADER_SIZE);
 8001b9c:	4620      	mov	r0, r4
 8001b9e:	f7fe fbbf 	bl	8000320 <SpiWrite>
	
	return(0);
}
 8001ba2:	2000      	movs	r0, #0
 8001ba4:	bd38      	pop	{r3, r4, r5, pc}

08001ba6 <hci_data_command_send>:
//!  @brief              Prepeare HCI header and initiate an HCI data write operation
//
//*****************************************************************************
void hci_data_command_send(unsigned short usOpcode, unsigned char *pucBuff,
                     unsigned char ucArgsLength,unsigned short ucDataLength)
{ 
 8001ba6:	b538      	push	{r3, r4, r5, lr}
 	unsigned char *stream = (pucBuff + SPI_HEADER_SIZE);
	
	UINT8_TO_STREAM(stream, HCI_TYPE_DATA);
	UINT8_TO_STREAM(stream, usOpcode);
	UINT8_TO_STREAM(stream, ucArgsLength);
	stream = UINT16_TO_STREAM(stream, ucArgsLength + ucDataLength);
 8001ba8:	189b      	adds	r3, r3, r2
//!  @brief              Prepeare HCI header and initiate an HCI data write operation
//
//*****************************************************************************
void hci_data_command_send(unsigned short usOpcode, unsigned char *pucBuff,
                     unsigned char ucArgsLength,unsigned short ucDataLength)
{ 
 8001baa:	460c      	mov	r4, r1
 	unsigned char *stream = (pucBuff + SPI_HEADER_SIZE);
	
	UINT8_TO_STREAM(stream, HCI_TYPE_DATA);
	UINT8_TO_STREAM(stream, usOpcode);
	UINT8_TO_STREAM(stream, ucArgsLength);
	stream = UINT16_TO_STREAM(stream, ucArgsLength + ucDataLength);
 8001bac:	b29d      	uxth	r5, r3
void hci_data_command_send(unsigned short usOpcode, unsigned char *pucBuff,
                     unsigned char ucArgsLength,unsigned short ucDataLength)
{ 
 	unsigned char *stream = (pucBuff + SPI_HEADER_SIZE);
	
	UINT8_TO_STREAM(stream, HCI_TYPE_DATA);
 8001bae:	2102      	movs	r1, #2
 8001bb0:	7161      	strb	r1, [r4, #5]
	UINT8_TO_STREAM(stream, usOpcode);
 8001bb2:	71a0      	strb	r0, [r4, #6]
	UINT8_TO_STREAM(stream, ucArgsLength);
 8001bb4:	71e2      	strb	r2, [r4, #7]
	stream = UINT16_TO_STREAM(stream, ucArgsLength + ucDataLength);
 8001bb6:	4629      	mov	r1, r5
 8001bb8:	f104 0008 	add.w	r0, r4, #8
 8001bbc:	f7ff fc97 	bl	80014ee <UINT16_TO_STREAM_f>
	
	// Send the command over SPI on data channel
	SpiWrite(pucBuff, ucArgsLength + ucDataLength + SIMPLE_LINK_HCI_DATA_CMND_HEADER_SIZE);
 8001bc0:	1d6a      	adds	r2, r5, #5
 8001bc2:	4620      	mov	r0, r4
 8001bc4:	b291      	uxth	r1, r2
	
	return;
}
 8001bc6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	UINT8_TO_STREAM(stream, usOpcode);
	UINT8_TO_STREAM(stream, ucArgsLength);
	stream = UINT16_TO_STREAM(stream, ucArgsLength + ucDataLength);
	
	// Send the command over SPI on data channel
	SpiWrite(pucBuff, ucArgsLength + ucDataLength + SIMPLE_LINK_HCI_DATA_CMND_HEADER_SIZE);
 8001bca:	f7fe bba9 	b.w	8000320 <SpiWrite>

08001bce <hci_patch_send>:
//!  @brief               Prepeare HCI header and initiate an HCI patch write operation
//
//*****************************************************************************
void
hci_patch_send(unsigned char ucOpcode, unsigned char *pucBuff, char *patch, unsigned short usDataLength)
{ 
 8001bce:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8001bd2:	461d      	mov	r5, r3
	unsigned short usTransLength;
	unsigned char *stream = (pucBuff + SPI_HEADER_SIZE);
	
	UINT8_TO_STREAM(stream, HCI_TYPE_PATCH);
	UINT8_TO_STREAM(stream, ucOpcode);
	stream = UINT16_TO_STREAM(stream, usDataLength + SIMPLE_LINK_HCI_PATCH_HEADER_SIZE);
 8001bd4:	f105 0a02 	add.w	sl, r5, #2
{ 
 	unsigned char *data_ptr = (pucBuff + SPI_HEADER_SIZE);
	unsigned short usTransLength;
	unsigned char *stream = (pucBuff + SPI_HEADER_SIZE);
	
	UINT8_TO_STREAM(stream, HCI_TYPE_PATCH);
 8001bd8:	2303      	movs	r3, #3
	UINT8_TO_STREAM(stream, ucOpcode);
 8001bda:	f101 0907 	add.w	r9, r1, #7
	stream = UINT16_TO_STREAM(stream, usDataLength + SIMPLE_LINK_HCI_PATCH_HEADER_SIZE);
 8001bde:	fa1f fa8a 	uxth.w	sl, sl
 	unsigned char *data_ptr = (pucBuff + SPI_HEADER_SIZE);
	unsigned short usTransLength;
	unsigned char *stream = (pucBuff + SPI_HEADER_SIZE);
	
	UINT8_TO_STREAM(stream, HCI_TYPE_PATCH);
	UINT8_TO_STREAM(stream, ucOpcode);
 8001be2:	7188      	strb	r0, [r1, #6]
{ 
 	unsigned char *data_ptr = (pucBuff + SPI_HEADER_SIZE);
	unsigned short usTransLength;
	unsigned char *stream = (pucBuff + SPI_HEADER_SIZE);
	
	UINT8_TO_STREAM(stream, HCI_TYPE_PATCH);
 8001be4:	714b      	strb	r3, [r1, #5]
//!  @brief               Prepeare HCI header and initiate an HCI patch write operation
//
//*****************************************************************************
void
hci_patch_send(unsigned char ucOpcode, unsigned char *pucBuff, char *patch, unsigned short usDataLength)
{ 
 8001be6:	460c      	mov	r4, r1
	unsigned short usTransLength;
	unsigned char *stream = (pucBuff + SPI_HEADER_SIZE);
	
	UINT8_TO_STREAM(stream, HCI_TYPE_PATCH);
	UINT8_TO_STREAM(stream, ucOpcode);
	stream = UINT16_TO_STREAM(stream, usDataLength + SIMPLE_LINK_HCI_PATCH_HEADER_SIZE);
 8001be8:	4648      	mov	r0, r9
 8001bea:	4651      	mov	r1, sl
//!  @brief               Prepeare HCI header and initiate an HCI patch write operation
//
//*****************************************************************************
void
hci_patch_send(unsigned char ucOpcode, unsigned char *pucBuff, char *patch, unsigned short usDataLength)
{ 
 8001bec:	4617      	mov	r7, r2
	unsigned short usTransLength;
	unsigned char *stream = (pucBuff + SPI_HEADER_SIZE);
	
	UINT8_TO_STREAM(stream, HCI_TYPE_PATCH);
	UINT8_TO_STREAM(stream, ucOpcode);
	stream = UINT16_TO_STREAM(stream, usDataLength + SIMPLE_LINK_HCI_PATCH_HEADER_SIZE);
 8001bee:	f7ff fc7e 	bl	80014ee <UINT16_TO_STREAM_f>
	
	if (usDataLength <= SL_PATCH_PORTION_SIZE)
 8001bf2:	f5b5 7f7a 	cmp.w	r5, #1000	; 0x3e8
	unsigned short usTransLength;
	unsigned char *stream = (pucBuff + SPI_HEADER_SIZE);
	
	UINT8_TO_STREAM(stream, HCI_TYPE_PATCH);
	UINT8_TO_STREAM(stream, ucOpcode);
	stream = UINT16_TO_STREAM(stream, usDataLength + SIMPLE_LINK_HCI_PATCH_HEADER_SIZE);
 8001bf6:	4680      	mov	r8, r0
	
	if (usDataLength <= SL_PATCH_PORTION_SIZE)
 8001bf8:	d813      	bhi.n	8001c22 <hci_patch_send+0x54>
	{
		UINT16_TO_STREAM(stream, usDataLength);
 8001bfa:	4629      	mov	r1, r5
 8001bfc:	f7ff fc77 	bl	80014ee <UINT16_TO_STREAM_f>
		stream = UINT16_TO_STREAM(stream, usDataLength);
 8001c00:	4629      	mov	r1, r5
 8001c02:	4640      	mov	r0, r8
 8001c04:	f7ff fc73 	bl	80014ee <UINT16_TO_STREAM_f>
		memcpy((pucBuff + SPI_HEADER_SIZE) + HCI_PATCH_HEADER_SIZE, patch, usDataLength);
 8001c08:	4639      	mov	r1, r7
 8001c0a:	f104 000b 	add.w	r0, r4, #11
 8001c0e:	462a      	mov	r2, r5
 8001c10:	f000 f9a0 	bl	8001f54 <memcpy>
		
		// Update the opcode of the event we will be waiting for
		SpiWrite(pucBuff, usDataLength + HCI_PATCH_HEADER_SIZE);
 8001c14:	1da9      	adds	r1, r5, #6
 8001c16:	4620      	mov	r0, r4
 8001c18:	b289      	uxth	r1, r1
			
			// Update the opcode of the event we will be waiting for
			SpiWrite((unsigned char *)data_ptr, usTransLength + sizeof(usTransLength));
		}
	}
}
 8001c1a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		UINT16_TO_STREAM(stream, usDataLength);
		stream = UINT16_TO_STREAM(stream, usDataLength);
		memcpy((pucBuff + SPI_HEADER_SIZE) + HCI_PATCH_HEADER_SIZE, patch, usDataLength);
		
		// Update the opcode of the event we will be waiting for
		SpiWrite(pucBuff, usDataLength + HCI_PATCH_HEADER_SIZE);
 8001c1e:	f7fe bb7f 	b.w	8000320 <SpiWrite>
	}
	else
	{
		
		usTransLength = (usDataLength/SL_PATCH_PORTION_SIZE);
 8001c22:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
 8001c26:	fbb5 f1f6 	udiv	r1, r5, r6
		UINT16_TO_STREAM(stream, usDataLength + SIMPLE_LINK_HCI_PATCH_HEADER_SIZE + usTransLength*SIMPLE_LINK_HCI_PATCH_HEADER_SIZE);
 8001c2a:	eb0a 0241 	add.w	r2, sl, r1, lsl #1
 8001c2e:	b291      	uxth	r1, r2
 8001c30:	f7ff fc5d 	bl	80014ee <UINT16_TO_STREAM_f>
		stream = UINT16_TO_STREAM(stream, SL_PATCH_PORTION_SIZE);
 8001c34:	4631      	mov	r1, r6
 8001c36:	4640      	mov	r0, r8
 8001c38:	f7ff fc59 	bl	80014ee <UINT16_TO_STREAM_f>
		memcpy(pucBuff + SPI_HEADER_SIZE + HCI_PATCH_HEADER_SIZE, patch, SL_PATCH_PORTION_SIZE);
 8001c3c:	4639      	mov	r1, r7
 8001c3e:	f104 000b 	add.w	r0, r4, #11
 8001c42:	4632      	mov	r2, r6
 8001c44:	f000 f986 	bl	8001f54 <memcpy>
		usDataLength -= SL_PATCH_PORTION_SIZE;
 8001c48:	f5a5 757a 	sub.w	r5, r5, #1000	; 0x3e8
		patch += SL_PATCH_PORTION_SIZE;
		
		// Update the opcode of the event we will be waiting for
		SpiWrite(pucBuff, SL_PATCH_PORTION_SIZE + HCI_PATCH_HEADER_SIZE);
 8001c4c:	4620      	mov	r0, r4
 8001c4e:	f240 31ee 	movw	r1, #1006	; 0x3ee
		
		usTransLength = (usDataLength/SL_PATCH_PORTION_SIZE);
		UINT16_TO_STREAM(stream, usDataLength + SIMPLE_LINK_HCI_PATCH_HEADER_SIZE + usTransLength*SIMPLE_LINK_HCI_PATCH_HEADER_SIZE);
		stream = UINT16_TO_STREAM(stream, SL_PATCH_PORTION_SIZE);
		memcpy(pucBuff + SPI_HEADER_SIZE + HCI_PATCH_HEADER_SIZE, patch, SL_PATCH_PORTION_SIZE);
		usDataLength -= SL_PATCH_PORTION_SIZE;
 8001c52:	b2ad      	uxth	r5, r5
		patch += SL_PATCH_PORTION_SIZE;
 8001c54:	19bf      	adds	r7, r7, r6
		
		// Update the opcode of the event we will be waiting for
		SpiWrite(pucBuff, SL_PATCH_PORTION_SIZE + HCI_PATCH_HEADER_SIZE);
 8001c56:	f7fe fb63 	bl	8000320 <SpiWrite>
		
		while (usDataLength)
		{
			if (usDataLength <= SL_PATCH_PORTION_SIZE)
 8001c5a:	f5b5 7f7a 	cmp.w	r5, #1000	; 0x3e8
 8001c5e:	d905      	bls.n	8001c6c <hci_patch_send+0x9e>
				
			}
			else
			{
				usTransLength = SL_PATCH_PORTION_SIZE;
				usDataLength -= usTransLength;
 8001c60:	f5a5 707a 	sub.w	r0, r5, #1000	; 0x3e8
 8001c64:	b285      	uxth	r5, r0
				usDataLength = 0;
				
			}
			else
			{
				usTransLength = SL_PATCH_PORTION_SIZE;
 8001c66:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
 8001c6a:	e001      	b.n	8001c70 <hci_patch_send+0xa2>
		// Update the opcode of the event we will be waiting for
		SpiWrite(pucBuff, SL_PATCH_PORTION_SIZE + HCI_PATCH_HEADER_SIZE);
		
		while (usDataLength)
		{
			if (usDataLength <= SL_PATCH_PORTION_SIZE)
 8001c6c:	462e      	mov	r6, r5
			{
				usTransLength = usDataLength;
				usDataLength = 0;
 8001c6e:	2500      	movs	r5, #0
			{
				usTransLength = SL_PATCH_PORTION_SIZE;
				usDataLength -= usTransLength;
			}
			
			*(unsigned short *)data_ptr = usTransLength;
 8001c70:	46a0      	mov	r8, r4
			memcpy(data_ptr + SIMPLE_LINK_HCI_PATCH_HEADER_SIZE, patch, usTransLength);
 8001c72:	4639      	mov	r1, r7
			{
				usTransLength = SL_PATCH_PORTION_SIZE;
				usDataLength -= usTransLength;
			}
			
			*(unsigned short *)data_ptr = usTransLength;
 8001c74:	f828 6f05 	strh.w	r6, [r8, #5]!
			memcpy(data_ptr + SIMPLE_LINK_HCI_PATCH_HEADER_SIZE, patch, usTransLength);
 8001c78:	4648      	mov	r0, r9
 8001c7a:	4632      	mov	r2, r6
 8001c7c:	f000 f96a 	bl	8001f54 <memcpy>
			patch += usTransLength;
			
			// Update the opcode of the event we will be waiting for
			SpiWrite((unsigned char *)data_ptr, usTransLength + sizeof(usTransLength));
 8001c80:	1cb3      	adds	r3, r6, #2
 8001c82:	4640      	mov	r0, r8
 8001c84:	b299      	uxth	r1, r3
				usDataLength -= usTransLength;
			}
			
			*(unsigned short *)data_ptr = usTransLength;
			memcpy(data_ptr + SIMPLE_LINK_HCI_PATCH_HEADER_SIZE, patch, usTransLength);
			patch += usTransLength;
 8001c86:	19bf      	adds	r7, r7, r6
			
			// Update the opcode of the event we will be waiting for
			SpiWrite((unsigned char *)data_ptr, usTransLength + sizeof(usTransLength));
 8001c88:	f7fe fb4a 	bl	8000320 <SpiWrite>
		patch += SL_PATCH_PORTION_SIZE;
		
		// Update the opcode of the event we will be waiting for
		SpiWrite(pucBuff, SL_PATCH_PORTION_SIZE + HCI_PATCH_HEADER_SIZE);
		
		while (usDataLength)
 8001c8c:	2d00      	cmp	r5, #0
 8001c8e:	d1e4      	bne.n	8001c5a <hci_patch_send+0x8c>
			
			// Update the opcode of the event we will be waiting for
			SpiWrite((unsigned char *)data_ptr, usTransLength + sizeof(usTransLength));
		}
	}
}
 8001c90:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

08001c94 <nvmem_read>:
//!	 
//*****************************************************************************

signed long 
nvmem_read(unsigned long ulFileId, unsigned long ulLength, unsigned long ulOffset, unsigned char *buff)
{
 8001c94:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 8001c98:	4686      	mov	lr, r0
	unsigned char ucStatus = 0xFF;
	unsigned char *ptr;
	unsigned char *args;
	
	ptr = tSLInformation.pucTxCommandBuffer;
 8001c9a:	4814      	ldr	r0, [pc, #80]	; (8001cec <nvmem_read+0x58>)
//!	 
//*****************************************************************************

signed long 
nvmem_read(unsigned long ulFileId, unsigned long ulLength, unsigned long ulOffset, unsigned char *buff)
{
 8001c9c:	460d      	mov	r5, r1
	unsigned char ucStatus = 0xFF;
	unsigned char *ptr;
	unsigned char *args;
	
	ptr = tSLInformation.pucTxCommandBuffer;
 8001c9e:	6886      	ldr	r6, [r0, #8]
	args = (ptr + HEADERS_SIZE_CMD);
	
	// Fill in HCI packet structure
	args = UINT32_TO_STREAM(args, ulFileId);
 8001ca0:	4671      	mov	r1, lr
//!	 
//*****************************************************************************

signed long 
nvmem_read(unsigned long ulFileId, unsigned long ulLength, unsigned long ulOffset, unsigned char *buff)
{
 8001ca2:	461f      	mov	r7, r3
	unsigned char ucStatus = 0xFF;
 8001ca4:	ac02      	add	r4, sp, #8
 8001ca6:	23ff      	movs	r3, #255	; 0xff
	
	ptr = tSLInformation.pucTxCommandBuffer;
	args = (ptr + HEADERS_SIZE_CMD);
	
	// Fill in HCI packet structure
	args = UINT32_TO_STREAM(args, ulFileId);
 8001ca8:	f106 0009 	add.w	r0, r6, #9
//*****************************************************************************

signed long 
nvmem_read(unsigned long ulFileId, unsigned long ulLength, unsigned long ulOffset, unsigned char *buff)
{
	unsigned char ucStatus = 0xFF;
 8001cac:	f804 3d01 	strb.w	r3, [r4, #-1]!
//!	 
//*****************************************************************************

signed long 
nvmem_read(unsigned long ulFileId, unsigned long ulLength, unsigned long ulOffset, unsigned char *buff)
{
 8001cb0:	4690      	mov	r8, r2
	
	ptr = tSLInformation.pucTxCommandBuffer;
	args = (ptr + HEADERS_SIZE_CMD);
	
	// Fill in HCI packet structure
	args = UINT32_TO_STREAM(args, ulFileId);
 8001cb2:	f7ff fc13 	bl	80014dc <UINT32_TO_STREAM_f>
	args = UINT32_TO_STREAM(args, ulLength);
 8001cb6:	4629      	mov	r1, r5
 8001cb8:	f7ff fc10 	bl	80014dc <UINT32_TO_STREAM_f>
	args = UINT32_TO_STREAM(args, ulOffset);
	
	// Initiate a HCI command
	hci_command_send(HCI_CMND_NVMEM_READ, ptr, NVMEM_READ_PARAMS_LEN);
 8001cbc:	f240 2501 	movw	r5, #513	; 0x201
	args = (ptr + HEADERS_SIZE_CMD);
	
	// Fill in HCI packet structure
	args = UINT32_TO_STREAM(args, ulFileId);
	args = UINT32_TO_STREAM(args, ulLength);
	args = UINT32_TO_STREAM(args, ulOffset);
 8001cc0:	4641      	mov	r1, r8
 8001cc2:	f7ff fc0b 	bl	80014dc <UINT32_TO_STREAM_f>
	
	// Initiate a HCI command
	hci_command_send(HCI_CMND_NVMEM_READ, ptr, NVMEM_READ_PARAMS_LEN);
 8001cc6:	220c      	movs	r2, #12
 8001cc8:	4631      	mov	r1, r6
 8001cca:	4628      	mov	r0, r5
 8001ccc:	f7ff ff5a 	bl	8001b84 <hci_command_send>
	SimpleLinkWaitEvent(HCI_CMND_NVMEM_READ, &ucStatus);
 8001cd0:	4628      	mov	r0, r5
 8001cd2:	4621      	mov	r1, r4
 8001cd4:	f7ff ff42 	bl	8001b5c <SimpleLinkWaitEvent>
   // Note: It is the user responsibility to ignore the data in case of an error code
	
	// Wait for the data in a synchronous way. Here we assume that the buffer is 
	// big enough to store also parameters of nvmem
	
	SimpleLinkWaitData(buff, 0, 0);
 8001cd8:	2100      	movs	r1, #0
 8001cda:	4638      	mov	r0, r7
 8001cdc:	460a      	mov	r2, r1
 8001cde:	f7ff ff47 	bl	8001b70 <SimpleLinkWaitData>
	
	return(ucStatus);
}
 8001ce2:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8001ce6:	e8bd 81fc 	ldmia.w	sp!, {r2, r3, r4, r5, r6, r7, r8, pc}
 8001cea:	bf00      	nop
 8001cec:	200009b8 	.word	0x200009b8

08001cf0 <nvmem_write>:
//*****************************************************************************

signed long 
nvmem_write(unsigned long ulFileId, unsigned long ulLength, unsigned long 
						ulEntryOffset, unsigned char *buff)
{
 8001cf0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 8001cf4:	4686      	mov	lr, r0
	unsigned char *ptr;
	unsigned char *args;
	
	iRes = EFAIL;
	
	ptr = tSLInformation.pucTxCommandBuffer;
 8001cf6:	4816      	ldr	r0, [pc, #88]	; (8001d50 <nvmem_write+0x60>)
//*****************************************************************************

signed long 
nvmem_write(unsigned long ulFileId, unsigned long ulLength, unsigned long 
						ulEntryOffset, unsigned char *buff)
{
 8001cf8:	460c      	mov	r4, r1
	unsigned char *ptr;
	unsigned char *args;
	
	iRes = EFAIL;
	
	ptr = tSLInformation.pucTxCommandBuffer;
 8001cfa:	6886      	ldr	r6, [r0, #8]
	args = (ptr + SPI_HEADER_SIZE + HCI_DATA_CMD_HEADER_SIZE);
	
	// Fill in HCI packet structure
	args = UINT32_TO_STREAM(args, ulFileId);
 8001cfc:	4671      	mov	r1, lr
//*****************************************************************************

signed long 
nvmem_write(unsigned long ulFileId, unsigned long ulLength, unsigned long 
						ulEntryOffset, unsigned char *buff)
{
 8001cfe:	4698      	mov	r8, r3
	long iRes;
	unsigned char *ptr;
	unsigned char *args;
	
	iRes = EFAIL;
 8001d00:	ad02      	add	r5, sp, #8
 8001d02:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
	
	ptr = tSLInformation.pucTxCommandBuffer;
	args = (ptr + SPI_HEADER_SIZE + HCI_DATA_CMD_HEADER_SIZE);
	
	// Fill in HCI packet structure
	args = UINT32_TO_STREAM(args, ulFileId);
 8001d06:	f106 000a 	add.w	r0, r6, #10
{
	long iRes;
	unsigned char *ptr;
	unsigned char *args;
	
	iRes = EFAIL;
 8001d0a:	f845 3d04 	str.w	r3, [r5, #-4]!
//*****************************************************************************

signed long 
nvmem_write(unsigned long ulFileId, unsigned long ulLength, unsigned long 
						ulEntryOffset, unsigned char *buff)
{
 8001d0e:	4617      	mov	r7, r2
	
	ptr = tSLInformation.pucTxCommandBuffer;
	args = (ptr + SPI_HEADER_SIZE + HCI_DATA_CMD_HEADER_SIZE);
	
	// Fill in HCI packet structure
	args = UINT32_TO_STREAM(args, ulFileId);
 8001d10:	f7ff fbe4 	bl	80014dc <UINT32_TO_STREAM_f>
	args = UINT32_TO_STREAM(args, 12);
 8001d14:	210c      	movs	r1, #12
 8001d16:	f7ff fbe1 	bl	80014dc <UINT32_TO_STREAM_f>
	args = UINT32_TO_STREAM(args, ulLength);
 8001d1a:	4621      	mov	r1, r4
 8001d1c:	f7ff fbde 	bl	80014dc <UINT32_TO_STREAM_f>
	args = UINT32_TO_STREAM(args, ulEntryOffset);
 8001d20:	4639      	mov	r1, r7
 8001d22:	f7ff fbdb 	bl	80014dc <UINT32_TO_STREAM_f>
	
	memcpy((ptr + SPI_HEADER_SIZE + HCI_DATA_CMD_HEADER_SIZE + 
 8001d26:	4641      	mov	r1, r8
 8001d28:	4622      	mov	r2, r4
 8001d2a:	f106 001a 	add.w	r0, r6, #26
 8001d2e:	f000 f911 	bl	8001f54 <memcpy>
					NVMEM_WRITE_PARAMS_LEN),buff,ulLength);
	
	// Initiate a HCI command but it will come on data channel
	hci_data_command_send(HCI_CMND_NVMEM_WRITE, ptr, NVMEM_WRITE_PARAMS_LEN,
 8001d32:	2090      	movs	r0, #144	; 0x90
 8001d34:	4631      	mov	r1, r6
 8001d36:	2210      	movs	r2, #16
 8001d38:	b2a3      	uxth	r3, r4
 8001d3a:	f7ff ff34 	bl	8001ba6 <hci_data_command_send>
												ulLength);
	
	SimpleLinkWaitEvent(HCI_EVNT_NVMEM_WRITE, &iRes);
 8001d3e:	f240 2002 	movw	r0, #514	; 0x202
 8001d42:	4629      	mov	r1, r5
 8001d44:	f7ff ff0a 	bl	8001b5c <SimpleLinkWaitEvent>
	
	return(iRes);
}
 8001d48:	9801      	ldr	r0, [sp, #4]
 8001d4a:	e8bd 81fc 	ldmia.w	sp!, {r2, r3, r4, r5, r6, r7, r8, pc}
 8001d4e:	bf00      	nop
 8001d50:	200009b8 	.word	0x200009b8

08001d54 <nvmem_set_mac_address>:
//!               mac address as appears over the air (OUI first)
//!	 
//*****************************************************************************

unsigned char nvmem_set_mac_address(unsigned char *mac)
{
 8001d54:	b508      	push	{r3, lr}
 8001d56:	4603      	mov	r3, r0
	return  nvmem_write(NVMEM_MAC_FILEID, MAC_ADDR_LEN, 0, mac);
 8001d58:	2006      	movs	r0, #6
 8001d5a:	4601      	mov	r1, r0
 8001d5c:	2200      	movs	r2, #0
 8001d5e:	f7ff ffc7 	bl	8001cf0 <nvmem_write>
}
 8001d62:	b2c0      	uxtb	r0, r0
 8001d64:	bd08      	pop	{r3, pc}

08001d66 <nvmem_get_mac_address>:
//!               mac address as appears over the air (OUI first)
//!	 
//*****************************************************************************

unsigned char nvmem_get_mac_address(unsigned char *mac)
{
 8001d66:	b508      	push	{r3, lr}
 8001d68:	4603      	mov	r3, r0
	return  nvmem_read(NVMEM_MAC_FILEID, MAC_ADDR_LEN, 0, mac);
 8001d6a:	2006      	movs	r0, #6
 8001d6c:	4601      	mov	r1, r0
 8001d6e:	2200      	movs	r2, #0
 8001d70:	f7ff ff90 	bl	8001c94 <nvmem_read>
}
 8001d74:	b2c0      	uxtb	r0, r0
 8001d76:	bd08      	pop	{r3, pc}

08001d78 <nvmem_write_patch>:
//!              applied in SP_PORTION_SIZE bytes portions.
//!	 
//*****************************************************************************

unsigned char nvmem_write_patch(unsigned long ulFileId, unsigned long spLength, const unsigned char *spData)
{
 8001d78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001d7a:	4606      	mov	r6, r0
 8001d7c:	460d      	mov	r5, r1
 8001d7e:	4617      	mov	r7, r2
 8001d80:	460c      	mov	r4, r1
//!              Each line is SP_PORTION_SIZE bytes long. Actual programming is 
//!              applied in SP_PORTION_SIZE bytes portions.
//!	 
//*****************************************************************************

unsigned char nvmem_write_patch(unsigned long ulFileId, unsigned long spLength, const unsigned char *spData)
 8001d82:	197b      	adds	r3, r7, r5
 8001d84:	1b2a      	subs	r2, r5, r4
{
	unsigned char 	status = 0;
	unsigned short	offset = 0;
	unsigned char*      spDataPtr = (unsigned char*)spData;
	
	while ((status == 0) && (spLength >= SP_PORTION_SIZE))
 8001d86:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
//!              Each line is SP_PORTION_SIZE bytes long. Actual programming is 
//!              applied in SP_PORTION_SIZE bytes portions.
//!	 
//*****************************************************************************

unsigned char nvmem_write_patch(unsigned long ulFileId, unsigned long spLength, const unsigned char *spData)
 8001d8a:	ebc4 0303 	rsb	r3, r4, r3
 8001d8e:	b292      	uxth	r2, r2
{
	unsigned char 	status = 0;
	unsigned short	offset = 0;
	unsigned char*      spDataPtr = (unsigned char*)spData;
	
	while ((status == 0) && (spLength >= SP_PORTION_SIZE))
 8001d90:	d30a      	bcc.n	8001da8 <nvmem_write_patch+0x30>
	{
		status = nvmem_write(ulFileId, SP_PORTION_SIZE, offset, spDataPtr);
 8001d92:	4630      	mov	r0, r6
 8001d94:	f44f 7100 	mov.w	r1, #512	; 0x200
 8001d98:	f7ff ffaa 	bl	8001cf0 <nvmem_write>
 8001d9c:	b2c0      	uxtb	r0, r0
		offset += SP_PORTION_SIZE;
		spLength -= SP_PORTION_SIZE;
 8001d9e:	f5a4 7400 	sub.w	r4, r4, #512	; 0x200
{
	unsigned char 	status = 0;
	unsigned short	offset = 0;
	unsigned char*      spDataPtr = (unsigned char*)spData;
	
	while ((status == 0) && (spLength >= SP_PORTION_SIZE))
 8001da2:	2800      	cmp	r0, #0
 8001da4:	d0ed      	beq.n	8001d82 <nvmem_write_patch+0xa>
 8001da6:	e007      	b.n	8001db8 <nvmem_write_patch+0x40>
	{
		// NVMEM error occurred
		return status;
	}
	
	if (spLength != 0)
 8001da8:	b12c      	cbz	r4, 8001db6 <nvmem_write_patch+0x3e>
	{
		// if reached here, a reminder is left
		status = nvmem_write(ulFileId, spLength, offset, spDataPtr);
 8001daa:	4630      	mov	r0, r6
 8001dac:	4621      	mov	r1, r4
 8001dae:	f7ff ff9f 	bl	8001cf0 <nvmem_write>
 8001db2:	b2c0      	uxtb	r0, r0
 8001db4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	{
		// NVMEM error occurred
		return status;
	}
	
	if (spLength != 0)
 8001db6:	4620      	mov	r0, r4
		// if reached here, a reminder is left
		status = nvmem_write(ulFileId, spLength, offset, spDataPtr);
	}
	
	return status;
}
 8001db8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08001dbc <SpiReceiveHandler>:
//! 			          called from the SPI library to receive the data
//
//*****************************************************************************
void SpiReceiveHandler(void *pvBuffer)
{	
	tSLInformation.usEventOrDataReceived = 1;
 8001dbc:	4b02      	ldr	r3, [pc, #8]	; (8001dc8 <SpiReceiveHandler+0xc>)
 8001dbe:	2201      	movs	r2, #1
 8001dc0:	805a      	strh	r2, [r3, #2]
	tSLInformation.pucReceivedData = (unsigned char 	*)pvBuffer;
 8001dc2:	6058      	str	r0, [r3, #4]
	
	hci_unsolicited_event_handler();
 8001dc4:	f7ff bcf2 	b.w	80017ac <hci_unsolicited_event_handler>
 8001dc8:	200009b8 	.word	0x200009b8

08001dcc <wlan_init>:
							 tBootLoaderPatches sBootLoaderPatches,
							 tWlanReadInteruptPin  sReadWlanInterruptPin,
							 tWlanInterruptEnable  sWlanInterruptEnable,
							 tWlanInterruptDisable sWlanInterruptDisable,
							 tWriteWlanPin         sWriteWlanPin)
{
 8001dcc:	b510      	push	{r4, lr}
	
	tSLInformation.sFWPatches = sFWPatches;
 8001dce:	4c08      	ldr	r4, [pc, #32]	; (8001df0 <wlan_init+0x24>)
 8001dd0:	60e1      	str	r1, [r4, #12]
	tSLInformation.sDriverPatches = sDriverPatches;
 8001dd2:	6122      	str	r2, [r4, #16]
	tSLInformation.sBootLoaderPatches = sBootLoaderPatches;
 8001dd4:	6163      	str	r3, [r4, #20]
	
	// init io callback
	tSLInformation.ReadWlanInterruptPin = sReadWlanInterruptPin;
 8001dd6:	9b02      	ldr	r3, [sp, #8]
	tSLInformation.WlanInterruptEnable  = sWlanInterruptEnable;
 8001dd8:	9903      	ldr	r1, [sp, #12]
	tSLInformation.sFWPatches = sFWPatches;
	tSLInformation.sDriverPatches = sDriverPatches;
	tSLInformation.sBootLoaderPatches = sBootLoaderPatches;
	
	// init io callback
	tSLInformation.ReadWlanInterruptPin = sReadWlanInterruptPin;
 8001dda:	61e3      	str	r3, [r4, #28]
	tSLInformation.WlanInterruptEnable  = sWlanInterruptEnable;
	tSLInformation.WlanInterruptDisable = sWlanInterruptDisable;
 8001ddc:	9a04      	ldr	r2, [sp, #16]
	tSLInformation.WriteWlanPin = sWriteWlanPin;
 8001dde:	9b05      	ldr	r3, [sp, #20]
	tSLInformation.sDriverPatches = sDriverPatches;
	tSLInformation.sBootLoaderPatches = sBootLoaderPatches;
	
	// init io callback
	tSLInformation.ReadWlanInterruptPin = sReadWlanInterruptPin;
	tSLInformation.WlanInterruptEnable  = sWlanInterruptEnable;
 8001de0:	6221      	str	r1, [r4, #32]
	tSLInformation.WlanInterruptDisable = sWlanInterruptDisable;
 8001de2:	6262      	str	r2, [r4, #36]	; 0x24
	tSLInformation.WriteWlanPin = sWriteWlanPin;
 8001de4:	62a3      	str	r3, [r4, #40]	; 0x28
	
	//init asynchronous events callback
	tSLInformation.sWlanCB= sWlanCB;
 8001de6:	61a0      	str	r0, [r4, #24]
	
	// By default TX Complete events are routed to host too
	tSLInformation.InformHostOnTxComplete = 1;
 8001de8:	2001      	movs	r0, #1
 8001dea:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
 8001dee:	bd10      	pop	{r4, pc}
 8001df0:	200009b8 	.word	0x200009b8

08001df4 <wlan_start>:
//
//*****************************************************************************

void
wlan_start(unsigned short usPatchesAvailableAtHost)
{
 8001df4:	b570      	push	{r4, r5, r6, lr}
	
	unsigned long ulSpiIRQState;
	
	tSLInformation.NumberOfSentPackets = 0;
 8001df6:	4c21      	ldr	r4, [pc, #132]	; (8001e7c <wlan_start+0x88>)
//
//*****************************************************************************

void
wlan_start(unsigned short usPatchesAvailableAtHost)
{
 8001df8:	4605      	mov	r5, r0
	tSLInformation.slTransmitDataError = 0;
	tSLInformation.usEventOrDataReceived = 0;
	tSLInformation.pucReceivedData = 0;
	
	// Allocate the memory for the RX/TX data transactions
	tSLInformation.pucTxCommandBuffer = (unsigned char *)wlan_tx_buffer;
 8001dfa:	4821      	ldr	r0, [pc, #132]	; (8001e80 <wlan_start+0x8c>)
wlan_start(unsigned short usPatchesAvailableAtHost)
{
	
	unsigned long ulSpiIRQState;
	
	tSLInformation.NumberOfSentPackets = 0;
 8001dfc:	2300      	movs	r3, #0
 8001dfe:	63a3      	str	r3, [r4, #56]	; 0x38
	tSLInformation.NumberOfReleasedPackets = 0;
 8001e00:	63e3      	str	r3, [r4, #60]	; 0x3c
	tSLInformation.usRxEventOpcode = 0;
 8001e02:	8023      	strh	r3, [r4, #0]
	tSLInformation.usNumberOfFreeBuffers = 0;
 8001e04:	8623      	strh	r3, [r4, #48]	; 0x30
	tSLInformation.usSlBufferLength = 0;
 8001e06:	8663      	strh	r3, [r4, #50]	; 0x32
	tSLInformation.usBufferSize = 0;
 8001e08:	86a3      	strh	r3, [r4, #52]	; 0x34
	tSLInformation.usRxDataPending = 0;
 8001e0a:	86e3      	strh	r3, [r4, #54]	; 0x36
	tSLInformation.slTransmitDataError = 0;
 8001e0c:	62e3      	str	r3, [r4, #44]	; 0x2c
	tSLInformation.usEventOrDataReceived = 0;
 8001e0e:	8063      	strh	r3, [r4, #2]
	tSLInformation.pucReceivedData = 0;
 8001e10:	6063      	str	r3, [r4, #4]
	
	// Allocate the memory for the RX/TX data transactions
	tSLInformation.pucTxCommandBuffer = (unsigned char *)wlan_tx_buffer;
 8001e12:	60a0      	str	r0, [r4, #8]
	
	// init spi
	SpiOpen(SpiReceiveHandler);
 8001e14:	481b      	ldr	r0, [pc, #108]	; (8001e84 <wlan_start+0x90>)
 8001e16:	f7fe f9a1 	bl	800015c <SpiOpen>
	
	// Check the IRQ line
	ulSpiIRQState = tSLInformation.ReadWlanInterruptPin();
 8001e1a:	69e1      	ldr	r1, [r4, #28]
 8001e1c:	4788      	blx	r1
	
	// ASIC 1273 chip enable: toggle WLAN EN line
	tSLInformation.WriteWlanPin( WLAN_ENABLE );
 8001e1e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
	
	// init spi
	SpiOpen(SpiReceiveHandler);
	
	// Check the IRQ line
	ulSpiIRQState = tSLInformation.ReadWlanInterruptPin();
 8001e20:	4606      	mov	r6, r0
	
	// ASIC 1273 chip enable: toggle WLAN EN line
	tSLInformation.WriteWlanPin( WLAN_ENABLE );
 8001e22:	2001      	movs	r0, #1
 8001e24:	4790      	blx	r2
	
	if (ulSpiIRQState)
 8001e26:	b306      	cbz	r6, 8001e6a <wlan_start+0x76>
	{
		// wait till the IRQ line goes low
		while(tSLInformation.ReadWlanInterruptPin() != 0)
 8001e28:	69e1      	ldr	r1, [r4, #28]
 8001e2a:	4788      	blx	r1
 8001e2c:	2800      	cmp	r0, #0
 8001e2e:	d1fb      	bne.n	8001e28 <wlan_start+0x34>
static void SimpleLink_Init_Start(unsigned short usPatchesAvailableAtHost)
{
	unsigned char *ptr;
	unsigned char *args;
	
	ptr = tSLInformation.pucTxCommandBuffer;
 8001e30:	4c12      	ldr	r4, [pc, #72]	; (8001e7c <wlan_start+0x88>)
	args = (unsigned char *)(ptr + HEADERS_SIZE_CMD);
	
	UINT8_TO_STREAM(args, ((usPatchesAvailableAtHost) ? SL_PATCHES_REQUEST_FORCE_HOST : SL_PATCHES_REQUEST_DEFAULT));
 8001e32:	3500      	adds	r5, #0
static void SimpleLink_Init_Start(unsigned short usPatchesAvailableAtHost)
{
	unsigned char *ptr;
	unsigned char *args;
	
	ptr = tSLInformation.pucTxCommandBuffer;
 8001e34:	68a1      	ldr	r1, [r4, #8]
	args = (unsigned char *)(ptr + HEADERS_SIZE_CMD);
	
	UINT8_TO_STREAM(args, ((usPatchesAvailableAtHost) ? SL_PATCHES_REQUEST_FORCE_HOST : SL_PATCHES_REQUEST_DEFAULT));
 8001e36:	bf18      	it	ne
 8001e38:	2501      	movne	r5, #1
 8001e3a:	724d      	strb	r5, [r1, #9]
	
	// IRQ Line asserted - send HCI_CMND_SIMPLE_LINK_START to CC3000
	hci_command_send(HCI_CMND_SIMPLE_LINK_START, ptr, WLAN_SL_INIT_START_PARAMS_LEN);
 8001e3c:	2201      	movs	r2, #1
 8001e3e:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8001e42:	f7ff fe9f 	bl	8001b84 <hci_command_send>
	
	SimpleLinkWaitEvent(HCI_CMND_SIMPLE_LINK_START, 0);
 8001e46:	2100      	movs	r1, #0
 8001e48:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8001e4c:	f7ff fe86 	bl	8001b5c <SimpleLinkWaitEvent>
	}
	
	SimpleLink_Init_Start(usPatchesAvailableAtHost);
	
	// Read Buffer's size and finish
	hci_command_send(HCI_CMND_READ_BUFFER_SIZE, tSLInformation.pucTxCommandBuffer, 0);
 8001e50:	68a1      	ldr	r1, [r4, #8]
 8001e52:	2200      	movs	r2, #0
 8001e54:	f244 000b 	movw	r0, #16395	; 0x400b
 8001e58:	f7ff fe94 	bl	8001b84 <hci_command_send>
	SimpleLinkWaitEvent(HCI_CMND_READ_BUFFER_SIZE, 0);
 8001e5c:	f244 000b 	movw	r0, #16395	; 0x400b
 8001e60:	2100      	movs	r1, #0
}
 8001e62:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	
	SimpleLink_Init_Start(usPatchesAvailableAtHost);
	
	// Read Buffer's size and finish
	hci_command_send(HCI_CMND_READ_BUFFER_SIZE, tSLInformation.pucTxCommandBuffer, 0);
	SimpleLinkWaitEvent(HCI_CMND_READ_BUFFER_SIZE, 0);
 8001e66:	f7ff be79 	b.w	8001b5c <SimpleLinkWaitEvent>
		}
	}
	else
	{
		// wait till the IRQ line goes high and than low
		while(tSLInformation.ReadWlanInterruptPin() == 0)
 8001e6a:	69e3      	ldr	r3, [r4, #28]
 8001e6c:	4798      	blx	r3
 8001e6e:	2800      	cmp	r0, #0
 8001e70:	d0fb      	beq.n	8001e6a <wlan_start+0x76>
		{
		}
		
		while(tSLInformation.ReadWlanInterruptPin() != 0)
 8001e72:	69e0      	ldr	r0, [r4, #28]
 8001e74:	4780      	blx	r0
 8001e76:	2800      	cmp	r0, #0
 8001e78:	d1fb      	bne.n	8001e72 <wlan_start+0x7e>
 8001e7a:	e7d9      	b.n	8001e30 <wlan_start+0x3c>
 8001e7c:	200009b8 	.word	0x200009b8
 8001e80:	20000098 	.word	0x20000098
 8001e84:	08001dbd 	.word	0x08001dbd

08001e88 <wlan_stop>:
//
//*****************************************************************************

void
wlan_stop(void)
{
 8001e88:	b538      	push	{r3, r4, r5, lr}
	// ASIC 1273 chip disable
	tSLInformation.WriteWlanPin( WLAN_DISABLE );
 8001e8a:	4c09      	ldr	r4, [pc, #36]	; (8001eb0 <wlan_stop+0x28>)
 8001e8c:	2000      	movs	r0, #0
 8001e8e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001e90:	4798      	blx	r3
 8001e92:	4625      	mov	r5, r4
	
	// Wait till IRQ line goes high...
	while(tSLInformation.ReadWlanInterruptPin() == 0)
 8001e94:	69e8      	ldr	r0, [r5, #28]
 8001e96:	4c06      	ldr	r4, [pc, #24]	; (8001eb0 <wlan_stop+0x28>)
 8001e98:	4780      	blx	r0
 8001e9a:	2800      	cmp	r0, #0
 8001e9c:	d0fa      	beq.n	8001e94 <wlan_stop+0xc>
	{
	}
	
	// Free the used by WLAN Driver memory
	if (tSLInformation.pucTxCommandBuffer)
 8001e9e:	68a1      	ldr	r1, [r4, #8]
 8001ea0:	b109      	cbz	r1, 8001ea6 <wlan_stop+0x1e>
	{
		tSLInformation.pucTxCommandBuffer = 0;
 8001ea2:	2200      	movs	r2, #0
 8001ea4:	60a2      	str	r2, [r4, #8]
	}
	
	SpiClose();
}
 8001ea6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	if (tSLInformation.pucTxCommandBuffer)
	{
		tSLInformation.pucTxCommandBuffer = 0;
	}
	
	SpiClose();
 8001eaa:	f7fe b96b 	b.w	8000184 <SpiClose>
 8001eae:	bf00      	nop
 8001eb0:	200009b8 	.word	0x200009b8

08001eb4 <wlan_set_event_mask>:
//
//*****************************************************************************

long
wlan_set_event_mask(unsigned long ulMask)
{
 8001eb4:	b537      	push	{r0, r1, r2, r4, r5, lr}
	long ret;
	unsigned char *ptr;
	unsigned char *args;
	
	
	if ((ulMask & HCI_EVNT_WLAN_TX_COMPLETE) == HCI_EVNT_WLAN_TX_COMPLETE)
 8001eb6:	f248 0208 	movw	r2, #32776	; 0x8008
 8001eba:	f248 0108 	movw	r1, #32776	; 0x8008
 8001ebe:	4002      	ands	r2, r0
 8001ec0:	428a      	cmp	r2, r1
//
//*****************************************************************************

long
wlan_set_event_mask(unsigned long ulMask)
{
 8001ec2:	4603      	mov	r3, r0
 8001ec4:	4913      	ldr	r1, [pc, #76]	; (8001f14 <wlan_set_event_mask+0x60>)
	long ret;
	unsigned char *ptr;
	unsigned char *args;
	
	
	if ((ulMask & HCI_EVNT_WLAN_TX_COMPLETE) == HCI_EVNT_WLAN_TX_COMPLETE)
 8001ec6:	d10b      	bne.n	8001ee0 <wlan_set_event_mask+0x2c>
	{
		tSLInformation.InformHostOnTxComplete = 0;
 8001ec8:	2000      	movs	r0, #0
		
		// Since an event is a virtual event - i.e. it is not coming from CC3000
		// there is no need to send anything to the device if it was an only event
		if (ulMask == HCI_EVNT_WLAN_TX_COMPLETE)
 8001eca:	4293      	cmp	r3, r2
	unsigned char *args;
	
	
	if ((ulMask & HCI_EVNT_WLAN_TX_COMPLETE) == HCI_EVNT_WLAN_TX_COMPLETE)
	{
		tSLInformation.InformHostOnTxComplete = 0;
 8001ecc:	f881 0040 	strb.w	r0, [r1, #64]	; 0x40
		
		// Since an event is a virtual event - i.e. it is not coming from CC3000
		// there is no need to send anything to the device if it was an only event
		if (ulMask == HCI_EVNT_WLAN_TX_COMPLETE)
 8001ed0:	d01f      	beq.n	8001f12 <wlan_set_event_mask+0x5e>
		{
			return 0;
		}
		
		ulMask &= ~HCI_EVNT_WLAN_TX_COMPLETE;
 8001ed2:	f423 4400 	bic.w	r4, r3, #32768	; 0x8000
 8001ed6:	f024 0508 	bic.w	r5, r4, #8
		ulMask |= HCI_EVNT_WLAN_UNSOL_BASE;
 8001eda:	f445 4300 	orr.w	r3, r5, #32768	; 0x8000
 8001ede:	e002      	b.n	8001ee6 <wlan_set_event_mask+0x32>
	}
	else
	{
		tSLInformation.InformHostOnTxComplete = 1;
 8001ee0:	2001      	movs	r0, #1
 8001ee2:	f881 0040 	strb.w	r0, [r1, #64]	; 0x40
	}
	
	ret = EFAIL;
	ptr = tSLInformation.pucTxCommandBuffer;
 8001ee6:	490b      	ldr	r1, [pc, #44]	; (8001f14 <wlan_set_event_mask+0x60>)
	else
	{
		tSLInformation.InformHostOnTxComplete = 1;
	}
	
	ret = EFAIL;
 8001ee8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
	ptr = tSLInformation.pucTxCommandBuffer;
 8001eec:	688d      	ldr	r5, [r1, #8]
	else
	{
		tSLInformation.InformHostOnTxComplete = 1;
	}
	
	ret = EFAIL;
 8001eee:	ac02      	add	r4, sp, #8
	ptr = tSLInformation.pucTxCommandBuffer;
	args = (unsigned char *)(ptr + HEADERS_SIZE_CMD);
	
	// Fill in HCI packet structure
	args = UINT32_TO_STREAM(args, ulMask);
 8001ef0:	4619      	mov	r1, r3
 8001ef2:	f105 0009 	add.w	r0, r5, #9
	else
	{
		tSLInformation.InformHostOnTxComplete = 1;
	}
	
	ret = EFAIL;
 8001ef6:	f844 2d04 	str.w	r2, [r4, #-4]!
	ptr = tSLInformation.pucTxCommandBuffer;
	args = (unsigned char *)(ptr + HEADERS_SIZE_CMD);
	
	// Fill in HCI packet structure
	args = UINT32_TO_STREAM(args, ulMask);
 8001efa:	f7ff faef 	bl	80014dc <UINT32_TO_STREAM_f>
	
	// Initiate a HCI command
	hci_command_send(HCI_CMND_EVENT_MASK,
 8001efe:	4629      	mov	r1, r5
 8001f00:	2204      	movs	r2, #4
 8001f02:	2008      	movs	r0, #8
 8001f04:	f7ff fe3e 	bl	8001b84 <hci_command_send>
									 ptr, WLAN_SET_MASK_PARAMS_LEN);
	
	// Wait for command complete event
	SimpleLinkWaitEvent(HCI_CMND_EVENT_MASK, &ret);
 8001f08:	2008      	movs	r0, #8
 8001f0a:	4621      	mov	r1, r4
 8001f0c:	f7ff fe26 	bl	8001b5c <SimpleLinkWaitEvent>
	
	return(ret);
 8001f10:	9801      	ldr	r0, [sp, #4]
}
 8001f12:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 8001f14:	200009b8 	.word	0x200009b8

08001f18 <wlan_smart_config_set_prefix>:
//
//*****************************************************************************

long
wlan_smart_config_set_prefix(char* cNewPrefix)
{
 8001f18:	b507      	push	{r0, r1, r2, lr}
	long ret;
	unsigned char *ptr;
	unsigned char *args;
	
	ret = EFAIL;
	ptr = tSLInformation.pucTxCommandBuffer;
 8001f1a:	4a0d      	ldr	r2, [pc, #52]	; (8001f50 <wlan_smart_config_set_prefix+0x38>)
{
	long ret;
	unsigned char *ptr;
	unsigned char *args;
	
	ret = EFAIL;
 8001f1c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8001f20:	9301      	str	r3, [sp, #4]
	ptr = tSLInformation.pucTxCommandBuffer;
 8001f22:	6891      	ldr	r1, [r2, #8]
	args = (ptr + HEADERS_SIZE_CMD);
	
	if (cNewPrefix == NULL)
 8001f24:	b190      	cbz	r0, 8001f4c <wlan_smart_config_set_prefix+0x34>
		return ret;
	else	// with the new Smart Config, prefix must be TTT
	{
		*cNewPrefix = 'T';
 8001f26:	2354      	movs	r3, #84	; 0x54
		*(cNewPrefix + 1) = 'T';
 8001f28:	7043      	strb	r3, [r0, #1]
	
	if (cNewPrefix == NULL)
		return ret;
	else	// with the new Smart Config, prefix must be TTT
	{
		*cNewPrefix = 'T';
 8001f2a:	7003      	strb	r3, [r0, #0]
		*(cNewPrefix + 1) = 'T';
		*(cNewPrefix + 2) = 'T';
 8001f2c:	7083      	strb	r3, [r0, #2]
	}
	
	ARRAY_TO_STREAM(args, cNewPrefix, SL_SIMPLE_CONFIG_PREFIX_LENGTH);
 8001f2e:	724b      	strb	r3, [r1, #9]
 8001f30:	7842      	ldrb	r2, [r0, #1]
 8001f32:	728a      	strb	r2, [r1, #10]
 8001f34:	7880      	ldrb	r0, [r0, #2]
	
	hci_command_send(HCI_CMND_WLAN_IOCTL_SIMPLE_CONFIG_SET_PREFIX, ptr, 
 8001f36:	2203      	movs	r2, #3
		*cNewPrefix = 'T';
		*(cNewPrefix + 1) = 'T';
		*(cNewPrefix + 2) = 'T';
	}
	
	ARRAY_TO_STREAM(args, cNewPrefix, SL_SIMPLE_CONFIG_PREFIX_LENGTH);
 8001f38:	72c8      	strb	r0, [r1, #11]
	
	hci_command_send(HCI_CMND_WLAN_IOCTL_SIMPLE_CONFIG_SET_PREFIX, ptr, 
 8001f3a:	200c      	movs	r0, #12
 8001f3c:	f7ff fe22 	bl	8001b84 <hci_command_send>
									 SL_SIMPLE_CONFIG_PREFIX_LENGTH);
	
	// Wait for command complete event
	SimpleLinkWaitEvent(HCI_CMND_WLAN_IOCTL_SIMPLE_CONFIG_SET_PREFIX, &ret);
 8001f40:	200c      	movs	r0, #12
 8001f42:	a901      	add	r1, sp, #4
 8001f44:	f7ff fe0a 	bl	8001b5c <SimpleLinkWaitEvent>
	
	return(ret);    
 8001f48:	9801      	ldr	r0, [sp, #4]
 8001f4a:	e000      	b.n	8001f4e <wlan_smart_config_set_prefix+0x36>
	ret = EFAIL;
	ptr = tSLInformation.pucTxCommandBuffer;
	args = (ptr + HEADERS_SIZE_CMD);
	
	if (cNewPrefix == NULL)
		return ret;
 8001f4c:	4618      	mov	r0, r3
	
	// Wait for command complete event
	SimpleLinkWaitEvent(HCI_CMND_WLAN_IOCTL_SIMPLE_CONFIG_SET_PREFIX, &ret);
	
	return(ret);    
}
 8001f4e:	bd0e      	pop	{r1, r2, r3, pc}
 8001f50:	200009b8 	.word	0x200009b8

08001f54 <memcpy>:
 8001f54:	2a0f      	cmp	r2, #15
 8001f56:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
 8001f5a:	f240 80a1 	bls.w	80020a0 <memcpy+0x14c>
 8001f5e:	ea41 0300 	orr.w	r3, r1, r0
 8001f62:	079b      	lsls	r3, r3, #30
 8001f64:	f040 809e 	bne.w	80020a4 <memcpy+0x150>
 8001f68:	680c      	ldr	r4, [r1, #0]
 8001f6a:	f1a2 0510 	sub.w	r5, r2, #16
 8001f6e:	6004      	str	r4, [r0, #0]
 8001f70:	684b      	ldr	r3, [r1, #4]
 8001f72:	46ac      	mov	ip, r5
 8001f74:	6043      	str	r3, [r0, #4]
 8001f76:	688c      	ldr	r4, [r1, #8]
 8001f78:	f1bc 0f0f 	cmp.w	ip, #15
 8001f7c:	6084      	str	r4, [r0, #8]
 8001f7e:	68cc      	ldr	r4, [r1, #12]
 8001f80:	f3c5 1500 	ubfx	r5, r5, #4, #1
 8001f84:	60c4      	str	r4, [r0, #12]
 8001f86:	f100 0310 	add.w	r3, r0, #16
 8001f8a:	f101 0410 	add.w	r4, r1, #16
 8001f8e:	d92b      	bls.n	8001fe8 <memcpy+0x94>
 8001f90:	b175      	cbz	r5, 8001fb0 <memcpy+0x5c>
 8001f92:	6825      	ldr	r5, [r4, #0]
 8001f94:	f1ac 0c10 	sub.w	ip, ip, #16
 8001f98:	601d      	str	r5, [r3, #0]
 8001f9a:	6865      	ldr	r5, [r4, #4]
 8001f9c:	605d      	str	r5, [r3, #4]
 8001f9e:	68a5      	ldr	r5, [r4, #8]
 8001fa0:	609d      	str	r5, [r3, #8]
 8001fa2:	68e5      	ldr	r5, [r4, #12]
 8001fa4:	3410      	adds	r4, #16
 8001fa6:	60dd      	str	r5, [r3, #12]
 8001fa8:	3310      	adds	r3, #16
 8001faa:	f1bc 0f0f 	cmp.w	ip, #15
 8001fae:	d91b      	bls.n	8001fe8 <memcpy+0x94>
 8001fb0:	6827      	ldr	r7, [r4, #0]
 8001fb2:	f104 0610 	add.w	r6, r4, #16
 8001fb6:	601f      	str	r7, [r3, #0]
 8001fb8:	6867      	ldr	r7, [r4, #4]
 8001fba:	f103 0510 	add.w	r5, r3, #16
 8001fbe:	605f      	str	r7, [r3, #4]
 8001fc0:	68a7      	ldr	r7, [r4, #8]
 8001fc2:	f1ac 0c20 	sub.w	ip, ip, #32
 8001fc6:	609f      	str	r7, [r3, #8]
 8001fc8:	68e7      	ldr	r7, [r4, #12]
 8001fca:	60df      	str	r7, [r3, #12]
 8001fcc:	6924      	ldr	r4, [r4, #16]
 8001fce:	611c      	str	r4, [r3, #16]
 8001fd0:	6877      	ldr	r7, [r6, #4]
 8001fd2:	f106 0410 	add.w	r4, r6, #16
 8001fd6:	606f      	str	r7, [r5, #4]
 8001fd8:	68b7      	ldr	r7, [r6, #8]
 8001fda:	3320      	adds	r3, #32
 8001fdc:	60af      	str	r7, [r5, #8]
 8001fde:	68f6      	ldr	r6, [r6, #12]
 8001fe0:	f1bc 0f0f 	cmp.w	ip, #15
 8001fe4:	60ee      	str	r6, [r5, #12]
 8001fe6:	d8e3      	bhi.n	8001fb0 <memcpy+0x5c>
 8001fe8:	f1a2 0810 	sub.w	r8, r2, #16
 8001fec:	f028 030f 	bic.w	r3, r8, #15
 8001ff0:	f002 040f 	and.w	r4, r2, #15
 8001ff4:	f103 0c10 	add.w	ip, r3, #16
 8001ff8:	2c03      	cmp	r4, #3
 8001ffa:	eb00 030c 	add.w	r3, r0, ip
 8001ffe:	eb01 080c 	add.w	r8, r1, ip
 8002002:	d951      	bls.n	80020a8 <memcpy+0x154>
 8002004:	1f21      	subs	r1, r4, #4
 8002006:	ea4f 0991 	mov.w	r9, r1, lsr #2
 800200a:	4644      	mov	r4, r8
 800200c:	eb08 0c89 	add.w	ip, r8, r9, lsl #2
 8002010:	f854 6b04 	ldr.w	r6, [r4], #4
 8002014:	ebc8 010c 	rsb	r1, r8, ip
 8002018:	f10c 0c04 	add.w	ip, ip, #4
 800201c:	461d      	mov	r5, r3
 800201e:	4564      	cmp	r4, ip
 8002020:	f845 6b04 	str.w	r6, [r5], #4
 8002024:	f3c1 0180 	ubfx	r1, r1, #2, #1
 8002028:	d012      	beq.n	8002050 <memcpy+0xfc>
 800202a:	b129      	cbz	r1, 8002038 <memcpy+0xe4>
 800202c:	f854 1b04 	ldr.w	r1, [r4], #4
 8002030:	4564      	cmp	r4, ip
 8002032:	f845 1b04 	str.w	r1, [r5], #4
 8002036:	d00b      	beq.n	8002050 <memcpy+0xfc>
 8002038:	4627      	mov	r7, r4
 800203a:	f857 1b04 	ldr.w	r1, [r7], #4
 800203e:	462e      	mov	r6, r5
 8002040:	f846 1b04 	str.w	r1, [r6], #4
 8002044:	6864      	ldr	r4, [r4, #4]
 8002046:	606c      	str	r4, [r5, #4]
 8002048:	1d3c      	adds	r4, r7, #4
 800204a:	1d35      	adds	r5, r6, #4
 800204c:	4564      	cmp	r4, ip
 800204e:	d1f3      	bne.n	8002038 <memcpy+0xe4>
 8002050:	f109 0c01 	add.w	ip, r9, #1
 8002054:	ea4f 098c 	mov.w	r9, ip, lsl #2
 8002058:	f002 0203 	and.w	r2, r2, #3
 800205c:	eb08 0109 	add.w	r1, r8, r9
 8002060:	444b      	add	r3, r9
 8002062:	b1d2      	cbz	r2, 800209a <memcpy+0x146>
 8002064:	780d      	ldrb	r5, [r1, #0]
 8002066:	189a      	adds	r2, r3, r2
 8002068:	43dc      	mvns	r4, r3
 800206a:	f803 5b01 	strb.w	r5, [r3], #1
 800206e:	1914      	adds	r4, r2, r4
 8002070:	4293      	cmp	r3, r2
 8002072:	f004 0401 	and.w	r4, r4, #1
 8002076:	d010      	beq.n	800209a <memcpy+0x146>
 8002078:	b12c      	cbz	r4, 8002086 <memcpy+0x132>
 800207a:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 800207e:	f803 4b01 	strb.w	r4, [r3], #1
 8002082:	4293      	cmp	r3, r2
 8002084:	d009      	beq.n	800209a <memcpy+0x146>
 8002086:	784d      	ldrb	r5, [r1, #1]
 8002088:	461c      	mov	r4, r3
 800208a:	f804 5b01 	strb.w	r5, [r4], #1
 800208e:	788d      	ldrb	r5, [r1, #2]
 8002090:	3102      	adds	r1, #2
 8002092:	705d      	strb	r5, [r3, #1]
 8002094:	1c63      	adds	r3, r4, #1
 8002096:	4293      	cmp	r3, r2
 8002098:	d1f5      	bne.n	8002086 <memcpy+0x132>
 800209a:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
 800209e:	4770      	bx	lr
 80020a0:	4603      	mov	r3, r0
 80020a2:	e7de      	b.n	8002062 <memcpy+0x10e>
 80020a4:	4603      	mov	r3, r0
 80020a6:	e7dd      	b.n	8002064 <memcpy+0x110>
 80020a8:	4641      	mov	r1, r8
 80020aa:	4622      	mov	r2, r4
 80020ac:	e7d9      	b.n	8002062 <memcpy+0x10e>
 80020ae:	bf00      	nop

080020b0 <memset>:
 80020b0:	b4f0      	push	{r4, r5, r6, r7}
 80020b2:	0784      	lsls	r4, r0, #30
 80020b4:	4603      	mov	r3, r0
 80020b6:	f000 808d 	beq.w	80021d4 <memset+0x124>
 80020ba:	1e54      	subs	r4, r2, #1
 80020bc:	2a00      	cmp	r2, #0
 80020be:	f000 8087 	beq.w	80021d0 <memset+0x120>
 80020c2:	07e5      	lsls	r5, r4, #31
 80020c4:	b2ce      	uxtb	r6, r1
 80020c6:	d411      	bmi.n	80020ec <memset+0x3c>
 80020c8:	461a      	mov	r2, r3
 80020ca:	f802 6b01 	strb.w	r6, [r2], #1
 80020ce:	4613      	mov	r3, r2
 80020d0:	4615      	mov	r5, r2
 80020d2:	0792      	lsls	r2, r2, #30
 80020d4:	d010      	beq.n	80020f8 <memset+0x48>
 80020d6:	1e62      	subs	r2, r4, #1
 80020d8:	2c00      	cmp	r4, #0
 80020da:	d079      	beq.n	80021d0 <memset+0x120>
 80020dc:	f803 6b01 	strb.w	r6, [r3], #1
 80020e0:	4614      	mov	r4, r2
 80020e2:	079a      	lsls	r2, r3, #30
 80020e4:	461d      	mov	r5, r3
 80020e6:	d007      	beq.n	80020f8 <memset+0x48>
 80020e8:	3c01      	subs	r4, #1
 80020ea:	e7ed      	b.n	80020c8 <memset+0x18>
 80020ec:	4603      	mov	r3, r0
 80020ee:	f803 6b01 	strb.w	r6, [r3], #1
 80020f2:	079a      	lsls	r2, r3, #30
 80020f4:	461d      	mov	r5, r3
 80020f6:	d1f7      	bne.n	80020e8 <memset+0x38>
 80020f8:	2c03      	cmp	r4, #3
 80020fa:	d952      	bls.n	80021a2 <memset+0xf2>
 80020fc:	b2ce      	uxtb	r6, r1
 80020fe:	ea46 2706 	orr.w	r7, r6, r6, lsl #8
 8002102:	2c0f      	cmp	r4, #15
 8002104:	ea47 4307 	orr.w	r3, r7, r7, lsl #16
 8002108:	d92d      	bls.n	8002166 <memset+0xb6>
 800210a:	f1a4 0210 	sub.w	r2, r4, #16
 800210e:	4617      	mov	r7, r2
 8002110:	2f0f      	cmp	r7, #15
 8002112:	f3c2 1600 	ubfx	r6, r2, #4, #1
 8002116:	602b      	str	r3, [r5, #0]
 8002118:	606b      	str	r3, [r5, #4]
 800211a:	60ab      	str	r3, [r5, #8]
 800211c:	60eb      	str	r3, [r5, #12]
 800211e:	f105 0210 	add.w	r2, r5, #16
 8002122:	d916      	bls.n	8002152 <memset+0xa2>
 8002124:	b13e      	cbz	r6, 8002136 <memset+0x86>
 8002126:	3f10      	subs	r7, #16
 8002128:	6013      	str	r3, [r2, #0]
 800212a:	6053      	str	r3, [r2, #4]
 800212c:	6093      	str	r3, [r2, #8]
 800212e:	60d3      	str	r3, [r2, #12]
 8002130:	3210      	adds	r2, #16
 8002132:	2f0f      	cmp	r7, #15
 8002134:	d90d      	bls.n	8002152 <memset+0xa2>
 8002136:	3f20      	subs	r7, #32
 8002138:	f102 0610 	add.w	r6, r2, #16
 800213c:	6013      	str	r3, [r2, #0]
 800213e:	6053      	str	r3, [r2, #4]
 8002140:	6093      	str	r3, [r2, #8]
 8002142:	60d3      	str	r3, [r2, #12]
 8002144:	6113      	str	r3, [r2, #16]
 8002146:	6153      	str	r3, [r2, #20]
 8002148:	6193      	str	r3, [r2, #24]
 800214a:	61d3      	str	r3, [r2, #28]
 800214c:	3220      	adds	r2, #32
 800214e:	2f0f      	cmp	r7, #15
 8002150:	d8f1      	bhi.n	8002136 <memset+0x86>
 8002152:	f1a4 0210 	sub.w	r2, r4, #16
 8002156:	f022 020f 	bic.w	r2, r2, #15
 800215a:	f004 040f 	and.w	r4, r4, #15
 800215e:	3210      	adds	r2, #16
 8002160:	2c03      	cmp	r4, #3
 8002162:	4415      	add	r5, r2
 8002164:	d91d      	bls.n	80021a2 <memset+0xf2>
 8002166:	1f27      	subs	r7, r4, #4
 8002168:	463e      	mov	r6, r7
 800216a:	462a      	mov	r2, r5
 800216c:	2e03      	cmp	r6, #3
 800216e:	f842 3b04 	str.w	r3, [r2], #4
 8002172:	f3c7 0780 	ubfx	r7, r7, #2, #1
 8002176:	d90d      	bls.n	8002194 <memset+0xe4>
 8002178:	b127      	cbz	r7, 8002184 <memset+0xd4>
 800217a:	3e04      	subs	r6, #4
 800217c:	2e03      	cmp	r6, #3
 800217e:	f842 3b04 	str.w	r3, [r2], #4
 8002182:	d907      	bls.n	8002194 <memset+0xe4>
 8002184:	4617      	mov	r7, r2
 8002186:	f847 3b04 	str.w	r3, [r7], #4
 800218a:	3e08      	subs	r6, #8
 800218c:	6053      	str	r3, [r2, #4]
 800218e:	1d3a      	adds	r2, r7, #4
 8002190:	2e03      	cmp	r6, #3
 8002192:	d8f7      	bhi.n	8002184 <memset+0xd4>
 8002194:	1f23      	subs	r3, r4, #4
 8002196:	f023 0203 	bic.w	r2, r3, #3
 800219a:	1d13      	adds	r3, r2, #4
 800219c:	f004 0403 	and.w	r4, r4, #3
 80021a0:	18ed      	adds	r5, r5, r3
 80021a2:	b1ac      	cbz	r4, 80021d0 <memset+0x120>
 80021a4:	b2c9      	uxtb	r1, r1
 80021a6:	43ea      	mvns	r2, r5
 80021a8:	192c      	adds	r4, r5, r4
 80021aa:	f805 1b01 	strb.w	r1, [r5], #1
 80021ae:	18a3      	adds	r3, r4, r2
 80021b0:	42a5      	cmp	r5, r4
 80021b2:	f003 0201 	and.w	r2, r3, #1
 80021b6:	d00b      	beq.n	80021d0 <memset+0x120>
 80021b8:	b11a      	cbz	r2, 80021c2 <memset+0x112>
 80021ba:	f805 1b01 	strb.w	r1, [r5], #1
 80021be:	42a5      	cmp	r5, r4
 80021c0:	d006      	beq.n	80021d0 <memset+0x120>
 80021c2:	462b      	mov	r3, r5
 80021c4:	f803 1b01 	strb.w	r1, [r3], #1
 80021c8:	7069      	strb	r1, [r5, #1]
 80021ca:	1c5d      	adds	r5, r3, #1
 80021cc:	42a5      	cmp	r5, r4
 80021ce:	d1f8      	bne.n	80021c2 <memset+0x112>
 80021d0:	bcf0      	pop	{r4, r5, r6, r7}
 80021d2:	4770      	bx	lr
 80021d4:	4605      	mov	r5, r0
 80021d6:	4614      	mov	r4, r2
 80021d8:	e78e      	b.n	80020f8 <memset+0x48>
 80021da:	bf00      	nop

080021dc <LED_CLK>:
 80021dc:	0004 0000 0004 0000                         ........

080021e4 <LED_PIN>:
 80021e4:	0100 0200                                   ....

080021e8 <BUTTON_PORT_SOURCE>:
 80021e8:	0000 0000                                   ....

080021ec <BUTTON_PIN_SOURCE>:
 80021ec:	000a 0000                                   ....

080021f0 <BUTTON_EXTI_LINE>:
 80021f0:	0400 0000                                   ....

080021f4 <BUTTON_CLK>:
 80021f4:	0004 0000 0000 0000                         ........

080021fc <BUTTON_PIN>:
 80021fc:	0400 0000                                   ....

08002200 <BUTTON_IRQn>:
 8002200:	0028 0000                                   (...

08002204 <cRMdefaultParams>:
 8002204:	0003 0101 1414 2700 2727 2727 2727 2727     .......'''''''''
 8002214:	2727 2727 2327 2525 2525 2525 2525 2325     '''''#%%%%%%%%%#
 8002224:	2323 0023 0000 0000 0000 0000 0000 0000     ###.............
	...
 800223c:	5050 5050 5050 5050 5050 5050 5050 5050     PPPPPPPPPPPPPPPP
 800224c:	5050 5050 5050 5050 5050 5050 5050 5050     PPPPPPPPPPPPPPPP
 800225c:	5050 0150 8077 1f1d 2622 2928 1f1a 2422     PPP.w..."&().."$
 800226c:	2826 1d16 201e 2524 2d1e 0201 0202 0002     &(... $%.-......
 800227c:	1515 1115 1515 000e                         ........

08002284 <wlan_drv_patch>:
 8002284:	0100 0000 1eb0 0000 045c 0018 62e4 0008     ........\....b..
 8002294:	0096 0000 0000 0000 0000 0000 0000 0000     ................
	...
 800232c:	0000 ffff 637a 0008 0096 0000 0000 0000     ....zc..........
	...
 80023cc:	0000 ffff 6410 0008 0096 0000 0000 0000     .....d..........
	...
 80023ec:	2007 4902 6008 4802 3019 46f7 3b40 0008     . .I.`.H.0.F@;..
 80023fc:	d049 0001 0000 0000 0000 0000 0000 0000     I...............
	...
 800246c:	0000 ffff 64a6 0008 0096 0000 0000 0000     .....d..........
	...
 800250c:	0000 ffff 653c 0008 0096 0000 0000 0000     ....<e..........
 800251c:	b5f0 b085 1c05 88a8 9000 8928 9001 68e9     ..........(....h
 800252c:	9102 7c28 9003 6a2a 2000 5617 6068 2900     ..(|..*j. .Vh`.)
 800253c:	d04c 2f00 dc4a 49ca 1c0c 2608 9004 8821     L../J..I...&..!.
 800254c:	9800 4281 d10c 8862 9801 4282 d108 2046     ...B..b....B..F 
 800255c:	5d02 9803 4282 d103 200e 5700 42b8 d00a     .]...B... .W.B..
 800256c:	2046 5d00 2811 d122 9800 4281 d11f 200e     F .].("....B... 
 800257c:	5700 42b8 d11b 2004 1c02 9802 49b9 2301     .W.B... .....I.#
 800258c:	469e 4be9 44fe 4718 2800 d017 1d20 9902     .F.K.D.G.(.. ...
 800259c:	2204 2301 469e 4be4 44fe 4718 2800 d00d     .".#.F.K.D.G.(..
 80025ac:	2046 ffff 65d2 0008 0096 0000 5d00 2811     F ...e.......].(
 80025bc:	d009 6da0 2800 d006 34ac 9804 3001 9004     ...m.(...4...0..
 80025cc:	3e01 d1c1 e007 9804 0600 0e00 21ac 4341     .>...........!AC
 80025dc:	48a6 1840 6068 48a6 30ad b005 bdf0 b500     .H@.h`.H.0......
 80025ec:	68c2 6990 2102 2301 469e 4ba2 44fe 4718     .h.i.!.#.F.K.D.G
 80025fc:	48a2 3061 bd00 7901 290b d003 0089 4a9f     .Ha0...y.).....J
 800260c:	5a51 e001 2101 0249 6041 489d 300d 46f7     QZ...!I.A`.H.0.F
 800261c:	1c01 489c 6802 489c 2a01 d101 3025 46f7     ...H.h.H.*..%0.F
 800262c:	4a9b 6812 604a 3019 46f7 2100 6041 4899     .J.hJ`.0.F.!A`.H
 800263c:	4998 1808 46f7 2100 6041 4897 49e4 1808     .I...F.!A`.H.I..
 800264c:	46f7 ffff 6668 0008 0096 0000 b5ff 6946     .F..hf........Fi
 800265c:	6840 9001 4994 7c0a 4f9a 2a01 d063 7c09     @h...I.|.O.*c..|
 800266c:	2903 d060 4a91 4b92 2100 9102 5659 2324     .)`..J.K.!..YV$#
 800267c:	4359 1853 9303 2801 d117 188a 2304 466c     YCS....(.....#lF
 800268c:	498c 7915 7808 43c0 4328 7020 3201 3101     .I.y.x.C(C p.2.1
 800269c:	3401 3b01 d1f5 1d31 4668 2204 2301 469e     .4.;..1.hF.".#.F
 80026ac:	4ba6 44fe 4718 2800 d040 1d35 4882 7800     .K.D.G.(@.5..H.x
 80026bc:	28ff d011 2800 d00f 9803 1d01 1c28 2401     .(...(......(..$
 80026cc:	46a6 4a7e 44fe 4710 2800 d105 487a 46a6     .F~J.D.G.(..zH.F
 80026dc:	497b 44fe 4708 e005 1c28 2101 468e 4978     {I.D.G..(..!.FxI
 80026ec:	44fe ffff 66fe 0008 0096 0000 4708 9901     .D...f.......G..
 80026fc:	2901 d101 2800 d11e 9901 315f d001 2800     .)...(...._1...(
 800270c:	d10f 20a8 5d81 2900 d008 1e49 5581 5d80     ... .].)..I..U.]
 800271c:	2800 d109 1c38 30ff 3008 e011 2103 9102     .(..8..0.0...!..
 800272c:	e000 20a8 9902 5581 1c38 30ff 3016 e007     ... ...U8..0.0..
 800273c:	9801 2801 d102 1c38 30a3 e001 1c38 309f     ...(..8..0..8..0
 800274c:	9000 bdff b500 1c02 6a10 69d1 6952 69c3     .........j.iRi.i
 800275c:	605a 2201 4696 4a5e 44fe 4710 485e 30ff     Z`.".F^J.D.G^H.0
 800276c:	306e bd00 b510 1c0a 6941 6a00 6993 69db     n0......Ai.j.i.i
 800277c:	6058 6990 2401 46a6 4a56 44fe 4710 46a6     X`.i.$.FVJ.D.G.F
 800278c:	4856 ffff 6794 0008 0096 0000 44fe 4700     VH...g.......D.G
 800279c:	4855 30ff 30b6 bd10 b570 1c05 696e 4853     UH.0.0..p...niSH
 80027ac:	6802 215c 5d88 2804 d115 2007 5588 0b10     .h\!.].(... .U..
 80027bc:	d211 2401 46a6 484e 44fe 4700 2800 d00a     ...$.FNH.D.G.(..
 80027cc:	2147 5789 60c1 2111 02c9 2200 2304 46a6     G!.W.`.!...".#.F
 80027dc:	4c48 44fe 4720 2001 6068 4843 4946 1808     HL.D G. h`CHFI..
 80027ec:	bd70 b570 1c05 69ae 209c 1980 214b 0089     p.p....i. ..K!..
 80027fc:	2401 46a6 4ae9 44fe 4710 215c 5d88 2807     .$.F.J.D.G\!.].(
 800280c:	d101 2009 e000 2005 69aa 5488 1c30 46a6     ... ... .i.T0..F
 800281c:	49ea 44fe 4708 6068 48e9 304d bd70 b5f0     .I.D.Gh`.HM0p...
 800282c:	6841 ffff 682a 0008 0096 0000 6882 2388     Ah..*h.......h.#
 800283c:	185e 8837 6f0b 2b00 d101 2f00 d110 2f06     ^.7..o.+.../.../
 800284c:	dd02 2100 43c9 e007 8833 009b 18c9 670a     ...!.C..3......g
 800285c:	8831 3101 8031 2101 6081 48e9 301d bdf0     1..11..!.`.H.0..
 800286c:	1c0b 2401 6f5d 671d 3304 3401 2c06 dae1     ...$]o.g.3.4.,..
 800287c:	e7f8 b500 2100 60c1 48e4 6801 3110 48e1     .....!.`.H.h.1.H
 800288c:	2220 2301 469e 4bef 44fe 4718 48e0 30fb      ".#.F.K.D.G.H.0
 800289c:	bd00 0d14 001b 1954 001b 1a91 0001 ad4b     ......T.......K.
 80028ac:	0003 4e61 0001 3206 0008 0b1f 0002 3f54     ..aN...2......T?
 80028bc:	0008 c145 0000 3c84 0008 021b 0000 17ed     ..E....<........
 80028cc:	0000 ffff 68c0 0008 0096 0000 c1f3 0001     .....h..........
 80028dc:	1934 001b 1908 001b 44a6 0008 171c 001b     4........D......
 80028ec:	1718 001b 67cb 0003 470d 0002 4239 0003     .....g...G..9B..
 80028fc:	e7bd 0002 40b1 0003 eab9 0001 da45 0000     .....@......E...
 800290c:	4124 0008 c071 0002 c07b 0002 039f 0000     $A..q...{.......
 800291c:	b5f0 b087 9105 9006 6986 1cf0 a1df 2204     .........i....."
 800292c:	2401 46a6 4b0f 44fe 4718 2800 d140 79f3     .$.F.K.D.G.(@..y
 800293c:	48dd 1c1a 7003 7a30 9000 7a70 9001 2003     .H...p0z..pz... 
 800294c:	492f 31f0 46a6 4ddd 44fe 4728 79f2 7a35     /I.1.F.M.D(G.y5z
 800295c:	7a77 1b78 1c43 4293 d01e 2a16 db0f 2d00     wzx.C..B...*...-
 800296c:	d10d ffff 6956 0008 0096 0000 e001 c68f     ....Vi..........
 800297c:	0003 48d5 7004 200a 1981 48ce 1c1a 46a6     ...H.p. ...H...F
 800298c:	4bb6 44fe 4718 e082 48d1 7004 48ca 1940     .K.D.G...H.p.H@.
 800299c:	210a 1989 1b7a 1c52 46a6 4baf 44fe 4718     .!..z.R..F.K.D.G
 80029ac:	e075 48c9 7004 48c9 7004 200a 1981 48c1     u..H.p.H.p. ...H
 80029bc:	46a6 4ba9 44fe 4718 e069 1cf0 2703 1c3a     .F.K.D.Gi....':.
 80029cc:	a1bb 46a6 4bc6 44fe 4718 2800 d15f e7ff     ...F.K.D.G.(_...
 80029dc:	79f1 48b9 7001 4db9 79b2 702a 1c38 490a     .y.H.p.M.y*p8..I
 80029ec:	31f4 46a6 4bb7 44fe 4718 7828 2800 d10e     .1.F.K.D.G(x.(..
 80029fc:	48b8 7004 48b8 7004 1c38 4903 31f5 46a6     .H.p.H.p8..I.1.F
 8002a0c:	4ab6 ffff 69ec 0008 0096 0000 44fe 4710     .J...i.......D.G
 8002a1c:	e002 46c0 04c7 0000 7a30 9000 7a70 9001     ...F....0z..pz..
 8002a2c:	48a8 7802 79f3 1c38 49e4 31f6 46a6 4da8     .H.x.y8..I.1.F.M
 8002a3c:	44fe 4728 1c23 79f2 7a37 7a70 1bc1 1c4d     .D(G#..y7zpz..M.
 8002a4c:	4295 d01e 499f 7809 2916 db0c 2f00 d10a     .B...I.x.).../..
 8002a5c:	48a2 7003 200a 1981 48ee 1c2a 46a6 4b81     .H.p. ...H*..F.K
 8002a6c:	44fe 4718 e018 499e 700b 49ea 19cb 210a     .D.G...I.p.I...!
 8002a7c:	1989 1bc0 1c42 1c18 46a6 4b7a 44fe 4718     ....B....FzK.D.G
 8002a8c:	e00a 4896 7003 4896 7003 200a 1981 48e1     ...H.p.H.p. ...H
 8002a9c:	46a6 4b74 44fe 4718 488e 7800 2800 d00a     .FtK.D.G.H.x.(..
 8002aac:	488d ffff 6a82 0008 0096 0000 7800 2800     .H...j.......x.(
 8002abc:	d006 488c 7800 2800 d002 488b 7800 2800     ...H.x.(...H.x.(
 8002acc:	d07f 2003 2117 0189 46a6 4a88 44fe 4710     ... .!...F.J.D.G
 8002adc:	487f 7801 487f 7807 4d7c 4e7a 48da 6800     .H.x.H.x|MzN.H.h
 8002aec:	2800 d12e 9806 6141 6205 48cc 9a05 6410     .(....Aa.b.H...d
 8002afc:	2f02 d001 2f03 d101 2203 e000 1c3a 9b05     ./.../..."..:...
 8002b0c:	63da 7832 639a 2f01 d103 2905 d004 290d     .c2x.c./...)...)
 8002b1c:	d002 48e5 30db e057 2600 9600 9101 9502     ...H.0W..&......
 8002b2c:	9603 9004 1c33 1c20 1c01 468e 4de0 44fe     ....3. ....F.M.D
 8002b3c:	4728 48df 6004 1c30 46a6 49de 44fe 4708     (G.H.`0..F.I.D.G
 8002b4c:	e03f ffff 6b18 0008 0096 0000 200d 2150     ?....k....... P!
 8002b5c:	46a6 4adc 44fe 4710 1c23 200d 1c31 2200     .F.J.D.G#.. 1.."
 8002b6c:	469e 4fd9 44fe 4738 7833 200d 1c29 1c22     .F.O.D8G3x. ).".
 8002b7c:	4696 4dd5 44fe 4728 7830 3001 1c02 200d     .F.M.D(G0x.0... 
 8002b8c:	4955 1c23 469e 4dd0 44fe 4728 4d53 7830     UI#..F.M.D(GSM0x
 8002b9c:	3002 1c02 200d 1c29 1c23 469e 4fca 44fe     .0... ).#..F.O.D
 8002bac:	4738 7828 2800 d00a 7830 3003 1c02 484a     8G(x.(..0x.0..JH
 8002bbc:	7803 200d 499c 46a6 4dc3 44fe 4728 48bf     .x. .I.F.M.D(G.H
 8002bcc:	6004 2000 46a6 49be 44fe 4708 48b9 49ee     .`. .F.I.D.G.H.I
 8002bdc:	1808 b007 bdf0 46c0 b87d 0003 1c01 48eb     .......F}......H
 8002bec:	6802 ffff 6bae 0008 0096 0000 48eb 2a00     .h...k.......H.*
 8002bfc:	d004 2200 620a 618a 301d 46f7 30d7 46f7     ...".b.a.0.F.0.F
 8002c0c:	46c0 21c9 0001 e191 0000 1c01 48e4 6802     .F.!.........H.h
 8002c1c:	48e4 2a00 d002 30ff 30b4 46f7 2200 61ca     .H.*...0.0.F.".a
 8002c2c:	618a 304f 46f7 48df 6801 698a 2001 03c0     .aO0.F.H.h.i. ..
 8002c3c:	4310 6188 2000 6108 48dc 3023 46f7 1789     .C.a. .a.H#0.F..
 8002c4c:	0002 1746 001b 3f30 0008 eb41 0000 b570     ..F...0?..A...p.
 8002c5c:	1c05 4ed6 6a29 69ea 1c30 2401 46a6 4b08     ...N)j.i0..$.F.K
 8002c6c:	44fe 4718 6968 46a6 49d2 44fe 4708 69a8     .D.Ghi.F.I.D.G.i
 8002c7c:	3006 60a8 48d0 6800 6068 60ee 48cf 306d     .0.`.H.hh`.`.Hm0
 8002c8c:	bd70 ffff 6c44 0008 0096 0000 b409 0003     p...Dl..........
 8002c9c:	b530 48cd 6d01 6c80 4308 d018 49cb 1c08     0..H.m.l.C...I..
 8002cac:	2207 23ff 3309 581b 2b00 d004 30ff 301d     .".#.3.X.+...0.0
 8002cbc:	3a01 d1f6 e00b 2002 4ac5 4bc6 2401 46a6     .:..... .J.K.$.F
 8002ccc:	4dc5 44fe 4728 46a6 48c4 44fe 4700 48c4     .M.D(G.F.H.D.G.H
 8002cdc:	30ff 305c bd30 46c0 5353 4449 c000 c046     .0\00..FSSID..F.
 8002cec:	454b 0059 62ee 0008 62f0 0008 62ec 0008     KEY..b...b...b..
 8002cfc:	62ed 0008 7ee7 0003 7f13 0003 62e8 0008     .b...~.......b..
 8002d0c:	62e9 0008 62ea 0008 62eb 0008 7edd 0003     .b...b...b...~..
 8002d1c:	c68f 0003 b5f0 b087 9100 9001 486c 6801     ............lH.h
 8002d2c:	4aaa ffff 6cda 0008 0096 0000 1c14 9402     .J...l..........
 8002d3c:	2607 2500 9503 9404 9505 48af 6800 4308     .&.%.......H.h.C
 8002d4c:	d027 68e0 9903 4288 dd0a 9003 1c40 9900     '..h...B....@...
 8002d5c:	6088 49a0 20ff 301d 4368 180c 68e0 9104     .`.I. .0hC...h..
 8002d6c:	9902 68c9 4288 db10 4288 d110 9802 2701     ...h.B...B.....'
 8002d7c:	46be 499e 44fe 4708 9006 1c20 46be 499b     .F.I.D.G.. ..F.I
 8002d8c:	44fe 4708 9906 4288 da01 9505 9402 4852     .D.G...B......RH
 8002d9c:	6801 27ff 3709 5938 2800 d006 4897 6800     .h.'.78Y.(...H.h
 8002dac:	2e07 d100 1c2e 4308 d004 34ff 341d 3501     .......C...4.4.5
 8002dbc:	2d07 dbc2 2e07 d10a 4890 6800 4308 d006     .-.......H.h.C..
 8002dcc:	9e05 ffff 6d70 0008 0096 0000 1c30 2101     ....pm......0..!
 8002ddc:	468e 498a 44fe 4708 9801 6147 2100 6181     .F.I.D.G..Ga.!.a
 8002dec:	22ff 321d 4372 9904 1889 61c1 6206 4884     .".2rC.....a.b.H
 8002dfc:	3039 b007 bdf0 46c0 04c7 0000 b510 1c04     90.....F........
 8002e0c:	2000 2101 468e 4980 44fe 4708 1e40 d500     . .!.F.I.D.G@...
 8002e1c:	2000 6060 61e0 487d 3021 bd10 b570 1c04     . ``.a}H!0..p...
 8002e2c:	69e5 6966 2000 2101 468e 4977 44fe 4708     .ifi. .!.FwI.D.G
 8002e3c:	6060 19ab 4a76 4975 4293 d302 1a9a 4282     ``..vJuI.B.....B
 8002e4c:	d902 1c08 3099 bd70 1c08 30ab bd70 46c0     .....0p....0p..F
 8002e5c:	6310 0008 6b08 7d41 8802 0092 1a51 393c     .c...kA}....Q.<9
 8002e6c:	22ff ffff 6e06 0008 0096 0000 325f 4291     ."...n......_2.B
 8002e7c:	d903 2165 8001 2102 7381 4869 4968 1808     ..e!...!.siHhI..
 8002e8c:	46f7 6330 0008 b5f8 6840 2124 4341 4866     .F0c....@h$!ACfH
 8002e9c:	1845 1d28 210c 1949 2204 2301 469e 4b63     E.(..!I..".#.FcK
 8002eac:	44fe 4718 4c60 2800 d01b 1c2b 2204 466e     .D.G`L.(..+.."nF
 8002ebc:	4960 7b1f 7808 43c0 4338 7030 3301 3101     `I.{.x.C8C0p.3.1
 8002ecc:	3601 3a01 d1f5 200c 1941 4668 2204 2301     .6.:... A.hF.".#
 8002edc:	469e 4b56 44fe 4718 2800 d002 1c20 304a     .FVK.D.G.(.. .J0
 8002eec:	bdf8 1c20 bdf8 bdb1 0000 9515 0000 3f58     .. ...........X?
 8002efc:	0008 f8f3 0000 09e9 0002 092b 0002 b5f8     ..........+.....
 8002f0c:	1c05 ffff 6e9c 0008 0096 0000 69aa 494d     .....n.......iMI
 8002f1c:	2000 5608 2124 4341 4846 1843 2404 466e     . .V$!ACFHC..$nF
 8002f2c:	4946 791f 7808 43c0 4338 7030 3301 3101     FI.y.x.C8C0p.3.1
 8002f3c:	3601 3c01 d1f5 1d11 4668 2204 2401 46a6     .6.<....hF.".$.F
 8002f4c:	4b3d 44fe 4718 1c01 483d d004 493e 7809     =K.D.G..=H..>I.x
 8002f5c:	6069 3043 bdf8 61ec 30af bdf8 b570 68c5     i`C0...a.0..p..h
 8002f6c:	6881 890a 4e3d 2a00 d022 2401 6dc2 18a2     .h..=N.*"..$.m..
 8002f7c:	65c2 8908 280d d11b 6b68 1c21 46a6 4a33     .e...(..hk!..F3J
 8002f8c:	44fe 4710 1c22 1c28 2100 46a6 4b30 44fe     .D.G".(..!.F0K.D
 8002f9c:	4718 602c 6be9 1c28 46a6 4a2e 44fe 4710     .G,`.k(..F.J.D.G
 8002fac:	1c28 ffff 6f32 0008 0096 0000 46a6 492c     (...2o.......F,I
 8002fbc:	44fe 4708 1c30 303d bd70 1c30 3023 bd70     .D.G0.=0p.0.#0p.
 8002fcc:	1e40 0080 4b2a 5019 4928 500a 46f7 02b1     @...*K.P(I.P.F..
 8002fdc:	0000 3f74 0008 c619 0000 3f5c 0008 c21d     ..t?......\?....
 8002fec:	0000 4468 0008 1243 0003 6334 0008 7a2f     ..hD..C...4c../z
 8002ffc:	0002 36b4 0008 f48f 0001 0000 001b 0434     ...6..........4.
 800300c:	001b 0432 0000 07c4 0000 0915 0002 93c5     ..2.............
 800301c:	0000 910d 0000 b5bd 0000 9295 0000 93fd     ................
 800302c:	0000 3f54 0008 4f29 0003 e8df 0002 8936     ..T?..)O......6.
 800303c:	0041 0681 0000 78b1 0000 ec94 0001 1908     A......x........
 800304c:	001b ffff 6fc8 0008 0096 0000 c68f 0003     .....o..........
 800305c:	171c 001b 6667 0003 44a6 0008 1718 001b     ....gf...D......
 800306c:	2fa7 0002 4491 0003 6391 0003 445b 0003     ./...D...c..[D..
 800307c:	44e7 0003 f304 001a 7b80 0008 b5fc 1c04     .D.......{......
 800308c:	69a5 6a60 9001 6920 2800 d435 2808 da33     .i`j.. i.(5..(3.
 800309c:	69e1 6809 2910 d12f 21ac 4341 4aac 5c51     .i.h.)/..!AC.JQ\
 80030ac:	0849 d327 0600 1600 68a2 4669 2301 469e     I.'......hiF.#.F
 80030bc:	4ba8 44fe 4718 1c06 3039 d01f 2e00 d01d     .K.D.G..90......
 80030cc:	9800 6807 9900 390c 9801 6001 1d28 2110     ...h...9...`(..!
 80030dc:	1a79 2204 2301 469e 4b9f 44fe 4718 2202     y..".#.F.K.D.G."
 80030ec:	802a ffff 705e 0008 0096 0000 1ca8 2108     *...^p.........!
 80030fc:	1a79 2301 469e 4b9a 44fe 4718 e003 2038     y..#.F.K.D.G..8 
 800310c:	e000 2000 43c6 6026 4897 307c 6220 bdfc     ... .C&`.H|0 b..
 800311c:	b570 1c05 6968 7806 69a8 2890 d121 2e04     p...hi.x.i.(!...
 800312c:	d01f 2e05 d01d 2e0a d01b 2e06 d019 2e0c     ................
 800313c:	da17 6928 2401 46a6 498c 44fe 4708 488b     ..(i.$.F.I.D.G.H
 800314c:	498c 2200 46a6 4b8b 44fe 4718 1c32 2003     .I.".F.K.D.G2.. 
 800315c:	49df 46a6 4bdf 44fe 4718 4887 30ff 305f     .I.F.K.D.G.H.0_0
 800316c:	6228 bd70 b5f0 b089 9005 6941 6902 4880     (bp.......Ai.i.H
 800317c:	4e86 4282 d051 3004 4282 d03c 4880 4282     .N.BQ..0.B<..H.B
 800318c:	d000 ffff 70f4 0008 0096 0000 e0e3 680d     .....p.........h
 800319c:	200c 1a08 9006 6848 1808 1d06 6888 9000     . ....Hh.....h..
 80031ac:	8873 2003 21b7 00c9 1c2a 2401 46a6 4f77     s.. .!..*..$.FwO
 80031bc:	44fe 4738 1c28 1c31 2210 46a6 4b74 44fe     .D8G(.1..".FtK.D
 80031cc:	4718 1c06 d112 21ac 4369 48f3 1840 2146     .G.....!iC.H@.F!
 80031dc:	5c09 2911 d101 2144 540c 2144 5c0a 2003     .\.)..D!.TD!.\. 
 80031ec:	49bd 310b 46a6 4bbd 44fe 4718 4866 1c31     .I.1.F.K.D.GfH1.
 80031fc:	9a06 46a6 4b62 44fe 4718 4868 30ec e0ab     ...FbK.D.GhH.0..
 800320c:	6808 00c0 1830 688a 2a02 d002 20e7 0080     .h..0..h.*... ..
 800321c:	e0a2 68ca 1889 7b09 6041 2180 6001 203b     ...h...{A`.!.`; 
 800322c:	0100 ffff 718a 0008 0096 0000 e099 6808     .....q.........h
 800323c:	9006 00c0 5834 2010 9004 2501 46ae 4858     ....4X. ...%.FXH
 800324c:	44fe 4700 9007 2800 d100 e089 210c 9807     .D.G...(.....!..
 800325c:	180f 49d3 20ac 9a06 4350 1808 2248 5c13     ...I. ..PC..H".\
 800326c:	065b 0e5b 5413 9a06 00d2 18b6 6871 2900     [.[..T......qh.)
 800327c:	d147 2c00 dd01 2c08 db21 2200 4669 700a     G..,...,!.."iF.p
 800328c:	9201 810a 728a 72cd 730d 734d 8801 48e4     .....r.r.sMs...H
 800329c:	2306 46ae 4ce4 44fe 4720 1c04 dc02 2000     .#.F.L.D G..... 
 80032ac:	43c0 e036 6034 20ac 4360 49bd 1809 225c     .C6.4`. `C.I..\"
 80032bc:	1c28 5450 2048 5c42 0652 0e52 5442 20ac     (.PTH B\R.R.BT. 
 80032cc:	4360 ffff 7220 0008 0096 0000 49b7 1808     `C.. r.......I..
 80032dc:	215c 5c09 1e49 2902 d916 3903 d008 2000     \!.\I..)...9... 
 80032ec:	5630 46ae 49d3 44fe 4708 2080 6030 e7db     0V.F.I.D.G. 0`..
 80032fc:	9408 2180 6031 2248 5c13 4319 5411 46ae     ...!1`H".\.C.T.F
 800330c:	49cd 44fe 4708 e00a 2001 e7ce 9806 1c39     .I.D.G... ....9.
 800331c:	aa04 46ae 4bc9 44fe 4718 1c04 9008 9806     ...F.K.D.G......
 800332c:	6038 9808 6078 2800 d015 20ac 4360 499f     8`..x`.(... `C.I
 800333c:	1809 8848 0402 2002 4310 60b8 6848 0e02     ..H.... .C.`Hh..
 800334c:	0201 0e09 0209 4311 0402 0e12 0412 430a     .......C.......C
 800335c:	0600 4310 60f8 9807 490d 2200 2310 46ae     ...C.`...I.".#.F
 800336c:	4cb7 ffff 72b6 0008 0096 0000 44fe 4720     .L...r.......D G
 800337c:	4812 e000 2016 49b5 1809 9805 6201 b009     .H... .I.....b..
 800338c:	bdf0 0d5d 001b e781 0002 b409 0003 1a27     ..]...........'.
 800339c:	0002 7a2f 0002 0202 0000 1005 0000 f6cf     ../z............
 80033ac:	0000 f4d5 0000 1002 0000 7f01 0003 1991     ................
 80033bc:	0002 6520 0008 c071 0002 032a 0000 b5f0     .. e..q...*.....
 80033cc:	b08b 9007 6905 6947 200c 1a38 9008 49f1     .....iGi. 8....I
 80033dc:	428d d116 6878 300f 1100 0100 6078 6838     .B..xh.0....x`8h
 80033ec:	280b d80e 2300 4668 7003 9808 2205 2401     .(...#hF.p...".$
 80033fc:	46a6 4ce9 44fe 4720 48e9 30ff 3095 9907     .F.L.D G.H.0.0..
 800340c:	6208 ffff 734c 0008 0096 0000 48e7 4285     .b..Ls.......H.B
 800341c:	d123 48f7 7802 466c 7222 7843 7263 7881     #..H.xlF"rCxcr.x
 800342c:	72a1 78c0 72e0 9100 9001 2003 4934 3101     .r.x.r..... 4I.1
 800343c:	2601 46b6 4eef 44fe 4730 2004 7020 9808     .&.F.N.D0G.  p..
 800344c:	49da 2200 ab02 2401 46a6 4cd6 44fe 4720     .I."...$.F.L.D G
 800345c:	48d5 30ff 3095 9907 6208 48e7 4285 d000     .H.0.0...b.H.B..
 800346c:	e0ec 2403 1c20 4926 3102 2201 4696 4ae3     ...$ .&I.1.".F.J
 800347c:	44fe 4710 48cc 30ff 3095 9009 6838 4ee1     .D.G.H.0.0..8h.N
 800348c:	2800 d100 e0c8 2001 4686 48dd 44fe 4700     .(..... .F.H.D.G
 800349c:	2800 d100 e0bc 6832 1c20 4919 3103 2301     .(....2h ..I.1.#
 80034ac:	469e ffff 73e2 0008 0096 0000 4b18 44fe     .F...s.......K.D
 80034bc:	4718 6830 2800 d140 4cd6 202e 1901 68b8     .G0h.(@..L. ...h
 80034cc:	3003 7008 7a38 7048 4dd3 1c21 940a 3130     .0.p8zHp.M!...01
 80034dc:	910a 68b8 1820 3030 682a 3a30 2301 469e     ...h .00*h0:.#.F
 80034ec:	4bce 44fe 4718 6878 1838 1d01 68ba 980a     .K.D.Gxh8....h..
 80034fc:	2301 469e 4bce 44fe 4718 68b8 6829 1808     .#.F.K.D.G.h)h..
 800350c:	1820 49c6 790a e004 46c0 05aa 0000 7ee7      ..I.y...F.....~
 800351c:	0003 7002 794a 7042 798a 7082 79c9 70c1     ...pJyBp.y.p.y.p
 800352c:	3004 210f 1a41 780a 68bb 189a 700a 1b00     .0.!A..x.h...p..
 800353c:	0400 0c00 6028 2001 6030 2002 1c01 2211     ....(`. 0`. ..."
 800354c:	2401 ffff 7478 0008 0096 0000 46a6 4bb7     .$..xt.......F.K
 800355c:	44fe 4718 1c06 d463 2003 46a6 49b4 44fe     .D.G..c.. .F.I.D
 800356c:	4708 1c07 2100 42b9 d051 222b 46a6 4bb1     .G...!.BQ.+".F.K
 800357c:	44fe 4718 200c 19c0 21ac 4371 4a15 1855     .D.G. ...!qC.JU.
 800358c:	6368 2100 2218 46a6 4baa 44fe 4718 48a4     hc.!.".F.K.D.G.H
 800359c:	6802 6b68 6042 1c39 31ac 6001 6800 499f     .hhkB`9..1.`.h.I
 80035ac:	46a6 4ba5 44fe 4718 2100 a803 2210 46a6     .F.K.D.G.!...".F
 80035bc:	4ba0 44fe 4718 21e0 4668 7401 2100 7441     .K.D.G.!hF.t.!At
 80035cc:	7481 21fb 74c1 49f1 81c1 2102 8181 6b69     .t.!.t.I...!..ik
 80035dc:	68ca e001 0d14 001b 2001 03c0 4310 60c8     .h....... ...C.`
 80035ec:	6848 ffff 750e 0008 0096 0000 9000 2200     Hh...u........."
 80035fc:	1c30 1c39 ab03 46a6 4de8 44fe 4728 1c05     0.9....F.M.D(G..
 800360c:	0630 1600 46a6 49f1 44fe 4708 1c38 46a6     0....F.I.D.G8..F
 800361c:	49f0 44fe 4708 e011 0630 1600 46a6 49eb     .I.D.G..0....F.I
 800362c:	44fe 4708 2001 43c5 e008 1c05 e006 2000     .D.G. .C....... 
 800363c:	2100 43cd e001 2000 1c05 6030 2300 4668     .!.C... ..0`.#hF
 800364c:	7003 062a 0e12 9808 4973 2401 46a6 4c5c     .p*.....sI.$.F\L
 800365c:	44fe 4720 9807 9909 6201 b00b bdf0 1950     .D G.....b....P.
 800366c:	001b 1629 0001 18c1 0001 1bf1 0001 1cf3     ..).............
 800367c:	0002 c07b 0002 f091 0000 b5fe 1c07 697d     ..{...........}i
 800368c:	69be ffff 75a4 0008 0096 0000 200c 1a30     .i...u....... 0.
 800369c:	9001 2d0a d119 6832 48e1 6002 2003 49e1     ...-..2h.H.`. .I
 80036ac:	2401 46a6 4bf0 44fe 4718 46a6 48de 44fe     .$.F.K.D.G.F.H.D
 80036bc:	4700 200a 2100 9a01 46a6 4bec 44fe 4718     .G. .!...F.K.D.G
 80036cc:	48da 21f5 0089 1808 6238 2d03 d17a 48d7     .H.!....8b.-z..H
 80036dc:	21f5 0089 1808 9002 6870 2800 d10c 2100     .!......ph.(...!
 80036ec:	48d3 6001 48d3 6800 2800 d061 2101 468e     .H.`.H.h.(a..!.F
 80036fc:	49d1 44fe 4708 e05b 48d0 68b1 6001 68f1     .I.D.G[..H.h.`.h
 800370c:	6041 6931 6081 6971 60c1 69b1 63c1 69f1     A`1i.`qi.`.i.c.i
 800371c:	6401 6a31 64c1 2401 46a6 48c9 44fe 4700     .d1j.d.$.F.H.D.G
 800372c:	46a6 ffff 763a 0008 0096 0000 48c8 44fe     .F..:v.......H.D
 800373c:	4700 6870 257d 00ed 42a8 d821 2801 d018     .Gph}%...B!..(..
 800374c:	2802 d005 1c28 46a6 49c2 44fe 4708 e01c     .(..(..F.I.D.G..
 800375c:	48bd 2300 1c19 4359 223e 434a 8382 3002     .H.#..YC>"JC...0
 800376c:	3301 2b10 dbf6 46a6 48b8 44fe 4700 48b9     .3.+...F.H.D.G.H
 800377c:	e00d 4db9 1c28 46a6 49b6 44fe 4708 e004     ...M(..F.I.D.G..
 800378c:	46a6 49b3 44fe 4708 6875 48b2 6005 1c05     .F.I.D.Guh.H.`..
 800379c:	4eab 6830 2800 d106 48b1 6800 46a6 49b0     .N0h.(...H.h.F.I
 80037ac:	44fe 4708 6030 9400 682b 49ae 4aaf 46a6     .D.G0`..+h.I.J.F
 80037bc:	4daf 44fe 4728 48a0 6004 2003 2100 9a01     .M.D(G.H.`. .!..
 80037cc:	2301 ffff 76d0 0008 0096 0000 469e 4bac     .#...v.......F.K
 80037dc:	44fe 4718 9802 6238 bdfe 46c0 0203 0000     .D.G..8b...F....
 80037ec:	c0a3 0002 e9a9 0000 0207 0000 b530 1c05     ............0...
 80037fc:	2000 2401 46a6 49a3 44fe 4708 46a6 49a2     . .$.F.I.D.G.F.I
 800380c:	44fe 4708 46a6 48a1 44fe 4700 217d 00c9     .D.G.F.H.D.G}!..
 800381c:	46a6 4aa0 44fe 4710 4987 312e 1808 499c     .F.J.D.G.I.1...I
 800382c:	8008 489d 300a 6228 bd30 46c0 62e4 0008     ...H.0(b0..F.b..
 800383c:	7f13 0003 1011 0000 7edd 0003 90b9 0000     .........~......
 800384c:	643c 0008 6444 0008 6440 0008 c66d 0003     <d..Dd..@d..m...
 800385c:	1908 001b 1811 0002 78d1 0002 bac9 0003     .........x......
 800386c:	b409 ffff 7766 0008 0096 0000 0003 b5fe     ....fw..........
 800387c:	9002 6945 4668 2101 468e 498a 44fe 4708     ..EihF.!.F.I.D.G
 800388c:	488a 1c04 6868 6901 784a 2700 1c3e 8820     .H..hh.iJx.'>. .
 800389c:	0840 d322 1d20 1c89 2301 469e 4b84 44fe     @.". ....#.F.K.D
 80038ac:	4718 2800 d107 6868 6900 7840 8821 0409     .G.(..hh.i@x!...
 80038bc:	1689 4281 d03d 2002 5f00 9900 1a08 0400     ...B=.. ._......
 80038cc:	1400 283c dd03 8820 1040 0040 8020 1c78     ..<(.. .@.@. .x.
 80038dc:	0607 0e3f 6868 6901 784a 342a 3601 2e14     ..?.hh.iJx*4.6..
 80038ec:	dbd5 2a00 d102 20ab 0040 e050 9b00 486e     ...*... @.P...nH
 80038fc:	2114 2200 8804 0864 d303 302a 3201 3901     .!."..d...*0.2.9
 800390c:	d1f8 ffff 77fc 0008 0096 0000 0612 0e12     .....w..........
 800391c:	2f14 d116 4867 8800 0600 1644 4965 2200     ./..gH....D.eI."
 800392c:	2001 8d4e 0636 1676 42a6 dd02 1c34 0602     . N.6.v..B..4...
 800393c:	0e12 312a 3001 2814 dbf3 e002 0632 0e12     ..*1.0.(....2...
 800394c:	9b00 202a 4342 485b 1811 880c 2001 4320     ..* BC[H.....  C
 800395c:	0400 0c00 8008 24fe 43a0 2414 5764 0664     .......$.C.$dWd.
 800396c:	0e24 4304 4853 5214 1814 8063 8808 0580     $..CSH.R..c.....
 800397c:	0d82 6868 6900 7840 0280 4310 8008 6868     ..hh.i@x...C..hh
 800398c:	6902 1d20 1c91 7852 2301 469e 4b4c 44fe     .i ...Rx.#.FLK.D
 800399c:	4718 9802 6104 20fe 4948 1809 9802 6201     .G...a. HI.....b
 80039ac:	bdfe ffff 7892 0008 0096 0000 6982 6941     .....x.......iAi
 80039bc:	6903 2b02 d10a 2a01 d101 2900 d005 2a02     .i.+...*...)...*
 80039cc:	d104 2900 d102 2111 e000 2106 6141 46f7     ...)...!...!Aa.F
 80039dc:	46c0 e914 0000 18c9 0002 b530 1c05 483b     .F........0...;H
 80039ec:	7800 2800 d004 2001 4686 4839 44fe 4700     .x.(... .F9H.D.G
 80039fc:	2401 46a6 4838 44fe 4700 46a6 4837 44fe     .$.F8H.D.G.F7H.D
 8003a0c:	4700 4836 300e 6228 bd30 1949 0001 7a2f     .G6H.0(b0.I.../z
 8003a1c:	0002 b518 6943 6981 4832 2981 d100 380b     ....Ci.i2H.)...8
 8003a2c:	2100 9100 681a 689b 2401 46a6 4c2e 44fe     .!...h.h.$.F.L.D
 8003a3c:	4720 bd18 b518 6940 2100 9100 6802 6883      G....@i.!...h.h
 8003a4c:	4828 ffff 7928 0008 0096 0000 3001 2401     (H..(y.......0.$
 8003a5c:	46a6 4c27 44fe 4720 bd18 46c0 6330 0008     .F'L.D G...F0c..
 8003a6c:	05ae 0000 9e19 0000 ecb9 0000 3f74 0008     ............t?..
 8003a7c:	3f80 0008 5db7 0003 0000 001b 8ed3 0000     .?...]..........
 8003a8c:	c6f7 0000 90e5 0000 6438 0008 27c0 0009     ........8d...'..
 8003a9c:	3ba0 0008 5d3d 0003 c619 0000 3ae8 0008     .;..=].......:..
 8003aac:	5d81 0003 7ee7 0003 f6cf 0000 4f4b 0003     .]...~......KO..
 8003abc:	c06b 0003 1e95 0001 40da 0008 aa55 0003     k........@..U...
 8003acc:	910d 0000 56d7 0003 5108 0008 c68f 0003     .....V...Q......
 8003adc:	b865 0000 b409 0003 1784 001b 86b5 0001     e...............
 8003aec:	473d ffff 79be 0008 0080 0000 0002 4973     =G...y........sI
 8003afc:	0002 905f 0000 100e 0000 f6f7 0000 b5ff     .._.............
 8003b0c:	4668 f7ff ff74 bdff b5ff 4668 f7ff ff58     hF..t.....hF..X.
 8003b1c:	bdff b5ff 4668 f7ff ff97 bdff b5ff 4668     ....hF........hF
 8003b2c:	f7ff ff81 bdff b5ff 4668 f7ff feb4 bdff     ........hF......
 8003b3c:	b5ff 4668 f7ff fc7f bdff b5ff 4668 f7ff     ..hF........hF..
 8003b4c:	fb37 bdff b5ff 4668 f7ff faed bdff b5ff     7.....hF........
 8003b5c:	4668 f7ff fe64 bdff b5ff 4668 f7ff fb52     hF..d.....hF..R.
 8003b6c:	bdff b5ff 4668 f7ff fdb0 bdff 7b78 0008     ....hF......x{..
 8003b7c:	0088 0000 b500 f0f8 fa43 bd00 6605 0008     ........C....f..
 8003b8c:	6637 0008 6541 0008 661d 0008 6425 0008     7f..Ae...f..%d..
 8003b9c:	6651 0008 665d 0008 6669 0008 6757 0008     Qf..]f..if..Wg..
 8003bac:	6777 0008 67a1 0008 67eb 0008 6827 0008     wg...g...g..'h..
 8003bbc:	6905 0008 6ba9 0008 6bcd 0008 6be9 0008     .i...k...k...k..
 8003bcc:	6c11 0008 6871 0008 6c49 0008 6da1 0008     .l..qh..Il...m..
 8003bdc:	6df9 0008 6e21 0008 6eed 0008 6ccd 0008     .m..!n...n...l..
 8003bec:	6e99 0008 6dc1 0008 0000 0000 0000 0000     .n...m..........
	...
 8003c08:	f304 001a 0080 0000 4eb2 0001 c15a 0000     .........N..Z...
 8003c18:	1a96 0001 0b22 0002 d060 0001 1a06 0000     ...."...`.......
 8003c28:	c6b8 0001 42d8 0003 4216 0003 dbee 0000     .....B...B......
 8003c38:	dc62 0000 e1c8 0000 178a 0002 be38 0000     b...........8...
 8003c48:	c626 0000 c256 0000 1262 0003 f4e4 0001     &...V...b.......
 8003c58:	ec3a 0000 925e 0000 e8fe 0002 7f18 0000     :...^...........
 8003c68:	ec64 0001 44fe 0003 941c 0000 66a8 0003     d....D.......f..
 8003c78:	e974 0002 ffff ffff ffff ffff ffff ffff     t...............
 8003c88:	ffff ffff ffff ffff 0000 0018 0096 0000     ................
 8003c98:	0600 1301 b5f0 b08a 4ce3 2003 7822 7863     .........L. "xcx
 8003ca8:	49e3 3901 2501 46ae 4ee0 44fe 4730 78a2     .I.9.%.F.N.D0G.x
 8003cb8:	78e3 2003 49de 46ae 4edc 44fe 4730 2003     .x. .I.F.N.D0G. 
 8003cc8:	49db 3101 46ae 4adb 44fe 4710 48da 7821     .I.1.F.J.D.G.H!x
 8003cd8:	7001 7861 7041 78e1 70c1 78a1 7081 48d9     .paxAp.x.p.x.p.H
 8003ce8:	1c04 3c33 1c20 2100 22dc 46ae 4bd3 44fe     ..3< ..!.".F.K.D
 8003cf8:	4718 2084 70a0 2705 71e7 260c 7326 200d     .G. .p.'.q.&&s. 
 8003d08:	1900 a1b0 1c32 46ae 4bcd 44fe 4718 2004     ....2..F.K.D.G. 
 8003d18:	7660 201a 1900 a1af 9108 2204 46ae 4bc8     `v. .......".F.K
 8003d28:	44fe 4718 77a7 ffff 0096 0018 0096 0000     .D.G.w..........
 8003d38:	341f a1ac 9109 1c20 1c3a 46ae 4bc3 44fe     .4.... .:..F.K.D
 8003d48:	4718 71e6 1c28 7260 2011 7320 2094 7360     .G.q(.`r.  s. `s
 8003d58:	25c0 7465 74a6 2209 74e2 4cbc 1c20 a1a3     .%et.t.".t.L ...
 8003d68:	2301 469e 4bb9 44fe 4718 2207 7262 4cb7     .#.F.K.D.G."br.L
 8003d78:	340a 1c20 a1a1 2301 469e 4bb3 44fe 4718     .4 ....#.F.K.D.G
 8003d88:	2004 71e0 4cb2 3412 1c20 9908 2204 2301     . .q.L.4 ....".#
 8003d98:	469e 4bad 44fe 4718 7127 4cac 3417 1c20     .F.K.D.G'q.L.4 .
 8003da8:	9909 1c3a 2301 469e 4ba8 44fe 4718 71e6     ..:..#.F.K.D.G.q
 8003db8:	2001 7260 2011 7320 2094 7360 2002 73e0     . `r.  s. `s. .s
 8003dc8:	7425 7466 74a5 ffff 012c 0018 0096 0000     %tft.t..,.......
 8003dd8:	262f 74e6 2010 7560 2780 75a7 2001 75e0     /&.t. `u.'.u. .u
 8003de8:	2011 76a0 2094 76e0 2024 7760 220a 77a2     . .v. .v$ `w.".w
 8003df8:	4c99 3436 1c20 a185 2301 469e 4b95 44fe     .L64 ....#.F.K.D
 8003e08:	4718 2218 72a2 4c94 3441 1c20 a182 2301     .G.".r.LA4 ....#
 8003e18:	469e 4b90 44fe 4718 7625 7666 2021 76e0     .F.K.D.G%vfv! .v
 8003e28:	7727 2001 7760 488c 3061 2111 7001 2194     'w. `w.Ha0.!.p.!
 8003e38:	7041 260f 70c6 2104 7201 21d2 7241 2106     Ap.&.p.!.r.!Ar.!
 8003e48:	7281 4c85 346c 1c20 a17a 2206 2301 469e     .r.Ll4 .z..".#.F
 8003e58:	4b80 44fe 4718 71a5 201e 71e0 7225 209e     .K.D.G.q. .q%r. 
 8003e68:	7260 2001 72e0 ffff 01c2 0018 0096 0000     `r. .r..........
 8003e78:	7327 7360 2011 7420 2094 7460 2004 74e0     's`s.  t. `t. .t
 8003e88:	20b3 4978 6008 2400 0631 0e09 2000 aa02     . xI.`.$1.... ..
 8003e98:	2301 469e 4b75 44fe 4718 4668 8900 0840     .#.FuK.D.GhF..@.
 8003ea8:	d30e 00a1 200f 43c2 4668 8903 4013 ad03     ..... .ChF...@..
 8003eb8:	526b 8940 4010 4469 81c8 1c60 0404 0c24     kR@..@iD..`...$.
 8003ec8:	3e01 2e0b dae0 1e60 0402 0c12 d01c 1c15     .>....`.........
 8003ed8:	ab03 2101 889e 0088 af02 5a3f 42b7 da0b     ...!......?Z.B..
 8003ee8:	46bc 1c07 446f 897f 4468 8106 3008 88de     .F..oD..hD...0..
 8003ef8:	8046 4660 8098 80df 3304 1c48 0401 0c09     F.`F.....3H.....
 8003f08:	3d01 d1e7 3a01 ffff 0258 0018 0096 0000     .=...:..X.......
 8003f18:	d1e2 4668 8981 89c2 1851 0409 0c09 4d56     ..hF....Q.....VM
 8003f28:	8029 4b56 8982 1a9a 89c0 1a10 8068 7928     ).VK........h.(y
 8003f38:	9000 882a 1a58 0403 0c1b 2003 4946 3911     ..*.X...... FI.9
 8003f48:	2601 46b6 4e4e 44fe 4730 2c02 db30 1e67     .&.FNN.D0G.,0.g.
 8003f58:	ae03 2401 1c20 9009 9809 0080 a902 5a09     ...$ ..........Z
 8003f68:	88b0 88f2 1812 428a da1a 2006 4360 4b42     .......B... `CBK
 8003f78:	1818 8002 8802 1a89 8041 2101 7101 8841     ........A..!.qA.
 8003f88:	9100 2101 9101 1c22 8803 2003 4932 3910     ...!..".... 2I.9
 8003f98:	2501 46ae 4d3b 44fe 4728 1c60 0404 0c24     .%.F;M.D(G`...$.
 8003fa8:	3604 9809 1c40 ffff 02ee 0018 0096 0000     .6..@...........
 8003fb8:	0600 0e00 9009 3f01 d1d3 2400 4835 7004     .......?...$5H.p
 8003fc8:	4835 7004 4835 7004 4835 7004 2001 4686     5H.p5H.p5H.p. .F
 8003fd8:	4834 44fe 4700 4933 1c22 6808 2800 d002     4H.D.G3I"..h.(..
 8003fe8:	2001 4090 4304 3104 3201 2a20 d3f5 482e     . .@.C.1.2 *...H
 8003ff8:	6004 b00a bdf0 645f 7665 6369 2d65 6e69     .`...._device-in
 8004008:	6f66 c000 c046 755f 7064 c000 c046 6f6c     fo..F._udp..F.lo
 8004018:	6163 006c 46c0 735f 7265 6976 6563 0073     cal..F_services.
 8004028:	46c0 645f 736e 732d 0064 6564 3d76 4343     .F_dns-sd.dev=CC
 8004038:	3033 3030 c000 6576 646e 726f 543d 7865     3000..vendor=Tex
 8004048:	7361 492d 736e ffff 0384 0018 0096 0000     as-Ins..........
 8004058:	7274 6d75 6e65 7374 c000 c046 6174 6772     truments..F.targ
 8004068:	7465 c000 0000 0018 7ef3 0003 05c6 0000     et.......~......
 8004078:	7edd 0003 62e4 0008 bac9 0003 b409 0003     .~...b..........
 8004088:	6477 0008 6440 0008 0add 0002 3248 0008     wd..@d......H2..
 8004098:	8000 ffff 7f01 0003 7f13 0003 62e8 0008     .............b..
 80040a8:	62e9 0008 62ea 0008 62eb 0008 03ed 0018     .b...b...b......
 80040b8:	7b80 0008 f384 001a 490d 480e 6788 480e     .{.......I.H.g.H
 80040c8:	6488 480e 6448 480e 64c8 480e 6508 4811     .d.HHd.H.d.H.e.H
 80040d8:	1c02 3204 4b0c 6013 4b0c 6293 4a0c 668a     ...2.K.`.K.b.J.f
 80040e8:	490d 6001 480d ffff 041a 0018 0042 0000     .I.`.H......B...
 80040f8:	490e 6001 490e 6041 46f7 211c 0008 7a17     .I.`.IA`.F.!...z
 8004108:	0008 7a0d 0008 7a03 0008 7a35 0008 7a2b     ...z...z..5z..+z
 8004118:	0008 7a21 0008 79f9 0008 79db 0008 2350     ..!z...y...y..P#
 8004128:	0008 79d1 0008 2658 0008 79ef 0008 79e5     ...y..X&...y...y
 8004138:	0008 ffff                                   ....

0800413c <fw_patch>:
 800413c:	0100 0000 1200 0000 0000 0018 1504 0000     ................
 800414c:	0004 0000 f1b8 0f90 16a4 0000 00c8 0000     ................
 800415c:	e066 a804 1d35 f021 fc99 4668 f023 fb28     f...5.!...hF#.(.
 800416c:	f89a 0000 2801 d107 4628 f005 fec3 4601     .....(..(F.....F
 800417c:	aa01 2000 f021 f950 4628 f005 febb a901     ... !.P.(F......
 800418c:	f021 fa2a 79e9 ea4f 00e0 b240 b111 f100     !.*..yO...@.....
 800419c:	0006 b240 71a8 381f 0040 71e8 4630 f001     ..@..q.8@..q0F..
 80041ac:	ff0d f110 0900 f04f 0100 d009 6828 0c40     ......O.....(h@.
 80041bc:	d309 68e8 0bc0 d203 4648 f7ff fedd 2101     ...h....HF.....!
 80041cc:	6828 0c40 d20a 6838 1c40 6038 6820 f36f     (h@...8h@.8` ho.
 80041dc:	000f 6020 6822 6838 4310 6020 68e8 0bc0     .. `"h8h.C `.h..
 80041ec:	d30f f8d8 0000 f100 0001 f8c8 0000 6820     .............. h
 80041fc:	f36f 401f 6020 f8d8 2000 6820 ea40 4002     o..@ `...  h@..@
 800420c:	6020 b949 f1b9 0f00 d103 4630 f007 f9be      `I.......0F....
 800421c:	e002 4648 f007 fa06 176c 0000 0014 0000     ..HF....l.......
 800422c:	4668 f00e fb85 9e00 2e00 d196 b005 e8bd     hF..............
 800423c:	87f0 46c0 209c 0000 0004 0000 f023 fd7a     ...F. ......#.z.
 800424c:	4774 0000 0008 0000 210b f021 f9cb 6820     tG.......!!... h
 800425c:	4b18 0000 0014 0000 f021 f86c e00a 6820     .K......!.l... h
 800426c:	6800 210c f040 0020 f021 f864 6204 0000     .h.!@. .!.d..b..
 800427c:	0008 0000 7920 f01f fca5 e069 ad34 0000     .... y....i.4...
 800428c:	0004 0000 6809 29ff ad98 0000 0004 0000     .....h.)........
 800429c:	1000 21d4 d3dc 0000 0010 0000 b500 f018     ...!............
 80042ac:	fbfb f000 f803 bd00 0000 0000 dfc0 0000     ................
 80042bc:	0004 0000 f017 fd3c f7c8 0000 0020 0000     ......<..... ...
 80042cc:	2e31 3931 332e 3431 4e5f 7765 465f 4354     1.19.314_New_FTC
 80042dc:	6c5f 6e65 7467 5f68 6f6d 7564 616c 6974     _length_modulati
 80042ec:	7e80 0001 0004 0000 f8df 8258 7ef4 0001     .~........X..~..
 80042fc:	0004 0000 487a 496b 7f9c 0001 0004 0000     ....zHkI........
 800430c:	7000 4d51 7fc4 0001 003c 0000 4940 f100     .pQM....<...@I..
 800431c:	0052 4a3a 81a8 8328 83e8 84e8 85a8 602a     R.:J..(.......*`
 800432c:	4839 f241 1211 852a 9018 9119 4939 911a     9HA...*.....9I..
 800433c:	4939 911b 4939 4620 f8df 90c4 911c 4938     9I..9I F......8I
 800434c:	f8df b0c0 4e31 911d 8048 0001 0004 0000     ....1N..H.......
 800435c:	f00d fa7c 80b4 0001 0034 0000 1234 0966     ..|.....4...4.f.
 800436c:	6b84 2000 7094 2000 70b4 2000 78c4 2000     .k. .p. .p. .x. 
 800437c:	7a50 2000 fffe 0003 70a4 2000 70b0 2000     Pz. .....p. .p. 
 800438c:	70b8 2000 5560 8030 5c3c 2000 7404 2000     .p. `U0.<\. .t. 
 800439c:	4d04 0002 00c8 0000 e92d 4ff0 f1ad 0d8c     .M......-..O....
 80043ac:	6804 300f 9403 f7fe fadb f104 0014 9004     .h.0............
 80043bc:	7d21 2000 f021 0173 2988 bf08 2001 9005     !}. !.s..)... ..
 80043cc:	9803 1d00 9006 485d 6800 2801 f040 83fa     ......]H.h.(@...
 80043dc:	4d5b 485c f8df 9170 6829 f8df 8170 f8df     [M\H..p.)h..p...
 80043ec:	a174 4288 d121 2210 2100 4648 464f f7fb     t..B!..".!HFOF..
 80043fc:	feb7 2210 2100 4640 f7fb feb2 4954 6808     ...".!@F....TI.h
 800440c:	f440 1080 6008 2001 4651 6008 2100 6029     @....`. QF.`.!)`
 800441c:	7839 4646 9100 7831 f241 1311 2204 9101     9xFF..1xA...."..
 800442c:	2107 9002 2003 f7f3 fc41 4651 9107 6808     .!... ..A.QF...h
 800443c:	4956 f8df b15c 2801 9108 4956 f8df a148     VI..\..(..VI..H.
 800444c:	9109 4955 910a 4944 910b 4944 910c 4944     ..UI..DI..DI..DI
 800445c:	910d 4944 910e 4944 910f 4944 9110 4944     ..DI..DI..DI..DI
 800446c:	4dcc 0002 00c8 0000 9111 4944 9112 4944     .M........DI..DI
 800447c:	9113 4944 9114 4944 9115 4944 9116 499f     ..DI..DI..DI...I
 800448c:	9117 499f 9118 499f 9119 499f 911a 499f     ...I...I...I...I
 800449c:	911b 499f 911c 499f 911d 499f 911e 499f     ...I...I...I...I
 80044ac:	911f f040 8100 9804 7840 f000 0103 2901     ..@.....@x.....)
 80044bc:	f040 80f9 9904 7809 f001 010c 2908 f040     @......x.....)@.
 80044cc:	80f2 9906 8809 f1a1 013c b20e 9905 b111     ........<.......
 80044dc:	f1a6 0602 b236 09c0 f04f 0700 d315 3e08     ....6...O......>
 80044ec:	b236 2e03 d010 2e17 d00e 3e08 b236 2e03     6..........>6...
 80044fc:	d008 2e17 d006 1f36 b236 2e03 bf14 2e17     ......6.6.......
 800450c:	2702 e002 2703 e000 2701 2e03 bf18 2e17     .'...'...'......
 800451c:	9a04 f040 80c8 320a f812 1b01 2405 f812     ..@....2.....$..
 800452c:	3b01 404b 1e64 b2d9 d1f9 ea81 1121 2e03     .;K@d.......!...
 800453c:	4e94 0002 00c8 0000 f001 010f 4648 d035     .N..........HF5.
 800454c:	4643 5cca 1c52 54ca 180c e033 5748 0002     CF.\R..T..3.HW..
 800455c:	7404 2000 1234 0966 5758 0002 5768 0002     .t. 4.f.XW..hW..
 800456c:	48c8 8030 5744 0002 5780 0002 5778 0002     .H0.DW...W..xW..
 800457c:	5810 0002 5818 0002 5820 0002 5828 0002     .X...X.. X..(X..
 800458c:	5830 0002 5838 0002 58dc 0002 58da 0002     0X..8X...X...X..
 800459c:	580c 0002 58e7 0002 58d8 0002 58e6 0002     .X...X...X...X..
 80045ac:	5754 0002 58de 0002 58e0 0002 180c 7820     TW...X...X.... x
 80045bc:	1c40 7020 7820 4643 eb03 0801 280a db76     @. p xCF.....(v.
 80045cc:	f898 0000 280a db72 4894 2500 6001 9804     .....(r..H.%.`..
 80045dc:	f100 090a 7840 0841 bf24 9904 1d09 d204     ....@xA.$.......
 80045ec:	0880 bf2e 4649 9904 3110 980b 2206 f7fa     ....IF...1..."..
 80045fc:	fcb9 980c 2206 4649 f7fa fcb4 489b 499a     ....."IF.....H.I
 800460c:	4f5c 0002 00c8 0000 7800 2208 6008 4658     \O.......x.".`XF
 800461c:	6007 980d 4629 f7fb fdaf 2208 980e 4629     .`..)F....."..)F
 800462c:	f7fb fdaa 2208 980f 4629 f7fb fda5 2208     ....."..)F....."
 800463c:	9810 4629 f7fb fda0 2208 9811 4629 f7fb     ..)F....."..)F..
 800464c:	fd9b 2208 9812 4629 f7fb fd96 9907 2002     ..."..)F....... 
 800465c:	6008 9913 4628 8008 9908 7008 9914 7008     .`..(F.....p...p
 800466c:	9915 6008 9916 7008 9917 6008 9918 6008     ...`...p...`...`
 800467c:	9919 6008 9909 8008 990a 8008 991a 8008     ...`............
 800468c:	497d 600d 991b 7008 991c 7008 991d 7008     }I.`...p...p...p
 800469c:	991e 8008 991f 8008 4651 8008 7820 9600     ........QF.. x..
 80046ac:	2204 9001 f898 0000 f241 1314 2107 9002     ."......A....!..
 80046bc:	2003 f7f3 fb07 9807 49a2 6800 9120 49a2     . .......I.h ..I
 80046cc:	2805 9121 499e 9122 f040 8237 9804 7840     .(!..I".@.7...@x
 80046dc:	5024 0002 00c8 0000 0841 bf24 9904 1d09     $P......A.$.....
 80046ec:	d205 0880 bf27 9904 310a 9904 3110 980b     ....'....1...1..
 80046fc:	f7f8 fc2d 2801 9804 f040 8223 7840 f000     ..-..(..@.#.@x..
 800470c:	0003 2803 d018 2802 bf07 9904 3110 9904     ...(...(.....1..
 800471c:	310a e013 5840 0002 5844 0002 5848 0002     .1..@X..DX..HX..
 800472c:	58e8 0002 58ea 0002 58eb 0002 58ec 0002     .X...X...X...X..
 800473c:	58e2 0002 58e4 0002 9904 3118 980c f7f8     .X...X.....1....
 800474c:	fc06 9904 2801 f040 81fc 7849 f001 0103     .....(@...Ix....
 800475c:	2901 f040 81f6 4659 6809 9a04 468e 4651     .)@...YF.h...FQF
 800476c:	8ad2 880b 1112 4293 f000 8237 800a 9906     .......B..7.....
 800477c:	8809 393c b20b 4671 1e49 d009 1e49 d004     ..<9..qFI...I...
 800478c:	1e49 d108 f1a3 0310 e004 f1a3 0314 e001     I...............
 800479c:	f1a3 0308 b21b 9805 b110 f1a3 0302 b21b     ................
 80047ac:	50ec 0002 00c8 0000 2b00 f100 81ce 9816     .P.......+......
 80047bc:	f240 5177 4299 900b 9814 9005 f000 81a3     @.wQ.B..........
 80047cc:	4608 f100 003c 4298 9a05 f000 819a f8df     .F..<..B........
 80047dc:	8248 7814 9a0b 2cbb 7812 920c d163 f8dd     H..x...,.x..c...
 80047ec:	c068 f9bc 2000 4291 bf18 4290 d15b 2b1c     h.... .B...B[..+
 80047fc:	f04f 0000 f2c0 8182 2b3d 9d13 f280 817e     O.......=+....~.
 800480c:	f1a3 011c b209 8029 9a1e f8dd 9030 f9b2     ......).....0...
 800481c:	6000 f1b9 0f01 d115 f8dd 9024 2e03 da0d     .`........$.....
 800482c:	f9b9 7000 42b9 d007 2601 8016 464a 460e     ...p.B...&..JF.F
 800483c:	e003 46c0 5788 0002 1c76 8016 9a1b 7816     ...F.W..v......x
 800484c:	9a1d 7016 9a0c 9e1f 2a02 d128 f9b6 2000     ...p.....*(.... 
 800485c:	f1be 0f00 d01a 2a03 4635 da0b 9e0a f9b6     .......*5F......
 800486c:	7000 42b9 d004 2201 802a 460a 4635 e000     .p.B..."*..F5F..
 800487c:	51b4 0002 00c8 0000 1c52 802a 991c 780a     .Q......R.*....x
 800488c:	991d 700a e00f 46c0 5750 0002 64a6 2000     ...p...FPW...d. 
 800489c:	574c 0002 8028 9905 7008 9a08 7811 f041     LW..(....p...xA.
 80048ac:	0104 7011 4604 4645 f8ac 0000 7028 2ccc     ...p.FEF....(p.,
 80048bc:	9a09 f040 8100 f8dd c07c 990a 9f1e 4645     ..@.....|.....EF
 80048cc:	f9b1 6000 f9b2 9000 7828 f8cd c050 9116     ...`....(x..P...
 80048dc:	970a 9213 9509 990c 2901 d105 9a05 ebb0     .........)......
 80048ec:	0f49 d101 2100 7011 990c 2902 d105 9a05     I....!.p...)....
 80048fc:	ebb0 0f46 d101 2100 7011 f5b3 7f14 f340     ..F....!.p....@.
 800490c:	80ba f240 3151 4299 9908 f340 80b4 7809     ..@.Q1.B..@....x
 800491c:	2906 f000 80b0 f2a3 2151 b20b ea4f 01e3     .)......Q!..O...
 800492c:	eb03 7111 ea4f 1121 b2ca ea4f 01e3 eb03     ...qO.!...O.....
 800493c:	7111 9d15 f021 010f eba3 0301 991d 682e     .q..!..........h
 800494c:	527c 0002 00c8 0000 f891 e000 fa5f f883     |R.........._...
 800495c:	b160 1831 f811 1c01 4051 b2cb e007 46c0     `.1.....Q@.....F
 800496c:	5850 0002 584c 0002 58d4 0002 4613 9919     PX..LX...X...F..
 800497c:	f8dd a06c f8dd b070 f8d1 c000 f000 010f     ..l...p.........
 800498c:	4299 d022 9b0a 4586 f89a 1000 f9b3 3000     .B"....E.......0
 800499c:	f89b 5000 dd15 5c37 1c44 ea82 0c07 f004     ...P..7\D.......
 80049ac:	070f 4567 d00b 45a6 4406 dd0a 7876 4072     ..gE...E.D..vxr@
 80049bc:	1c86 f006 060f 4296 d103 1cc0 e04d 1c80     .......B....M...
 80049cc:	e04b 9e05 2200 7032 e04a f000 011f 2201     K...."2pJ......"
 80049dc:	408a 9917 10c4 680b f024 0103 f85c 7001     .@.....h$...\..p
 80049ec:	423a d132 585f 423a 4406 d01f 9b18 7837     :B2._X:B.D....7x
 80049fc:	681b 45b8 d104 5858 4202 d019 4663 e015     .h.E..XX.B..cF..
 8004a0c:	10a1 008c 5919 4391 5119 9000 7830 9001     .....Y.C.Q..0x..
 8004a1c:	5344 0002 00c8 0000 2003 2106 4602 f64d     DS....... .!.FM.
 8004a2c:	5380 f7f3 f963 9909 6828 780e 1836 e006     .S..c...(h.x6...
 8004a3c:	58db 0002 10a0 0081 5858 4302 505a f886     .X......XX.CZP..
 8004a4c:	8000 980b 7800 900c 9813 f9b0 9000 9809     .....x..........
 8004a5c:	7800 9a0a 1c40 f89b 5000 f89a 1000 f9b2     .x..@....P......
 8004a6c:	3000 9a09 b2c0 7010 9a0c 2a01 d103 4288     .0.....p...*...B
 8004a7c:	bfc8 f88a 0000 990c 2902 d107 42a8 bfc8     .........)...B..
 8004a8c:	f88b 0000 e002 980a f9b0 3000 f1b9 0f00     ...........0....
 8004a9c:	dd06 2b03 d104 9811 2201 4649 f000 fb70     ...+....."IF..p.
 8004aac:	9816 f9b0 1000 9814 2900 f9b0 0000 dd05     .........)......
 8004abc:	2803 d103 9812 2202 f000 fb62 9805 7804     .(....."..b....x
 8004acc:	980b 7800 900c 9808 2cbb 7801 d002 2caa     ...x.....,.x...,
 8004adc:	d02f e031 980c 2801 d10b 980d 9a17 6010     /.1....(.......`
 8004aec:	540c 0002 00c8 0000 980f 9a18 6010 9a19     .T...........`..
 8004afc:	9811 6010 4a47 9815 6002 980c 2802 d10b     ...`GJ...`...(..
 8004b0c:	980e 9a17 6010 9810 9a18 6010 9a19 9812     .....`.....`....
 8004b1c:	6010 4a41 9815 6002 20cc e00f 9908 7809     .`AJ...`. .....x
 8004b2c:	e00c 2002 e000 2001 990b 7008 991a 800b     ... ... ...p....
 8004b3c:	9913 2000 8008 9808 7801 20bb 9a05 7010     ... .....x. ...p
 8004b4c:	2906 9907 d111 2006 6008 9820 2500 7005     .)..... .` ..%.p
 8004b5c:	9821 4629 2204 f7fb fb27 2001 f000 fa36     !.)F."..'.. ..6.
 8004b6c:	2002 f000 fa33 9822 6005 9807 9904 6800     . ..3."..`.....h
 8004b7c:	2807 d144 7809 9c03 2980 d140 3438 7821     .(D..x...)@.84!x
 8004b8c:	1c64 4622 2900 d13a 9820 f890 a000 9822     d."F.):. .....".
 8004b9c:	9005 f8d0 9000 4651 4648 f7fd f979 fa5f     ......QFHF..y._.
 8004bac:	f880 9f21 7815 4651 4648 f817 3008 f7fd     ..!..xQFHF...0..
 8004bbc:	54d4 0002 00c8 0000 f96f 461e 1d1b b2c0     .T......o..F....
 8004bcc:	5c38 1d00 42a8 4628 dd07 1880 1c82 7810     8\...B(F.......x
 8004bdc:	182d 1cad b2ad 42ab dcf7 f804 6b01 4911     -......B.....k.I
 8004bec:	4632 4620 eb01 1148 f7fa f9dc 1bad 20ff     2F F..H........ 
 8004bfc:	1934 1ead f804 0b01 7025 9805 6801 1c49     4.......%p...hI.
 8004c0c:	6001 9807 6800 2807 d004 9906 6808 f420     .`...h.(.....h .
 8004c1c:	3080 6008 b023 e8bd 8ff0 46c0 578c 0002     .0.`#......F.W..
 8004c2c:	57cc 0002 5854 0002 486d e92d 47f0 4d6d     .W..TX..mH-..GmM
 8004c3c:	8982 f64a 2155 f5ad 7dfe 4291 f04f 0100     ..J.U!...}.BO...
 8004c4c:	f1ad 0d38 d110 6029 f241 4110 8181 f64f     ..8...)`A..A..O.
 8004c5c:	70ff 4965 6008 6828 9000 2202 2105 2003     .peI.`(h...".!. 
 8004c6c:	f241 2334 f7f3 f84a 6829 4c60 2901 6820     A.4#..J.)h`L.) h
 8004c7c:	f040 80af 4d5e 2802 6829 d123 485d 6800     @...^M.()h#.]H.h
 8004c8c:	559c 0002 00c8 0000 4a5e 5c12 9200 9101     .U......^J.\....
 8004c9c:	495d 6809 9102 495a 5c0b 2003 2107 2204     ]I.h..ZI.\. .!."
 8004cac:	f7f3 f830 495a 794a 4858 9200 7902 9201     ..0.ZIJyXH...y..
 8004cbc:	7940 2204 9002 2003 790b 2107 f7f3 f822     @y."... .y.!..".
 8004ccc:	2003 6020 f7ec ff1c 6820 6829 2804 d115     .  `.... h)h.(..
 8004cdc:	200d f88d 0010 2500 f88d 5014 f88d 1015     . .....%...P....
 8004cec:	4628 2163 f000 fafc 2163 4628 f000 fa86     (Fc!....c!(F....
 8004cfc:	a903 a804 f7e0 fccc 2005 6020 4d45 2805     .........  `EM.(
 8004d0c:	6829 f101 0101 6029 d11d 4a43 428a d11a     )h....)`..CJ.B..
 8004d1c:	4842 6801 9100 6840 9001 2003 4602 2106     BH.h..@h... .F.!
 8004d2c:	4e40 4633 3b22 f7f2 ffed 483d 6801 9100     @N3F";....=H.h..
 8004d3c:	6840 4633 2106 9001 2003 4602 f7f2 ffe2     @h3F.!... .F....
 8004d4c:	2000 6028 6820 2806 d147 f04f 0a07 f8c4     . (` h.(G.O.....
 8004d5c:	5664 0002 00c8 0000 a000 2003 f248 5370     dV......... H.pS
 8004d6c:	2201 2104 f7f2 ffd2 f8df 80c8 4f30 f248     .".!........0OH.
 8004d7c:	5970 2501 ea49 0305 2201 2104 2003 f7f2     pY.%I....".!. ..
 8004d8c:	ffc5 2400 f817 0f02 e020 0169 eb04 0208     ...$.... .i.....
 8004d9c:	1888 1cc6 7843 9300 7880 9001 7830 9002     ....Cx...x..0x..
 8004dac:	5c53 4651 2204 2003 f7f2 ffb0 7838 1b01     S\QF.". ....8x..
 8004dbc:	f1b1 3fff d108 78f0 9000 78b3 2003 2202     ...?...x...x. ."
 8004dcc:	2105 f7f2 ffa3 7838 1d24 b2e4 42a0 dcdc     .!....8x$....B..
 8004ddc:	1cad b2ed 2d04 dbcd 2163 f44f 7005 f7f1     .....-..c!O..p..
 8004dec:	fca5 f7e1 fd87 b07f b00e e8bd 87f0 46c0     ...............F
 8004dfc:	7404 2000 5748 0002 0040 803d 5744 0002     .t. HW..@.=.DW..
 8004e0c:	5750 0002 5788 0002 5758 0002 5768 0002     PW...W..XW..hW..
 8004e1c:	5754 0002 5778 0002 5780 0002 574c 0002     TW..xW...W..LW..
 8004e2c:	572c 0002 00c8 0000 ffff 0003 5830 0002     ,W..........0X..
 8004e3c:	5838 0002 5566 eedd 58d3 0002 5854 0002     8X..fU...X..TX..
	...
 8004efc:	57f4 0002 00c8 0000 0000 0000 0000 0000     .W..............
	...
 8004fcc:	58bc 0002 00c8 0000 0000 0000 0000 0000     .X..............
	...
 8005008:	e92d 4ffe 4a4a 4d49 9000 f9b2 2000 a343     -..OJJIM..... C.
 8005018:	7829 9301 a343 2801 9302 4e47 f8df 811c     )x..C..(..GN....
 8005028:	f8df 911c d01e 4843 7804 0148 1987 1830     ......CH.xH...0.
 8005038:	9901 2206 f7f9 ffcc 4640 7801 6800 f107     ..."....@F.x.h..
 8005048:	0706 f807 1b01 f807 4b01 f04f 0100 f807     .........KO.....
 8005058:	1b01 b920 7039 7828 464e 210a e058 f8df     .. .9p(xNF.!X...
 8005068:	b0e4 e00f b2d4 0148 1987 1830 9902 2207     ......H...0...."
 8005078:	f7f9 ffae 1dff 2000 f8df b0cc f807 4b01     ....... .......K
 8005088:	f807 0b01 2c16 46b2 bfae 2014 1e60 b2c0     .....,.F... `...
 8005098:	7038 464e 5984 0002 00c8 0000 1c7f 1c40     8pNF.Y........@.
 80050a8:	b2c2 7828 465b 2100 5432 4638 f000 f910     ..(x[F.!2T8F....
 80050b8:	7828 2c16 5c31 f101 010a 5431 f100 0001     (x.,1\....1T....
 80050c8:	b2c0 7028 db2b 9900 eb0a 1040 4607 2901     ..(p+.....@..F.)
 80050d8:	f1a4 0901 d009 9901 2206 f7f9 ff7d 4640     ........."..}.@F
 80050e8:	7800 1dbf f807 0b01 e004 9902 2207 f7f9     .x..........."..
 80050f8:	ff73 1dff f807 4b01 3c15 2115 7828 b2e2     s......K.<.!(x..
 8005108:	465b f807 1b01 5432 f807 9b01 4638 f000     [F....2T....8F..
 8005118:	f8df 7828 5c31 310a 5431 1c40 7028 e8bd     ..(x1\.11T@.(p..
 8005128:	8ffe 46c0 5454 4b54 5945 c000 5454 5354     ...FTTTKEY..TTTS
 8005138:	4953 0044 584c 0002 58de 0002 58e0 0002     SID.LX...X...X..
 8005148:	5854 0002 5754 0002 58d4 0002 57cc 0002     TX..TW...X...W..
 8005158:	578c 0002 b57e 4604 460d f894 1036 4a15     .W..~..F.F..6..J
 8005168:	2907 bf18 5a4c 0002 00c8 0000 6811 d10a     .)..LZ.......h..
 8005178:	2101 6011 4b12 260d f104 0224 1e76 f842     .!.`.K.&..$.v.B.
 8005188:	3f14 6053 d1fa f894 0036 4e0e 9000 6830     .?S`....6..N..0h
 8005198:	f241 1312 2204 9001 9102 2107 2003 f7f2     A....".....!. ..
 80051a8:	fdcb 4629 4620 f7e7 fc81 6831 2200 2905     ..)F F....1h.".)
 80051b8:	d102 4905 3108 600a bd7e 46c0 5748 0002     ...I.1.`~..FHW..
 80051c8:	86a0 0001 5744 0002 7c00 2000 b570 004d     ....DW...|. p.M.
 80051d8:	2d20 f04f 0100 460c ea4f 1355 d309 f850      -O....FO.U...P.
 80051e8:	6021 f1b6 3fff d104 1c49 b2c9 3d20 1e5b     !`...?..I... =[.
 80051f8:	d1f5 b14d 2d20 d209 2301 40ab 1e5b f850     ..M. -...#.@[.P.
 8005208:	0021 4018 4283 d101 f04f 0401 4807 7803     !..@.B..O....H.x
 8005218:	b92c 2101 4091 43c9 b2c9 400b e003 2101     ,..!.@.C...@...!
 8005228:	4091 b2c9 430b 7003 bd70 46c0 58e6 0002     .@...C.pp..F.X..
 8005238:	b51c 4c0f 5b14 0002 00c8 0000 6822 2a01     ...L.[......"h.*
 8005248:	d115 480c 6800 2807 bf14 2040 f44f 7005     ...H.h.(..@ O..p
 8005258:	2163 f7f1 fa85 6820 9000 f243 3333 2106     c!.... h..C.33.!
 8005268:	2040 9001 2003 4602 f7f2 fd6a bd1c f7f1     @ ... .F..j.....
 8005278:	fa77 bd1c 5744 0002 5748 0002 b51e 4604     w...DW..HW.....F
 8005288:	490a 2000 4a0a 6008 490a 9000 9001 6011     .I. .J.`.I.....`
 8005298:	4a09 f245 5355 9102 6010 2107 2204 2003     .JE.US...`.!.". 
 80052a8:	f7f2 fd4e 4620 f7e7 fdcf bd1e 5748 0002     ..N. F......HW..
 80052b8:	7404 2000 1234 0966 5744 0002 b530 460d     .t. 4.f.DW..0..F
 80052c8:	6984 f7dc fc47 1d24 2801 eb04 0145 d106     .i..G.$..(..E...
 80052d8:	8e89 eb04 0485 b911 6921 b901 2000 bd30     ........!i... 0.
 80052e8:	b530 4605 b15a eb03 0341 781c 7859 ea41     0..FZ...A..xYxA.
 80052f8:	1104 1e52 f103 0302 f805 1b01 d1f5 bd30     ..R...........0.
 8005308:	b500 2000 5bdc 0002 0030 0000 f7e7 ff86     ... .[..0.......
 8005318:	4803 6801 2903 bf04 2104 6001 bd00 46c0     .H.h.)...!.`...F
 8005328:	5744 0002 4a03 6812 2a01 bf04 4802 2163     DW...J.h.*...Hc!
 8005338:	f7f1 ba26 5748 0002 2002 0001 534c 0000     ..&.HW... ..LS..
